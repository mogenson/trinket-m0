/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.1.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __CM0PLUS_REV: u32 = 1;
pub const __MPU_PRESENT: u32 = 0;
pub const __NVIC_PRIO_BITS: u32 = 2;
pub const __VTOR_PRESENT: u32 = 1;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __CM_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM_CMSIS_VERSION_SUB: u32 = 1;
pub const __CM_CMSIS_VERSION: u32 = 327681;
pub const __CM0PLUS_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM0PLUS_CMSIS_VERSION_SUB: u32 = 1;
pub const __CM0PLUS_CMSIS_VERSION: u32 = 327681;
pub const __CORTEX_M: u32 = 0;
pub const __FPU_USED: u32 = 0;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 8;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967040;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const SCS_BASE: u32 = 3758153728;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const NVIC_USER_IRQ_OFFSET: u32 = 16;
pub const EXC_RETURN_HANDLER: u32 = 4294967281;
pub const EXC_RETURN_THREAD_MSP: u32 = 4294967289;
pub const EXC_RETURN_THREAD_PSP: u32 = 4294967293;
pub const REV_AC: u32 = 273;
pub const AC_CTRLA_OFFSET: u32 = 0;
pub const AC_CTRLA_SWRST_Pos: u32 = 0;
pub const AC_CTRLA_ENABLE_Pos: u32 = 1;
pub const AC_CTRLA_RUNSTDBY_Pos: u32 = 2;
pub const AC_CTRLA_LPMUX_Pos: u32 = 7;
pub const AC_CTRLB_OFFSET: u32 = 1;
pub const AC_CTRLB_START0_Pos: u32 = 0;
pub const AC_CTRLB_START1_Pos: u32 = 1;
pub const AC_CTRLB_START_Pos: u32 = 0;
pub const AC_EVCTRL_OFFSET: u32 = 2;
pub const AC_EVCTRL_COMPEO0_Pos: u32 = 0;
pub const AC_EVCTRL_COMPEO1_Pos: u32 = 1;
pub const AC_EVCTRL_COMPEO_Pos: u32 = 0;
pub const AC_EVCTRL_WINEO0_Pos: u32 = 4;
pub const AC_EVCTRL_WINEO_Pos: u32 = 4;
pub const AC_EVCTRL_COMPEI0_Pos: u32 = 8;
pub const AC_EVCTRL_COMPEI1_Pos: u32 = 9;
pub const AC_EVCTRL_COMPEI_Pos: u32 = 8;
pub const AC_INTENCLR_OFFSET: u32 = 4;
pub const AC_INTENCLR_COMP0_Pos: u32 = 0;
pub const AC_INTENCLR_COMP1_Pos: u32 = 1;
pub const AC_INTENCLR_COMP_Pos: u32 = 0;
pub const AC_INTENCLR_WIN0_Pos: u32 = 4;
pub const AC_INTENCLR_WIN_Pos: u32 = 4;
pub const AC_INTENSET_OFFSET: u32 = 5;
pub const AC_INTENSET_COMP0_Pos: u32 = 0;
pub const AC_INTENSET_COMP1_Pos: u32 = 1;
pub const AC_INTENSET_COMP_Pos: u32 = 0;
pub const AC_INTENSET_WIN0_Pos: u32 = 4;
pub const AC_INTENSET_WIN_Pos: u32 = 4;
pub const AC_INTFLAG_OFFSET: u32 = 6;
pub const AC_INTFLAG_COMP0_Pos: u32 = 0;
pub const AC_INTFLAG_COMP1_Pos: u32 = 1;
pub const AC_INTFLAG_COMP_Pos: u32 = 0;
pub const AC_INTFLAG_WIN0_Pos: u32 = 4;
pub const AC_INTFLAG_WIN_Pos: u32 = 4;
pub const AC_STATUSA_OFFSET: u32 = 8;
pub const AC_STATUSA_STATE0_Pos: u32 = 0;
pub const AC_STATUSA_STATE1_Pos: u32 = 1;
pub const AC_STATUSA_STATE_Pos: u32 = 0;
pub const AC_STATUSA_WSTATE0_Pos: u32 = 4;
pub const AC_STATUSB_OFFSET: u32 = 9;
pub const AC_STATUSB_READY0_Pos: u32 = 0;
pub const AC_STATUSB_READY1_Pos: u32 = 1;
pub const AC_STATUSB_READY_Pos: u32 = 0;
pub const AC_STATUSB_SYNCBUSY_Pos: u32 = 7;
pub const AC_STATUSC_OFFSET: u32 = 10;
pub const AC_STATUSC_STATE0_Pos: u32 = 0;
pub const AC_STATUSC_STATE1_Pos: u32 = 1;
pub const AC_STATUSC_STATE_Pos: u32 = 0;
pub const AC_STATUSC_WSTATE0_Pos: u32 = 4;
pub const AC_WINCTRL_OFFSET: u32 = 12;
pub const AC_WINCTRL_WEN0_Pos: u32 = 0;
pub const AC_WINCTRL_WINTSEL0_Pos: u32 = 1;
pub const AC_COMPCTRL_OFFSET: u32 = 16;
pub const AC_COMPCTRL_ENABLE_Pos: u32 = 0;
pub const AC_COMPCTRL_SINGLE_Pos: u32 = 1;
pub const AC_COMPCTRL_SPEED_Pos: u32 = 2;
pub const AC_COMPCTRL_INTSEL_Pos: u32 = 5;
pub const AC_COMPCTRL_MUXNEG_Pos: u32 = 8;
pub const AC_COMPCTRL_MUXPOS_Pos: u32 = 12;
pub const AC_COMPCTRL_SWAP_Pos: u32 = 15;
pub const AC_COMPCTRL_OUT_Pos: u32 = 16;
pub const AC_COMPCTRL_HYST_Pos: u32 = 19;
pub const AC_COMPCTRL_FLEN_Pos: u32 = 24;
pub const AC_SCALER_OFFSET: u32 = 32;
pub const AC_SCALER_VALUE_Pos: u32 = 0;
pub const REV_ADC: u32 = 288;
pub const ADC_CTRLA_OFFSET: u32 = 0;
pub const ADC_CTRLA_SWRST_Pos: u32 = 0;
pub const ADC_CTRLA_ENABLE_Pos: u32 = 1;
pub const ADC_CTRLA_RUNSTDBY_Pos: u32 = 2;
pub const ADC_REFCTRL_OFFSET: u32 = 1;
pub const ADC_REFCTRL_REFSEL_Pos: u32 = 0;
pub const ADC_REFCTRL_REFCOMP_Pos: u32 = 7;
pub const ADC_AVGCTRL_OFFSET: u32 = 2;
pub const ADC_AVGCTRL_SAMPLENUM_Pos: u32 = 0;
pub const ADC_AVGCTRL_ADJRES_Pos: u32 = 4;
pub const ADC_SAMPCTRL_OFFSET: u32 = 3;
pub const ADC_SAMPCTRL_SAMPLEN_Pos: u32 = 0;
pub const ADC_CTRLB_OFFSET: u32 = 4;
pub const ADC_CTRLB_DIFFMODE_Pos: u32 = 0;
pub const ADC_CTRLB_LEFTADJ_Pos: u32 = 1;
pub const ADC_CTRLB_FREERUN_Pos: u32 = 2;
pub const ADC_CTRLB_CORREN_Pos: u32 = 3;
pub const ADC_CTRLB_RESSEL_Pos: u32 = 4;
pub const ADC_CTRLB_PRESCALER_Pos: u32 = 8;
pub const ADC_WINCTRL_OFFSET: u32 = 8;
pub const ADC_WINCTRL_WINMODE_Pos: u32 = 0;
pub const ADC_SWTRIG_OFFSET: u32 = 12;
pub const ADC_SWTRIG_FLUSH_Pos: u32 = 0;
pub const ADC_SWTRIG_START_Pos: u32 = 1;
pub const ADC_INPUTCTRL_OFFSET: u32 = 16;
pub const ADC_INPUTCTRL_MUXPOS_Pos: u32 = 0;
pub const ADC_INPUTCTRL_MUXNEG_Pos: u32 = 8;
pub const ADC_INPUTCTRL_INPUTSCAN_Pos: u32 = 16;
pub const ADC_INPUTCTRL_INPUTOFFSET_Pos: u32 = 20;
pub const ADC_INPUTCTRL_GAIN_Pos: u32 = 24;
pub const ADC_EVCTRL_OFFSET: u32 = 20;
pub const ADC_EVCTRL_STARTEI_Pos: u32 = 0;
pub const ADC_EVCTRL_SYNCEI_Pos: u32 = 1;
pub const ADC_EVCTRL_RESRDYEO_Pos: u32 = 4;
pub const ADC_EVCTRL_WINMONEO_Pos: u32 = 5;
pub const ADC_INTENCLR_OFFSET: u32 = 22;
pub const ADC_INTENCLR_RESRDY_Pos: u32 = 0;
pub const ADC_INTENCLR_OVERRUN_Pos: u32 = 1;
pub const ADC_INTENCLR_WINMON_Pos: u32 = 2;
pub const ADC_INTENCLR_SYNCRDY_Pos: u32 = 3;
pub const ADC_INTENSET_OFFSET: u32 = 23;
pub const ADC_INTENSET_RESRDY_Pos: u32 = 0;
pub const ADC_INTENSET_OVERRUN_Pos: u32 = 1;
pub const ADC_INTENSET_WINMON_Pos: u32 = 2;
pub const ADC_INTENSET_SYNCRDY_Pos: u32 = 3;
pub const ADC_INTFLAG_OFFSET: u32 = 24;
pub const ADC_INTFLAG_RESRDY_Pos: u32 = 0;
pub const ADC_INTFLAG_OVERRUN_Pos: u32 = 1;
pub const ADC_INTFLAG_WINMON_Pos: u32 = 2;
pub const ADC_INTFLAG_SYNCRDY_Pos: u32 = 3;
pub const ADC_STATUS_OFFSET: u32 = 25;
pub const ADC_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const ADC_RESULT_OFFSET: u32 = 26;
pub const ADC_RESULT_RESULT_Pos: u32 = 0;
pub const ADC_WINLT_OFFSET: u32 = 28;
pub const ADC_WINLT_WINLT_Pos: u32 = 0;
pub const ADC_WINUT_OFFSET: u32 = 32;
pub const ADC_WINUT_WINUT_Pos: u32 = 0;
pub const ADC_GAINCORR_OFFSET: u32 = 36;
pub const ADC_GAINCORR_GAINCORR_Pos: u32 = 0;
pub const ADC_OFFSETCORR_OFFSET: u32 = 38;
pub const ADC_OFFSETCORR_OFFSETCORR_Pos: u32 = 0;
pub const ADC_CALIB_OFFSET: u32 = 40;
pub const ADC_CALIB_LINEARITY_CAL_Pos: u32 = 0;
pub const ADC_CALIB_BIAS_CAL_Pos: u32 = 8;
pub const ADC_DBGCTRL_OFFSET: u32 = 42;
pub const ADC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const REV_DAC: u32 = 272;
pub const DAC_CTRLA_OFFSET: u32 = 0;
pub const DAC_CTRLA_SWRST_Pos: u32 = 0;
pub const DAC_CTRLA_ENABLE_Pos: u32 = 1;
pub const DAC_CTRLA_RUNSTDBY_Pos: u32 = 2;
pub const DAC_CTRLB_OFFSET: u32 = 1;
pub const DAC_CTRLB_EOEN_Pos: u32 = 0;
pub const DAC_CTRLB_IOEN_Pos: u32 = 1;
pub const DAC_CTRLB_LEFTADJ_Pos: u32 = 2;
pub const DAC_CTRLB_VPD_Pos: u32 = 3;
pub const DAC_CTRLB_BDWP_Pos: u32 = 4;
pub const DAC_CTRLB_REFSEL_Pos: u32 = 6;
pub const DAC_EVCTRL_OFFSET: u32 = 2;
pub const DAC_EVCTRL_STARTEI_Pos: u32 = 0;
pub const DAC_EVCTRL_EMPTYEO_Pos: u32 = 1;
pub const DAC_INTENCLR_OFFSET: u32 = 4;
pub const DAC_INTENCLR_UNDERRUN_Pos: u32 = 0;
pub const DAC_INTENCLR_EMPTY_Pos: u32 = 1;
pub const DAC_INTENCLR_SYNCRDY_Pos: u32 = 2;
pub const DAC_INTENSET_OFFSET: u32 = 5;
pub const DAC_INTENSET_UNDERRUN_Pos: u32 = 0;
pub const DAC_INTENSET_EMPTY_Pos: u32 = 1;
pub const DAC_INTENSET_SYNCRDY_Pos: u32 = 2;
pub const DAC_INTFLAG_OFFSET: u32 = 6;
pub const DAC_INTFLAG_UNDERRUN_Pos: u32 = 0;
pub const DAC_INTFLAG_EMPTY_Pos: u32 = 1;
pub const DAC_INTFLAG_SYNCRDY_Pos: u32 = 2;
pub const DAC_STATUS_OFFSET: u32 = 7;
pub const DAC_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const DAC_DATA_OFFSET: u32 = 8;
pub const DAC_DATA_DATA_Pos: u32 = 0;
pub const DAC_DATABUF_OFFSET: u32 = 12;
pub const DAC_DATABUF_DATABUF_Pos: u32 = 0;
pub const REV_DMAC: u32 = 256;
pub const DMAC_CTRL_OFFSET: u32 = 0;
pub const DMAC_CTRL_SWRST_Pos: u32 = 0;
pub const DMAC_CTRL_DMAENABLE_Pos: u32 = 1;
pub const DMAC_CTRL_CRCENABLE_Pos: u32 = 2;
pub const DMAC_CTRL_LVLEN0_Pos: u32 = 8;
pub const DMAC_CTRL_LVLEN1_Pos: u32 = 9;
pub const DMAC_CTRL_LVLEN2_Pos: u32 = 10;
pub const DMAC_CTRL_LVLEN3_Pos: u32 = 11;
pub const DMAC_CTRL_LVLEN_Pos: u32 = 8;
pub const DMAC_CRCCTRL_OFFSET: u32 = 2;
pub const DMAC_CRCCTRL_CRCBEATSIZE_Pos: u32 = 0;
pub const DMAC_CRCCTRL_CRCPOLY_Pos: u32 = 2;
pub const DMAC_CRCCTRL_CRCSRC_Pos: u32 = 8;
pub const DMAC_CRCDATAIN_OFFSET: u32 = 4;
pub const DMAC_CRCDATAIN_CRCDATAIN_Pos: u32 = 0;
pub const DMAC_CRCCHKSUM_OFFSET: u32 = 8;
pub const DMAC_CRCCHKSUM_CRCCHKSUM_Pos: u32 = 0;
pub const DMAC_CRCSTATUS_OFFSET: u32 = 12;
pub const DMAC_CRCSTATUS_CRCBUSY_Pos: u32 = 0;
pub const DMAC_CRCSTATUS_CRCZERO_Pos: u32 = 1;
pub const DMAC_DBGCTRL_OFFSET: u32 = 13;
pub const DMAC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const DMAC_QOSCTRL_OFFSET: u32 = 14;
pub const DMAC_QOSCTRL_WRBQOS_Pos: u32 = 0;
pub const DMAC_QOSCTRL_FQOS_Pos: u32 = 2;
pub const DMAC_QOSCTRL_DQOS_Pos: u32 = 4;
pub const DMAC_SWTRIGCTRL_OFFSET: u32 = 16;
pub const DMAC_SWTRIGCTRL_SWTRIG0_Pos: u32 = 0;
pub const DMAC_SWTRIGCTRL_SWTRIG1_Pos: u32 = 1;
pub const DMAC_SWTRIGCTRL_SWTRIG2_Pos: u32 = 2;
pub const DMAC_SWTRIGCTRL_SWTRIG3_Pos: u32 = 3;
pub const DMAC_SWTRIGCTRL_SWTRIG4_Pos: u32 = 4;
pub const DMAC_SWTRIGCTRL_SWTRIG5_Pos: u32 = 5;
pub const DMAC_SWTRIGCTRL_SWTRIG6_Pos: u32 = 6;
pub const DMAC_SWTRIGCTRL_SWTRIG7_Pos: u32 = 7;
pub const DMAC_SWTRIGCTRL_SWTRIG8_Pos: u32 = 8;
pub const DMAC_SWTRIGCTRL_SWTRIG9_Pos: u32 = 9;
pub const DMAC_SWTRIGCTRL_SWTRIG10_Pos: u32 = 10;
pub const DMAC_SWTRIGCTRL_SWTRIG11_Pos: u32 = 11;
pub const DMAC_SWTRIGCTRL_SWTRIG_Pos: u32 = 0;
pub const DMAC_PRICTRL0_OFFSET: u32 = 20;
pub const DMAC_PRICTRL0_LVLPRI0_Pos: u32 = 0;
pub const DMAC_PRICTRL0_RRLVLEN0_Pos: u32 = 7;
pub const DMAC_PRICTRL0_LVLPRI1_Pos: u32 = 8;
pub const DMAC_PRICTRL0_RRLVLEN1_Pos: u32 = 15;
pub const DMAC_PRICTRL0_LVLPRI2_Pos: u32 = 16;
pub const DMAC_PRICTRL0_RRLVLEN2_Pos: u32 = 23;
pub const DMAC_PRICTRL0_LVLPRI3_Pos: u32 = 24;
pub const DMAC_PRICTRL0_RRLVLEN3_Pos: u32 = 31;
pub const DMAC_INTPEND_OFFSET: u32 = 32;
pub const DMAC_INTPEND_ID_Pos: u32 = 0;
pub const DMAC_INTPEND_TERR_Pos: u32 = 8;
pub const DMAC_INTPEND_TCMPL_Pos: u32 = 9;
pub const DMAC_INTPEND_SUSP_Pos: u32 = 10;
pub const DMAC_INTPEND_FERR_Pos: u32 = 13;
pub const DMAC_INTPEND_BUSY_Pos: u32 = 14;
pub const DMAC_INTPEND_PEND_Pos: u32 = 15;
pub const DMAC_INTSTATUS_OFFSET: u32 = 36;
pub const DMAC_INTSTATUS_CHINT0_Pos: u32 = 0;
pub const DMAC_INTSTATUS_CHINT1_Pos: u32 = 1;
pub const DMAC_INTSTATUS_CHINT2_Pos: u32 = 2;
pub const DMAC_INTSTATUS_CHINT3_Pos: u32 = 3;
pub const DMAC_INTSTATUS_CHINT4_Pos: u32 = 4;
pub const DMAC_INTSTATUS_CHINT5_Pos: u32 = 5;
pub const DMAC_INTSTATUS_CHINT6_Pos: u32 = 6;
pub const DMAC_INTSTATUS_CHINT7_Pos: u32 = 7;
pub const DMAC_INTSTATUS_CHINT8_Pos: u32 = 8;
pub const DMAC_INTSTATUS_CHINT9_Pos: u32 = 9;
pub const DMAC_INTSTATUS_CHINT10_Pos: u32 = 10;
pub const DMAC_INTSTATUS_CHINT11_Pos: u32 = 11;
pub const DMAC_INTSTATUS_CHINT_Pos: u32 = 0;
pub const DMAC_BUSYCH_OFFSET: u32 = 40;
pub const DMAC_BUSYCH_BUSYCH0_Pos: u32 = 0;
pub const DMAC_BUSYCH_BUSYCH1_Pos: u32 = 1;
pub const DMAC_BUSYCH_BUSYCH2_Pos: u32 = 2;
pub const DMAC_BUSYCH_BUSYCH3_Pos: u32 = 3;
pub const DMAC_BUSYCH_BUSYCH4_Pos: u32 = 4;
pub const DMAC_BUSYCH_BUSYCH5_Pos: u32 = 5;
pub const DMAC_BUSYCH_BUSYCH6_Pos: u32 = 6;
pub const DMAC_BUSYCH_BUSYCH7_Pos: u32 = 7;
pub const DMAC_BUSYCH_BUSYCH8_Pos: u32 = 8;
pub const DMAC_BUSYCH_BUSYCH9_Pos: u32 = 9;
pub const DMAC_BUSYCH_BUSYCH10_Pos: u32 = 10;
pub const DMAC_BUSYCH_BUSYCH11_Pos: u32 = 11;
pub const DMAC_BUSYCH_BUSYCH_Pos: u32 = 0;
pub const DMAC_PENDCH_OFFSET: u32 = 44;
pub const DMAC_PENDCH_PENDCH0_Pos: u32 = 0;
pub const DMAC_PENDCH_PENDCH1_Pos: u32 = 1;
pub const DMAC_PENDCH_PENDCH2_Pos: u32 = 2;
pub const DMAC_PENDCH_PENDCH3_Pos: u32 = 3;
pub const DMAC_PENDCH_PENDCH4_Pos: u32 = 4;
pub const DMAC_PENDCH_PENDCH5_Pos: u32 = 5;
pub const DMAC_PENDCH_PENDCH6_Pos: u32 = 6;
pub const DMAC_PENDCH_PENDCH7_Pos: u32 = 7;
pub const DMAC_PENDCH_PENDCH8_Pos: u32 = 8;
pub const DMAC_PENDCH_PENDCH9_Pos: u32 = 9;
pub const DMAC_PENDCH_PENDCH10_Pos: u32 = 10;
pub const DMAC_PENDCH_PENDCH11_Pos: u32 = 11;
pub const DMAC_PENDCH_PENDCH_Pos: u32 = 0;
pub const DMAC_ACTIVE_OFFSET: u32 = 48;
pub const DMAC_ACTIVE_LVLEX0_Pos: u32 = 0;
pub const DMAC_ACTIVE_LVLEX1_Pos: u32 = 1;
pub const DMAC_ACTIVE_LVLEX2_Pos: u32 = 2;
pub const DMAC_ACTIVE_LVLEX3_Pos: u32 = 3;
pub const DMAC_ACTIVE_LVLEX_Pos: u32 = 0;
pub const DMAC_ACTIVE_ID_Pos: u32 = 8;
pub const DMAC_ACTIVE_ABUSY_Pos: u32 = 15;
pub const DMAC_ACTIVE_BTCNT_Pos: u32 = 16;
pub const DMAC_BASEADDR_OFFSET: u32 = 52;
pub const DMAC_BASEADDR_BASEADDR_Pos: u32 = 0;
pub const DMAC_WRBADDR_OFFSET: u32 = 56;
pub const DMAC_WRBADDR_WRBADDR_Pos: u32 = 0;
pub const DMAC_CHID_OFFSET: u32 = 63;
pub const DMAC_CHID_ID_Pos: u32 = 0;
pub const DMAC_CHCTRLA_OFFSET: u32 = 64;
pub const DMAC_CHCTRLA_SWRST_Pos: u32 = 0;
pub const DMAC_CHCTRLA_ENABLE_Pos: u32 = 1;
pub const DMAC_CHCTRLB_OFFSET: u32 = 68;
pub const DMAC_CHCTRLB_EVACT_Pos: u32 = 0;
pub const DMAC_CHCTRLB_EVIE_Pos: u32 = 3;
pub const DMAC_CHCTRLB_EVOE_Pos: u32 = 4;
pub const DMAC_CHCTRLB_LVL_Pos: u32 = 5;
pub const DMAC_CHCTRLB_TRIGSRC_Pos: u32 = 8;
pub const DMAC_CHCTRLB_TRIGACT_Pos: u32 = 22;
pub const DMAC_CHCTRLB_CMD_Pos: u32 = 24;
pub const DMAC_CHINTENCLR_OFFSET: u32 = 76;
pub const DMAC_CHINTENCLR_TERR_Pos: u32 = 0;
pub const DMAC_CHINTENCLR_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTENCLR_SUSP_Pos: u32 = 2;
pub const DMAC_CHINTENSET_OFFSET: u32 = 77;
pub const DMAC_CHINTENSET_TERR_Pos: u32 = 0;
pub const DMAC_CHINTENSET_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTENSET_SUSP_Pos: u32 = 2;
pub const DMAC_CHINTFLAG_OFFSET: u32 = 78;
pub const DMAC_CHINTFLAG_TERR_Pos: u32 = 0;
pub const DMAC_CHINTFLAG_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTFLAG_SUSP_Pos: u32 = 2;
pub const DMAC_CHSTATUS_OFFSET: u32 = 79;
pub const DMAC_CHSTATUS_PEND_Pos: u32 = 0;
pub const DMAC_CHSTATUS_BUSY_Pos: u32 = 1;
pub const DMAC_CHSTATUS_FERR_Pos: u32 = 2;
pub const DMAC_BTCTRL_OFFSET: u32 = 0;
pub const DMAC_BTCTRL_VALID_Pos: u32 = 0;
pub const DMAC_BTCTRL_EVOSEL_Pos: u32 = 1;
pub const DMAC_BTCTRL_BLOCKACT_Pos: u32 = 3;
pub const DMAC_BTCTRL_BEATSIZE_Pos: u32 = 8;
pub const DMAC_BTCTRL_SRCINC_Pos: u32 = 10;
pub const DMAC_BTCTRL_DSTINC_Pos: u32 = 11;
pub const DMAC_BTCTRL_STEPSEL_Pos: u32 = 12;
pub const DMAC_BTCTRL_STEPSIZE_Pos: u32 = 13;
pub const DMAC_BTCNT_OFFSET: u32 = 2;
pub const DMAC_BTCNT_BTCNT_Pos: u32 = 0;
pub const DMAC_SRCADDR_OFFSET: u32 = 4;
pub const DMAC_SRCADDR_SRCADDR_Pos: u32 = 0;
pub const DMAC_DSTADDR_OFFSET: u32 = 8;
pub const DMAC_DSTADDR_DSTADDR_Pos: u32 = 0;
pub const DMAC_DESCADDR_OFFSET: u32 = 12;
pub const DMAC_DESCADDR_DESCADDR_Pos: u32 = 0;
pub const REV_DSU: u32 = 512;
pub const DSU_CTRL_OFFSET: u32 = 0;
pub const DSU_CTRL_SWRST_Pos: u32 = 0;
pub const DSU_CTRL_CRC_Pos: u32 = 2;
pub const DSU_CTRL_MBIST_Pos: u32 = 3;
pub const DSU_CTRL_CE_Pos: u32 = 4;
pub const DSU_STATUSA_OFFSET: u32 = 1;
pub const DSU_STATUSA_DONE_Pos: u32 = 0;
pub const DSU_STATUSA_CRSTEXT_Pos: u32 = 1;
pub const DSU_STATUSA_BERR_Pos: u32 = 2;
pub const DSU_STATUSA_FAIL_Pos: u32 = 3;
pub const DSU_STATUSA_PERR_Pos: u32 = 4;
pub const DSU_STATUSB_OFFSET: u32 = 2;
pub const DSU_STATUSB_PROT_Pos: u32 = 0;
pub const DSU_STATUSB_DBGPRES_Pos: u32 = 1;
pub const DSU_STATUSB_DCCD0_Pos: u32 = 2;
pub const DSU_STATUSB_DCCD1_Pos: u32 = 3;
pub const DSU_STATUSB_DCCD_Pos: u32 = 2;
pub const DSU_STATUSB_HPE_Pos: u32 = 4;
pub const DSU_ADDR_OFFSET: u32 = 4;
pub const DSU_ADDR_ADDR_Pos: u32 = 2;
pub const DSU_LENGTH_OFFSET: u32 = 8;
pub const DSU_LENGTH_LENGTH_Pos: u32 = 2;
pub const DSU_DATA_OFFSET: u32 = 12;
pub const DSU_DATA_DATA_Pos: u32 = 0;
pub const DSU_DCC_OFFSET: u32 = 16;
pub const DSU_DCC_DATA_Pos: u32 = 0;
pub const DSU_DID_OFFSET: u32 = 24;
pub const DSU_DID_DEVSEL_Pos: u32 = 0;
pub const DSU_DID_REVISION_Pos: u32 = 8;
pub const DSU_DID_DIE_Pos: u32 = 12;
pub const DSU_DID_SERIES_Pos: u32 = 16;
pub const DSU_DID_FAMILY_Pos: u32 = 23;
pub const DSU_DID_PROCESSOR_Pos: u32 = 28;
pub const DSU_ENTRY_OFFSET: u32 = 4096;
pub const DSU_ENTRY_EPRES_Pos: u32 = 0;
pub const DSU_ENTRY_FMT_Pos: u32 = 1;
pub const DSU_ENTRY_ADDOFF_Pos: u32 = 12;
pub const DSU_ENTRY1_OFFSET: u32 = 4100;
pub const DSU_END_OFFSET: u32 = 4104;
pub const DSU_END_END_Pos: u32 = 0;
pub const DSU_MEMTYPE_OFFSET: u32 = 8140;
pub const DSU_MEMTYPE_SMEMP_Pos: u32 = 0;
pub const DSU_PID4_OFFSET: u32 = 8144;
pub const DSU_PID4_JEPCC_Pos: u32 = 0;
pub const DSU_PID4_FKBC_Pos: u32 = 4;
pub const DSU_PID0_OFFSET: u32 = 8160;
pub const DSU_PID0_PARTNBL_Pos: u32 = 0;
pub const DSU_PID1_OFFSET: u32 = 8164;
pub const DSU_PID1_PARTNBH_Pos: u32 = 0;
pub const DSU_PID1_JEPIDCL_Pos: u32 = 4;
pub const DSU_PID2_OFFSET: u32 = 8168;
pub const DSU_PID2_JEPIDCH_Pos: u32 = 0;
pub const DSU_PID2_JEPU_Pos: u32 = 3;
pub const DSU_PID2_REVISION_Pos: u32 = 4;
pub const DSU_PID3_OFFSET: u32 = 8172;
pub const DSU_PID3_CUSMOD_Pos: u32 = 0;
pub const DSU_PID3_REVAND_Pos: u32 = 4;
pub const DSU_CID0_OFFSET: u32 = 8176;
pub const DSU_CID0_PREAMBLEB0_Pos: u32 = 0;
pub const DSU_CID1_OFFSET: u32 = 8180;
pub const DSU_CID1_PREAMBLE_Pos: u32 = 0;
pub const DSU_CID1_CCLASS_Pos: u32 = 4;
pub const DSU_CID2_OFFSET: u32 = 8184;
pub const DSU_CID2_PREAMBLEB2_Pos: u32 = 0;
pub const DSU_CID3_OFFSET: u32 = 8188;
pub const DSU_CID3_PREAMBLEB3_Pos: u32 = 0;
pub const REV_EIC: u32 = 257;
pub const EIC_CTRL_OFFSET: u32 = 0;
pub const EIC_CTRL_SWRST_Pos: u32 = 0;
pub const EIC_CTRL_ENABLE_Pos: u32 = 1;
pub const EIC_STATUS_OFFSET: u32 = 1;
pub const EIC_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const EIC_NMICTRL_OFFSET: u32 = 2;
pub const EIC_NMICTRL_NMISENSE_Pos: u32 = 0;
pub const EIC_NMICTRL_NMIFILTEN_Pos: u32 = 3;
pub const EIC_NMIFLAG_OFFSET: u32 = 3;
pub const EIC_NMIFLAG_NMI_Pos: u32 = 0;
pub const EIC_EVCTRL_OFFSET: u32 = 4;
pub const EIC_EVCTRL_EXTINTEO0_Pos: u32 = 0;
pub const EIC_EVCTRL_EXTINTEO1_Pos: u32 = 1;
pub const EIC_EVCTRL_EXTINTEO2_Pos: u32 = 2;
pub const EIC_EVCTRL_EXTINTEO3_Pos: u32 = 3;
pub const EIC_EVCTRL_EXTINTEO4_Pos: u32 = 4;
pub const EIC_EVCTRL_EXTINTEO5_Pos: u32 = 5;
pub const EIC_EVCTRL_EXTINTEO6_Pos: u32 = 6;
pub const EIC_EVCTRL_EXTINTEO7_Pos: u32 = 7;
pub const EIC_EVCTRL_EXTINTEO8_Pos: u32 = 8;
pub const EIC_EVCTRL_EXTINTEO9_Pos: u32 = 9;
pub const EIC_EVCTRL_EXTINTEO10_Pos: u32 = 10;
pub const EIC_EVCTRL_EXTINTEO11_Pos: u32 = 11;
pub const EIC_EVCTRL_EXTINTEO12_Pos: u32 = 12;
pub const EIC_EVCTRL_EXTINTEO13_Pos: u32 = 13;
pub const EIC_EVCTRL_EXTINTEO14_Pos: u32 = 14;
pub const EIC_EVCTRL_EXTINTEO15_Pos: u32 = 15;
pub const EIC_EVCTRL_EXTINTEO_Pos: u32 = 0;
pub const EIC_INTENCLR_OFFSET: u32 = 8;
pub const EIC_INTENCLR_EXTINT0_Pos: u32 = 0;
pub const EIC_INTENCLR_EXTINT1_Pos: u32 = 1;
pub const EIC_INTENCLR_EXTINT2_Pos: u32 = 2;
pub const EIC_INTENCLR_EXTINT3_Pos: u32 = 3;
pub const EIC_INTENCLR_EXTINT4_Pos: u32 = 4;
pub const EIC_INTENCLR_EXTINT5_Pos: u32 = 5;
pub const EIC_INTENCLR_EXTINT6_Pos: u32 = 6;
pub const EIC_INTENCLR_EXTINT7_Pos: u32 = 7;
pub const EIC_INTENCLR_EXTINT8_Pos: u32 = 8;
pub const EIC_INTENCLR_EXTINT9_Pos: u32 = 9;
pub const EIC_INTENCLR_EXTINT10_Pos: u32 = 10;
pub const EIC_INTENCLR_EXTINT11_Pos: u32 = 11;
pub const EIC_INTENCLR_EXTINT12_Pos: u32 = 12;
pub const EIC_INTENCLR_EXTINT13_Pos: u32 = 13;
pub const EIC_INTENCLR_EXTINT14_Pos: u32 = 14;
pub const EIC_INTENCLR_EXTINT15_Pos: u32 = 15;
pub const EIC_INTENCLR_EXTINT_Pos: u32 = 0;
pub const EIC_INTENSET_OFFSET: u32 = 12;
pub const EIC_INTENSET_EXTINT0_Pos: u32 = 0;
pub const EIC_INTENSET_EXTINT1_Pos: u32 = 1;
pub const EIC_INTENSET_EXTINT2_Pos: u32 = 2;
pub const EIC_INTENSET_EXTINT3_Pos: u32 = 3;
pub const EIC_INTENSET_EXTINT4_Pos: u32 = 4;
pub const EIC_INTENSET_EXTINT5_Pos: u32 = 5;
pub const EIC_INTENSET_EXTINT6_Pos: u32 = 6;
pub const EIC_INTENSET_EXTINT7_Pos: u32 = 7;
pub const EIC_INTENSET_EXTINT8_Pos: u32 = 8;
pub const EIC_INTENSET_EXTINT9_Pos: u32 = 9;
pub const EIC_INTENSET_EXTINT10_Pos: u32 = 10;
pub const EIC_INTENSET_EXTINT11_Pos: u32 = 11;
pub const EIC_INTENSET_EXTINT12_Pos: u32 = 12;
pub const EIC_INTENSET_EXTINT13_Pos: u32 = 13;
pub const EIC_INTENSET_EXTINT14_Pos: u32 = 14;
pub const EIC_INTENSET_EXTINT15_Pos: u32 = 15;
pub const EIC_INTENSET_EXTINT_Pos: u32 = 0;
pub const EIC_INTFLAG_OFFSET: u32 = 16;
pub const EIC_INTFLAG_EXTINT0_Pos: u32 = 0;
pub const EIC_INTFLAG_EXTINT1_Pos: u32 = 1;
pub const EIC_INTFLAG_EXTINT2_Pos: u32 = 2;
pub const EIC_INTFLAG_EXTINT3_Pos: u32 = 3;
pub const EIC_INTFLAG_EXTINT4_Pos: u32 = 4;
pub const EIC_INTFLAG_EXTINT5_Pos: u32 = 5;
pub const EIC_INTFLAG_EXTINT6_Pos: u32 = 6;
pub const EIC_INTFLAG_EXTINT7_Pos: u32 = 7;
pub const EIC_INTFLAG_EXTINT8_Pos: u32 = 8;
pub const EIC_INTFLAG_EXTINT9_Pos: u32 = 9;
pub const EIC_INTFLAG_EXTINT10_Pos: u32 = 10;
pub const EIC_INTFLAG_EXTINT11_Pos: u32 = 11;
pub const EIC_INTFLAG_EXTINT12_Pos: u32 = 12;
pub const EIC_INTFLAG_EXTINT13_Pos: u32 = 13;
pub const EIC_INTFLAG_EXTINT14_Pos: u32 = 14;
pub const EIC_INTFLAG_EXTINT15_Pos: u32 = 15;
pub const EIC_INTFLAG_EXTINT_Pos: u32 = 0;
pub const EIC_WAKEUP_OFFSET: u32 = 20;
pub const EIC_WAKEUP_WAKEUPEN0_Pos: u32 = 0;
pub const EIC_WAKEUP_WAKEUPEN1_Pos: u32 = 1;
pub const EIC_WAKEUP_WAKEUPEN2_Pos: u32 = 2;
pub const EIC_WAKEUP_WAKEUPEN3_Pos: u32 = 3;
pub const EIC_WAKEUP_WAKEUPEN4_Pos: u32 = 4;
pub const EIC_WAKEUP_WAKEUPEN5_Pos: u32 = 5;
pub const EIC_WAKEUP_WAKEUPEN6_Pos: u32 = 6;
pub const EIC_WAKEUP_WAKEUPEN7_Pos: u32 = 7;
pub const EIC_WAKEUP_WAKEUPEN8_Pos: u32 = 8;
pub const EIC_WAKEUP_WAKEUPEN9_Pos: u32 = 9;
pub const EIC_WAKEUP_WAKEUPEN10_Pos: u32 = 10;
pub const EIC_WAKEUP_WAKEUPEN11_Pos: u32 = 11;
pub const EIC_WAKEUP_WAKEUPEN12_Pos: u32 = 12;
pub const EIC_WAKEUP_WAKEUPEN13_Pos: u32 = 13;
pub const EIC_WAKEUP_WAKEUPEN14_Pos: u32 = 14;
pub const EIC_WAKEUP_WAKEUPEN15_Pos: u32 = 15;
pub const EIC_WAKEUP_WAKEUPEN_Pos: u32 = 0;
pub const EIC_CONFIG_OFFSET: u32 = 24;
pub const EIC_CONFIG_SENSE0_Pos: u32 = 0;
pub const EIC_CONFIG_FILTEN0_Pos: u32 = 3;
pub const EIC_CONFIG_SENSE1_Pos: u32 = 4;
pub const EIC_CONFIG_FILTEN1_Pos: u32 = 7;
pub const EIC_CONFIG_SENSE2_Pos: u32 = 8;
pub const EIC_CONFIG_FILTEN2_Pos: u32 = 11;
pub const EIC_CONFIG_SENSE3_Pos: u32 = 12;
pub const EIC_CONFIG_FILTEN3_Pos: u32 = 15;
pub const EIC_CONFIG_SENSE4_Pos: u32 = 16;
pub const EIC_CONFIG_FILTEN4_Pos: u32 = 19;
pub const EIC_CONFIG_SENSE5_Pos: u32 = 20;
pub const EIC_CONFIG_FILTEN5_Pos: u32 = 23;
pub const EIC_CONFIG_SENSE6_Pos: u32 = 24;
pub const EIC_CONFIG_FILTEN6_Pos: u32 = 27;
pub const EIC_CONFIG_SENSE7_Pos: u32 = 28;
pub const EIC_CONFIG_FILTEN7_Pos: u32 = 31;
pub const REV_EVSYS: u32 = 257;
pub const EVSYS_CTRL_OFFSET: u32 = 0;
pub const EVSYS_CTRL_SWRST_Pos: u32 = 0;
pub const EVSYS_CTRL_GCLKREQ_Pos: u32 = 4;
pub const EVSYS_CHANNEL_OFFSET: u32 = 4;
pub const EVSYS_CHANNEL_CHANNEL_Pos: u32 = 0;
pub const EVSYS_CHANNEL_SWEVT_Pos: u32 = 8;
pub const EVSYS_CHANNEL_EVGEN_Pos: u32 = 16;
pub const EVSYS_CHANNEL_PATH_Pos: u32 = 24;
pub const EVSYS_CHANNEL_EDGSEL_Pos: u32 = 26;
pub const EVSYS_USER_OFFSET: u32 = 8;
pub const EVSYS_USER_USER_Pos: u32 = 0;
pub const EVSYS_USER_CHANNEL_Pos: u32 = 8;
pub const EVSYS_CHSTATUS_OFFSET: u32 = 12;
pub const EVSYS_CHSTATUS_USRRDY0_Pos: u32 = 0;
pub const EVSYS_CHSTATUS_USRRDY1_Pos: u32 = 1;
pub const EVSYS_CHSTATUS_USRRDY2_Pos: u32 = 2;
pub const EVSYS_CHSTATUS_USRRDY3_Pos: u32 = 3;
pub const EVSYS_CHSTATUS_USRRDY4_Pos: u32 = 4;
pub const EVSYS_CHSTATUS_USRRDY5_Pos: u32 = 5;
pub const EVSYS_CHSTATUS_USRRDY6_Pos: u32 = 6;
pub const EVSYS_CHSTATUS_USRRDY7_Pos: u32 = 7;
pub const EVSYS_CHSTATUS_USRRDY_Pos: u32 = 0;
pub const EVSYS_CHSTATUS_CHBUSY0_Pos: u32 = 8;
pub const EVSYS_CHSTATUS_CHBUSY1_Pos: u32 = 9;
pub const EVSYS_CHSTATUS_CHBUSY2_Pos: u32 = 10;
pub const EVSYS_CHSTATUS_CHBUSY3_Pos: u32 = 11;
pub const EVSYS_CHSTATUS_CHBUSY4_Pos: u32 = 12;
pub const EVSYS_CHSTATUS_CHBUSY5_Pos: u32 = 13;
pub const EVSYS_CHSTATUS_CHBUSY6_Pos: u32 = 14;
pub const EVSYS_CHSTATUS_CHBUSY7_Pos: u32 = 15;
pub const EVSYS_CHSTATUS_CHBUSY_Pos: u32 = 8;
pub const EVSYS_CHSTATUS_USRRDY8_Pos: u32 = 16;
pub const EVSYS_CHSTATUS_USRRDY9_Pos: u32 = 17;
pub const EVSYS_CHSTATUS_USRRDY10_Pos: u32 = 18;
pub const EVSYS_CHSTATUS_USRRDY11_Pos: u32 = 19;
pub const EVSYS_CHSTATUS_USRRDYp8_Pos: u32 = 16;
pub const EVSYS_CHSTATUS_CHBUSY8_Pos: u32 = 24;
pub const EVSYS_CHSTATUS_CHBUSY9_Pos: u32 = 25;
pub const EVSYS_CHSTATUS_CHBUSY10_Pos: u32 = 26;
pub const EVSYS_CHSTATUS_CHBUSY11_Pos: u32 = 27;
pub const EVSYS_CHSTATUS_CHBUSYp8_Pos: u32 = 24;
pub const EVSYS_INTENCLR_OFFSET: u32 = 16;
pub const EVSYS_INTENCLR_OVR0_Pos: u32 = 0;
pub const EVSYS_INTENCLR_OVR1_Pos: u32 = 1;
pub const EVSYS_INTENCLR_OVR2_Pos: u32 = 2;
pub const EVSYS_INTENCLR_OVR3_Pos: u32 = 3;
pub const EVSYS_INTENCLR_OVR4_Pos: u32 = 4;
pub const EVSYS_INTENCLR_OVR5_Pos: u32 = 5;
pub const EVSYS_INTENCLR_OVR6_Pos: u32 = 6;
pub const EVSYS_INTENCLR_OVR7_Pos: u32 = 7;
pub const EVSYS_INTENCLR_OVR_Pos: u32 = 0;
pub const EVSYS_INTENCLR_EVD0_Pos: u32 = 8;
pub const EVSYS_INTENCLR_EVD1_Pos: u32 = 9;
pub const EVSYS_INTENCLR_EVD2_Pos: u32 = 10;
pub const EVSYS_INTENCLR_EVD3_Pos: u32 = 11;
pub const EVSYS_INTENCLR_EVD4_Pos: u32 = 12;
pub const EVSYS_INTENCLR_EVD5_Pos: u32 = 13;
pub const EVSYS_INTENCLR_EVD6_Pos: u32 = 14;
pub const EVSYS_INTENCLR_EVD7_Pos: u32 = 15;
pub const EVSYS_INTENCLR_EVD_Pos: u32 = 8;
pub const EVSYS_INTENCLR_OVR8_Pos: u32 = 16;
pub const EVSYS_INTENCLR_OVR9_Pos: u32 = 17;
pub const EVSYS_INTENCLR_OVR10_Pos: u32 = 18;
pub const EVSYS_INTENCLR_OVR11_Pos: u32 = 19;
pub const EVSYS_INTENCLR_OVRp8_Pos: u32 = 16;
pub const EVSYS_INTENCLR_EVD8_Pos: u32 = 24;
pub const EVSYS_INTENCLR_EVD9_Pos: u32 = 25;
pub const EVSYS_INTENCLR_EVD10_Pos: u32 = 26;
pub const EVSYS_INTENCLR_EVD11_Pos: u32 = 27;
pub const EVSYS_INTENCLR_EVDp8_Pos: u32 = 24;
pub const EVSYS_INTENSET_OFFSET: u32 = 20;
pub const EVSYS_INTENSET_OVR0_Pos: u32 = 0;
pub const EVSYS_INTENSET_OVR1_Pos: u32 = 1;
pub const EVSYS_INTENSET_OVR2_Pos: u32 = 2;
pub const EVSYS_INTENSET_OVR3_Pos: u32 = 3;
pub const EVSYS_INTENSET_OVR4_Pos: u32 = 4;
pub const EVSYS_INTENSET_OVR5_Pos: u32 = 5;
pub const EVSYS_INTENSET_OVR6_Pos: u32 = 6;
pub const EVSYS_INTENSET_OVR7_Pos: u32 = 7;
pub const EVSYS_INTENSET_OVR_Pos: u32 = 0;
pub const EVSYS_INTENSET_EVD0_Pos: u32 = 8;
pub const EVSYS_INTENSET_EVD1_Pos: u32 = 9;
pub const EVSYS_INTENSET_EVD2_Pos: u32 = 10;
pub const EVSYS_INTENSET_EVD3_Pos: u32 = 11;
pub const EVSYS_INTENSET_EVD4_Pos: u32 = 12;
pub const EVSYS_INTENSET_EVD5_Pos: u32 = 13;
pub const EVSYS_INTENSET_EVD6_Pos: u32 = 14;
pub const EVSYS_INTENSET_EVD7_Pos: u32 = 15;
pub const EVSYS_INTENSET_EVD_Pos: u32 = 8;
pub const EVSYS_INTENSET_OVR8_Pos: u32 = 16;
pub const EVSYS_INTENSET_OVR9_Pos: u32 = 17;
pub const EVSYS_INTENSET_OVR10_Pos: u32 = 18;
pub const EVSYS_INTENSET_OVR11_Pos: u32 = 19;
pub const EVSYS_INTENSET_OVRp8_Pos: u32 = 16;
pub const EVSYS_INTENSET_EVD8_Pos: u32 = 24;
pub const EVSYS_INTENSET_EVD9_Pos: u32 = 25;
pub const EVSYS_INTENSET_EVD10_Pos: u32 = 26;
pub const EVSYS_INTENSET_EVD11_Pos: u32 = 27;
pub const EVSYS_INTENSET_EVDp8_Pos: u32 = 24;
pub const EVSYS_INTFLAG_OFFSET: u32 = 24;
pub const EVSYS_INTFLAG_OVR0_Pos: u32 = 0;
pub const EVSYS_INTFLAG_OVR1_Pos: u32 = 1;
pub const EVSYS_INTFLAG_OVR2_Pos: u32 = 2;
pub const EVSYS_INTFLAG_OVR3_Pos: u32 = 3;
pub const EVSYS_INTFLAG_OVR4_Pos: u32 = 4;
pub const EVSYS_INTFLAG_OVR5_Pos: u32 = 5;
pub const EVSYS_INTFLAG_OVR6_Pos: u32 = 6;
pub const EVSYS_INTFLAG_OVR7_Pos: u32 = 7;
pub const EVSYS_INTFLAG_OVR_Pos: u32 = 0;
pub const EVSYS_INTFLAG_EVD0_Pos: u32 = 8;
pub const EVSYS_INTFLAG_EVD1_Pos: u32 = 9;
pub const EVSYS_INTFLAG_EVD2_Pos: u32 = 10;
pub const EVSYS_INTFLAG_EVD3_Pos: u32 = 11;
pub const EVSYS_INTFLAG_EVD4_Pos: u32 = 12;
pub const EVSYS_INTFLAG_EVD5_Pos: u32 = 13;
pub const EVSYS_INTFLAG_EVD6_Pos: u32 = 14;
pub const EVSYS_INTFLAG_EVD7_Pos: u32 = 15;
pub const EVSYS_INTFLAG_EVD_Pos: u32 = 8;
pub const EVSYS_INTFLAG_OVR8_Pos: u32 = 16;
pub const EVSYS_INTFLAG_OVR9_Pos: u32 = 17;
pub const EVSYS_INTFLAG_OVR10_Pos: u32 = 18;
pub const EVSYS_INTFLAG_OVR11_Pos: u32 = 19;
pub const EVSYS_INTFLAG_OVRp8_Pos: u32 = 16;
pub const EVSYS_INTFLAG_EVD8_Pos: u32 = 24;
pub const EVSYS_INTFLAG_EVD9_Pos: u32 = 25;
pub const EVSYS_INTFLAG_EVD10_Pos: u32 = 26;
pub const EVSYS_INTFLAG_EVD11_Pos: u32 = 27;
pub const EVSYS_INTFLAG_EVDp8_Pos: u32 = 24;
pub const REV_GCLK: u32 = 528;
pub const GCLK_CTRL_OFFSET: u32 = 0;
pub const GCLK_CTRL_SWRST_Pos: u32 = 0;
pub const GCLK_STATUS_OFFSET: u32 = 1;
pub const GCLK_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const GCLK_CLKCTRL_OFFSET: u32 = 2;
pub const GCLK_CLKCTRL_ID_Pos: u32 = 0;
pub const GCLK_CLKCTRL_GEN_Pos: u32 = 8;
pub const GCLK_CLKCTRL_CLKEN_Pos: u32 = 14;
pub const GCLK_CLKCTRL_WRTLOCK_Pos: u32 = 15;
pub const GCLK_GENCTRL_OFFSET: u32 = 4;
pub const GCLK_GENCTRL_ID_Pos: u32 = 0;
pub const GCLK_GENCTRL_SRC_Pos: u32 = 8;
pub const GCLK_GENCTRL_GENEN_Pos: u32 = 16;
pub const GCLK_GENCTRL_IDC_Pos: u32 = 17;
pub const GCLK_GENCTRL_OOV_Pos: u32 = 18;
pub const GCLK_GENCTRL_OE_Pos: u32 = 19;
pub const GCLK_GENCTRL_DIVSEL_Pos: u32 = 20;
pub const GCLK_GENCTRL_RUNSTDBY_Pos: u32 = 21;
pub const GCLK_GENDIV_OFFSET: u32 = 8;
pub const GCLK_GENDIV_ID_Pos: u32 = 0;
pub const GCLK_GENDIV_DIV_Pos: u32 = 8;
pub const REV_HMATRIXB: u32 = 530;
pub const HMATRIXB_PRAS_OFFSET: u32 = 128;
pub const HMATRIXB_PRBS_OFFSET: u32 = 132;
pub const HMATRIXB_SFR_OFFSET: u32 = 272;
pub const HMATRIXB_SFR_SFR_Pos: u32 = 0;
pub const REV_I2S: u32 = 258;
pub const I2S_CTRLA_OFFSET: u32 = 0;
pub const I2S_CTRLA_SWRST_Pos: u32 = 0;
pub const I2S_CTRLA_ENABLE_Pos: u32 = 1;
pub const I2S_CTRLA_CKEN0_Pos: u32 = 2;
pub const I2S_CTRLA_CKEN1_Pos: u32 = 3;
pub const I2S_CTRLA_CKEN_Pos: u32 = 2;
pub const I2S_CTRLA_SEREN0_Pos: u32 = 4;
pub const I2S_CTRLA_SEREN1_Pos: u32 = 5;
pub const I2S_CTRLA_SEREN_Pos: u32 = 4;
pub const I2S_CLKCTRL_OFFSET: u32 = 4;
pub const I2S_CLKCTRL_SLOTSIZE_Pos: u32 = 0;
pub const I2S_CLKCTRL_NBSLOTS_Pos: u32 = 2;
pub const I2S_CLKCTRL_FSWIDTH_Pos: u32 = 5;
pub const I2S_CLKCTRL_BITDELAY_Pos: u32 = 7;
pub const I2S_CLKCTRL_FSSEL_Pos: u32 = 8;
pub const I2S_CLKCTRL_FSINV_Pos: u32 = 11;
pub const I2S_CLKCTRL_SCKSEL_Pos: u32 = 12;
pub const I2S_CLKCTRL_MCKSEL_Pos: u32 = 16;
pub const I2S_CLKCTRL_MCKEN_Pos: u32 = 18;
pub const I2S_CLKCTRL_MCKDIV_Pos: u32 = 19;
pub const I2S_CLKCTRL_MCKOUTDIV_Pos: u32 = 24;
pub const I2S_CLKCTRL_FSOUTINV_Pos: u32 = 29;
pub const I2S_CLKCTRL_SCKOUTINV_Pos: u32 = 30;
pub const I2S_CLKCTRL_MCKOUTINV_Pos: u32 = 31;
pub const I2S_INTENCLR_OFFSET: u32 = 12;
pub const I2S_INTENCLR_RXRDY0_Pos: u32 = 0;
pub const I2S_INTENCLR_RXRDY1_Pos: u32 = 1;
pub const I2S_INTENCLR_RXRDY_Pos: u32 = 0;
pub const I2S_INTENCLR_RXOR0_Pos: u32 = 4;
pub const I2S_INTENCLR_RXOR1_Pos: u32 = 5;
pub const I2S_INTENCLR_RXOR_Pos: u32 = 4;
pub const I2S_INTENCLR_TXRDY0_Pos: u32 = 8;
pub const I2S_INTENCLR_TXRDY1_Pos: u32 = 9;
pub const I2S_INTENCLR_TXRDY_Pos: u32 = 8;
pub const I2S_INTENCLR_TXUR0_Pos: u32 = 12;
pub const I2S_INTENCLR_TXUR1_Pos: u32 = 13;
pub const I2S_INTENCLR_TXUR_Pos: u32 = 12;
pub const I2S_INTENSET_OFFSET: u32 = 16;
pub const I2S_INTENSET_RXRDY0_Pos: u32 = 0;
pub const I2S_INTENSET_RXRDY1_Pos: u32 = 1;
pub const I2S_INTENSET_RXRDY_Pos: u32 = 0;
pub const I2S_INTENSET_RXOR0_Pos: u32 = 4;
pub const I2S_INTENSET_RXOR1_Pos: u32 = 5;
pub const I2S_INTENSET_RXOR_Pos: u32 = 4;
pub const I2S_INTENSET_TXRDY0_Pos: u32 = 8;
pub const I2S_INTENSET_TXRDY1_Pos: u32 = 9;
pub const I2S_INTENSET_TXRDY_Pos: u32 = 8;
pub const I2S_INTENSET_TXUR0_Pos: u32 = 12;
pub const I2S_INTENSET_TXUR1_Pos: u32 = 13;
pub const I2S_INTENSET_TXUR_Pos: u32 = 12;
pub const I2S_INTFLAG_OFFSET: u32 = 20;
pub const I2S_INTFLAG_RXRDY0_Pos: u32 = 0;
pub const I2S_INTFLAG_RXRDY1_Pos: u32 = 1;
pub const I2S_INTFLAG_RXRDY_Pos: u32 = 0;
pub const I2S_INTFLAG_RXOR0_Pos: u32 = 4;
pub const I2S_INTFLAG_RXOR1_Pos: u32 = 5;
pub const I2S_INTFLAG_RXOR_Pos: u32 = 4;
pub const I2S_INTFLAG_TXRDY0_Pos: u32 = 8;
pub const I2S_INTFLAG_TXRDY1_Pos: u32 = 9;
pub const I2S_INTFLAG_TXRDY_Pos: u32 = 8;
pub const I2S_INTFLAG_TXUR0_Pos: u32 = 12;
pub const I2S_INTFLAG_TXUR1_Pos: u32 = 13;
pub const I2S_INTFLAG_TXUR_Pos: u32 = 12;
pub const I2S_SYNCBUSY_OFFSET: u32 = 24;
pub const I2S_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const I2S_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const I2S_SYNCBUSY_CKEN0_Pos: u32 = 2;
pub const I2S_SYNCBUSY_CKEN1_Pos: u32 = 3;
pub const I2S_SYNCBUSY_CKEN_Pos: u32 = 2;
pub const I2S_SYNCBUSY_SEREN0_Pos: u32 = 4;
pub const I2S_SYNCBUSY_SEREN1_Pos: u32 = 5;
pub const I2S_SYNCBUSY_SEREN_Pos: u32 = 4;
pub const I2S_SYNCBUSY_DATA0_Pos: u32 = 8;
pub const I2S_SYNCBUSY_DATA1_Pos: u32 = 9;
pub const I2S_SYNCBUSY_DATA_Pos: u32 = 8;
pub const I2S_SERCTRL_OFFSET: u32 = 32;
pub const I2S_SERCTRL_SERMODE_Pos: u32 = 0;
pub const I2S_SERCTRL_TXDEFAULT_Pos: u32 = 2;
pub const I2S_SERCTRL_TXSAME_Pos: u32 = 4;
pub const I2S_SERCTRL_CLKSEL_Pos: u32 = 5;
pub const I2S_SERCTRL_SLOTADJ_Pos: u32 = 7;
pub const I2S_SERCTRL_DATASIZE_Pos: u32 = 8;
pub const I2S_SERCTRL_WORDADJ_Pos: u32 = 12;
pub const I2S_SERCTRL_EXTEND_Pos: u32 = 13;
pub const I2S_SERCTRL_BITREV_Pos: u32 = 15;
pub const I2S_SERCTRL_SLOTDIS0_Pos: u32 = 16;
pub const I2S_SERCTRL_SLOTDIS1_Pos: u32 = 17;
pub const I2S_SERCTRL_SLOTDIS2_Pos: u32 = 18;
pub const I2S_SERCTRL_SLOTDIS3_Pos: u32 = 19;
pub const I2S_SERCTRL_SLOTDIS4_Pos: u32 = 20;
pub const I2S_SERCTRL_SLOTDIS5_Pos: u32 = 21;
pub const I2S_SERCTRL_SLOTDIS6_Pos: u32 = 22;
pub const I2S_SERCTRL_SLOTDIS7_Pos: u32 = 23;
pub const I2S_SERCTRL_SLOTDIS_Pos: u32 = 16;
pub const I2S_SERCTRL_MONO_Pos: u32 = 24;
pub const I2S_SERCTRL_DMA_Pos: u32 = 25;
pub const I2S_SERCTRL_RXLOOP_Pos: u32 = 26;
pub const I2S_DATA_OFFSET: u32 = 48;
pub const I2S_DATA_DATA_Pos: u32 = 0;
pub const REV_MTB: u32 = 256;
pub const MTB_POSITION_OFFSET: u32 = 0;
pub const MTB_POSITION_WRAP_Pos: u32 = 2;
pub const MTB_POSITION_POINTER_Pos: u32 = 3;
pub const MTB_MASTER_OFFSET: u32 = 4;
pub const MTB_MASTER_MASK_Pos: u32 = 0;
pub const MTB_MASTER_TSTARTEN_Pos: u32 = 5;
pub const MTB_MASTER_TSTOPEN_Pos: u32 = 6;
pub const MTB_MASTER_SFRWPRIV_Pos: u32 = 7;
pub const MTB_MASTER_RAMPRIV_Pos: u32 = 8;
pub const MTB_MASTER_HALTREQ_Pos: u32 = 9;
pub const MTB_MASTER_EN_Pos: u32 = 31;
pub const MTB_FLOW_OFFSET: u32 = 8;
pub const MTB_FLOW_AUTOSTOP_Pos: u32 = 0;
pub const MTB_FLOW_AUTOHALT_Pos: u32 = 1;
pub const MTB_FLOW_WATERMARK_Pos: u32 = 3;
pub const MTB_BASE_OFFSET: u32 = 12;
pub const MTB_ITCTRL_OFFSET: u32 = 3840;
pub const MTB_CLAIMSET_OFFSET: u32 = 4000;
pub const MTB_CLAIMCLR_OFFSET: u32 = 4004;
pub const MTB_LOCKACCESS_OFFSET: u32 = 4016;
pub const MTB_LOCKSTATUS_OFFSET: u32 = 4020;
pub const MTB_AUTHSTATUS_OFFSET: u32 = 4024;
pub const MTB_DEVARCH_OFFSET: u32 = 4028;
pub const MTB_DEVID_OFFSET: u32 = 4040;
pub const MTB_DEVTYPE_OFFSET: u32 = 4044;
pub const MTB_PID4_OFFSET: u32 = 4048;
pub const MTB_PID5_OFFSET: u32 = 4052;
pub const MTB_PID6_OFFSET: u32 = 4056;
pub const MTB_PID7_OFFSET: u32 = 4060;
pub const MTB_PID0_OFFSET: u32 = 4064;
pub const MTB_PID1_OFFSET: u32 = 4068;
pub const MTB_PID2_OFFSET: u32 = 4072;
pub const MTB_PID3_OFFSET: u32 = 4076;
pub const MTB_CID0_OFFSET: u32 = 4080;
pub const MTB_CID1_OFFSET: u32 = 4084;
pub const MTB_CID2_OFFSET: u32 = 4088;
pub const MTB_CID3_OFFSET: u32 = 4092;
pub const REV_NVMCTRL: u32 = 262;
pub const NVMCTRL_CTRLA_OFFSET: u32 = 0;
pub const NVMCTRL_CTRLA_CMD_Pos: u32 = 0;
pub const NVMCTRL_CTRLA_CMDEX_Pos: u32 = 8;
pub const NVMCTRL_CTRLB_OFFSET: u32 = 4;
pub const NVMCTRL_CTRLB_RWS_Pos: u32 = 1;
pub const NVMCTRL_CTRLB_MANW_Pos: u32 = 7;
pub const NVMCTRL_CTRLB_SLEEPPRM_Pos: u32 = 8;
pub const NVMCTRL_CTRLB_READMODE_Pos: u32 = 16;
pub const NVMCTRL_CTRLB_CACHEDIS_Pos: u32 = 18;
pub const NVMCTRL_PARAM_OFFSET: u32 = 8;
pub const NVMCTRL_PARAM_NVMP_Pos: u32 = 0;
pub const NVMCTRL_PARAM_PSZ_Pos: u32 = 16;
pub const NVMCTRL_INTENCLR_OFFSET: u32 = 12;
pub const NVMCTRL_INTENCLR_READY_Pos: u32 = 0;
pub const NVMCTRL_INTENCLR_ERROR_Pos: u32 = 1;
pub const NVMCTRL_INTENSET_OFFSET: u32 = 16;
pub const NVMCTRL_INTENSET_READY_Pos: u32 = 0;
pub const NVMCTRL_INTENSET_ERROR_Pos: u32 = 1;
pub const NVMCTRL_INTFLAG_OFFSET: u32 = 20;
pub const NVMCTRL_INTFLAG_READY_Pos: u32 = 0;
pub const NVMCTRL_INTFLAG_ERROR_Pos: u32 = 1;
pub const NVMCTRL_STATUS_OFFSET: u32 = 24;
pub const NVMCTRL_STATUS_PRM_Pos: u32 = 0;
pub const NVMCTRL_STATUS_LOAD_Pos: u32 = 1;
pub const NVMCTRL_STATUS_PROGE_Pos: u32 = 2;
pub const NVMCTRL_STATUS_LOCKE_Pos: u32 = 3;
pub const NVMCTRL_STATUS_NVME_Pos: u32 = 4;
pub const NVMCTRL_STATUS_SB_Pos: u32 = 8;
pub const NVMCTRL_ADDR_OFFSET: u32 = 28;
pub const NVMCTRL_ADDR_ADDR_Pos: u32 = 0;
pub const NVMCTRL_LOCK_OFFSET: u32 = 32;
pub const NVMCTRL_LOCK_LOCK_Pos: u32 = 0;
pub const ADC_FUSES_BIASCAL_Pos: u32 = 3;
pub const ADC_FUSES_LINEARITY_0_Pos: u32 = 27;
pub const ADC_FUSES_LINEARITY_1_Pos: u32 = 0;
pub const FUSES_BOD33USERLEVEL_Pos: u32 = 8;
pub const FUSES_BOD33_ACTION_Pos: u32 = 15;
pub const FUSES_BOD33_EN_Pos: u32 = 14;
pub const FUSES_BOD33_HYST_Pos: u32 = 8;
pub const FUSES_DFLL48M_COARSE_CAL_Pos: u32 = 26;
pub const FUSES_DFLL48M_FINE_CAL_Pos: u32 = 0;
pub const FUSES_HOT_ADC_VAL_Pos: u32 = 20;
pub const FUSES_HOT_INT1V_VAL_Pos: u32 = 0;
pub const FUSES_HOT_TEMP_VAL_DEC_Pos: u32 = 20;
pub const FUSES_HOT_TEMP_VAL_INT_Pos: u32 = 12;
pub const FUSES_OSC32K_CAL_Pos: u32 = 6;
pub const FUSES_ROOM_ADC_VAL_Pos: u32 = 8;
pub const FUSES_ROOM_INT1V_VAL_Pos: u32 = 24;
pub const FUSES_ROOM_TEMP_VAL_DEC_Pos: u32 = 8;
pub const FUSES_ROOM_TEMP_VAL_INT_Pos: u32 = 0;
pub const NVMCTRL_FUSES_BOOTPROT_Pos: u32 = 0;
pub const NVMCTRL_FUSES_EEPROM_SIZE_Pos: u32 = 4;
pub const NVMCTRL_FUSES_REGION_LOCKS_Pos: u32 = 16;
pub const USB_FUSES_TRANSN_Pos: u32 = 13;
pub const USB_FUSES_TRANSP_Pos: u32 = 18;
pub const USB_FUSES_TRIM_Pos: u32 = 23;
pub const WDT_FUSES_ALWAYSON_Pos: u32 = 26;
pub const WDT_FUSES_ENABLE_Pos: u32 = 25;
pub const WDT_FUSES_EWOFFSET_Pos: u32 = 3;
pub const WDT_FUSES_PER_Pos: u32 = 27;
pub const WDT_FUSES_WEN_Pos: u32 = 7;
pub const WDT_FUSES_WINDOW_0_Pos: u32 = 31;
pub const WDT_FUSES_WINDOW_1_Pos: u32 = 0;
pub const REV_PAC: u32 = 257;
pub const PAC_WPCLR_OFFSET: u32 = 0;
pub const PAC_WPCLR_WP_Pos: u32 = 1;
pub const PAC_WPSET_OFFSET: u32 = 4;
pub const PAC_WPSET_WP_Pos: u32 = 1;
pub const REV_PM: u32 = 513;
pub const PM_CTRL_OFFSET: u32 = 0;
pub const PM_SLEEP_OFFSET: u32 = 1;
pub const PM_SLEEP_IDLE_Pos: u32 = 0;
pub const PM_CPUSEL_OFFSET: u32 = 8;
pub const PM_CPUSEL_CPUDIV_Pos: u32 = 0;
pub const PM_APBASEL_OFFSET: u32 = 9;
pub const PM_APBASEL_APBADIV_Pos: u32 = 0;
pub const PM_APBBSEL_OFFSET: u32 = 10;
pub const PM_APBBSEL_APBBDIV_Pos: u32 = 0;
pub const PM_APBCSEL_OFFSET: u32 = 11;
pub const PM_APBCSEL_APBCDIV_Pos: u32 = 0;
pub const PM_AHBMASK_OFFSET: u32 = 20;
pub const PM_AHBMASK_HPB0_Pos: u32 = 0;
pub const PM_AHBMASK_HPB1_Pos: u32 = 1;
pub const PM_AHBMASK_HPB2_Pos: u32 = 2;
pub const PM_AHBMASK_DSU_Pos: u32 = 3;
pub const PM_AHBMASK_NVMCTRL_Pos: u32 = 4;
pub const PM_AHBMASK_DMAC_Pos: u32 = 5;
pub const PM_AHBMASK_USB_Pos: u32 = 6;
pub const PM_APBAMASK_OFFSET: u32 = 24;
pub const PM_APBAMASK_PAC0_Pos: u32 = 0;
pub const PM_APBAMASK_PM_Pos: u32 = 1;
pub const PM_APBAMASK_SYSCTRL_Pos: u32 = 2;
pub const PM_APBAMASK_GCLK_Pos: u32 = 3;
pub const PM_APBAMASK_WDT_Pos: u32 = 4;
pub const PM_APBAMASK_RTC_Pos: u32 = 5;
pub const PM_APBAMASK_EIC_Pos: u32 = 6;
pub const PM_APBBMASK_OFFSET: u32 = 28;
pub const PM_APBBMASK_PAC1_Pos: u32 = 0;
pub const PM_APBBMASK_DSU_Pos: u32 = 1;
pub const PM_APBBMASK_NVMCTRL_Pos: u32 = 2;
pub const PM_APBBMASK_PORT_Pos: u32 = 3;
pub const PM_APBBMASK_DMAC_Pos: u32 = 4;
pub const PM_APBBMASK_USB_Pos: u32 = 5;
pub const PM_APBBMASK_HMATRIX_Pos: u32 = 6;
pub const PM_APBCMASK_OFFSET: u32 = 32;
pub const PM_APBCMASK_PAC2_Pos: u32 = 0;
pub const PM_APBCMASK_EVSYS_Pos: u32 = 1;
pub const PM_APBCMASK_SERCOM0_Pos: u32 = 2;
pub const PM_APBCMASK_SERCOM1_Pos: u32 = 3;
pub const PM_APBCMASK_SERCOM2_Pos: u32 = 4;
pub const PM_APBCMASK_SERCOM3_Pos: u32 = 5;
pub const PM_APBCMASK_SERCOM4_Pos: u32 = 6;
pub const PM_APBCMASK_SERCOM5_Pos: u32 = 7;
pub const PM_APBCMASK_TCC0_Pos: u32 = 8;
pub const PM_APBCMASK_TCC1_Pos: u32 = 9;
pub const PM_APBCMASK_TCC2_Pos: u32 = 10;
pub const PM_APBCMASK_TC3_Pos: u32 = 11;
pub const PM_APBCMASK_TC4_Pos: u32 = 12;
pub const PM_APBCMASK_TC5_Pos: u32 = 13;
pub const PM_APBCMASK_TC6_Pos: u32 = 14;
pub const PM_APBCMASK_TC7_Pos: u32 = 15;
pub const PM_APBCMASK_ADC_Pos: u32 = 16;
pub const PM_APBCMASK_AC_Pos: u32 = 17;
pub const PM_APBCMASK_DAC_Pos: u32 = 18;
pub const PM_APBCMASK_PTC_Pos: u32 = 19;
pub const PM_APBCMASK_I2S_Pos: u32 = 20;
pub const PM_INTENCLR_OFFSET: u32 = 52;
pub const PM_INTENCLR_CKRDY_Pos: u32 = 0;
pub const PM_INTENSET_OFFSET: u32 = 53;
pub const PM_INTENSET_CKRDY_Pos: u32 = 0;
pub const PM_INTFLAG_OFFSET: u32 = 54;
pub const PM_INTFLAG_CKRDY_Pos: u32 = 0;
pub const PM_RCAUSE_OFFSET: u32 = 56;
pub const PM_RCAUSE_POR_Pos: u32 = 0;
pub const PM_RCAUSE_BOD12_Pos: u32 = 1;
pub const PM_RCAUSE_BOD33_Pos: u32 = 2;
pub const PM_RCAUSE_EXT_Pos: u32 = 4;
pub const PM_RCAUSE_WDT_Pos: u32 = 5;
pub const PM_RCAUSE_SYST_Pos: u32 = 6;
pub const REV_PORT: u32 = 256;
pub const PORT_DIR_OFFSET: u32 = 0;
pub const PORT_DIR_DIR_Pos: u32 = 0;
pub const PORT_DIRCLR_OFFSET: u32 = 4;
pub const PORT_DIRCLR_DIRCLR_Pos: u32 = 0;
pub const PORT_DIRSET_OFFSET: u32 = 8;
pub const PORT_DIRSET_DIRSET_Pos: u32 = 0;
pub const PORT_DIRTGL_OFFSET: u32 = 12;
pub const PORT_DIRTGL_DIRTGL_Pos: u32 = 0;
pub const PORT_OUT_OFFSET: u32 = 16;
pub const PORT_OUT_OUT_Pos: u32 = 0;
pub const PORT_OUTCLR_OFFSET: u32 = 20;
pub const PORT_OUTCLR_OUTCLR_Pos: u32 = 0;
pub const PORT_OUTSET_OFFSET: u32 = 24;
pub const PORT_OUTSET_OUTSET_Pos: u32 = 0;
pub const PORT_OUTTGL_OFFSET: u32 = 28;
pub const PORT_OUTTGL_OUTTGL_Pos: u32 = 0;
pub const PORT_IN_OFFSET: u32 = 32;
pub const PORT_IN_IN_Pos: u32 = 0;
pub const PORT_CTRL_OFFSET: u32 = 36;
pub const PORT_CTRL_SAMPLING_Pos: u32 = 0;
pub const PORT_WRCONFIG_OFFSET: u32 = 40;
pub const PORT_WRCONFIG_PINMASK_Pos: u32 = 0;
pub const PORT_WRCONFIG_PMUXEN_Pos: u32 = 16;
pub const PORT_WRCONFIG_INEN_Pos: u32 = 17;
pub const PORT_WRCONFIG_PULLEN_Pos: u32 = 18;
pub const PORT_WRCONFIG_DRVSTR_Pos: u32 = 22;
pub const PORT_WRCONFIG_PMUX_Pos: u32 = 24;
pub const PORT_WRCONFIG_WRPMUX_Pos: u32 = 28;
pub const PORT_WRCONFIG_WRPINCFG_Pos: u32 = 30;
pub const PORT_WRCONFIG_HWSEL_Pos: u32 = 31;
pub const PORT_PMUX_OFFSET: u32 = 48;
pub const PORT_PMUX_PMUXE_Pos: u32 = 0;
pub const PORT_PMUX_PMUXO_Pos: u32 = 4;
pub const PORT_PINCFG_OFFSET: u32 = 64;
pub const PORT_PINCFG_PMUXEN_Pos: u32 = 0;
pub const PORT_PINCFG_INEN_Pos: u32 = 1;
pub const PORT_PINCFG_PULLEN_Pos: u32 = 2;
pub const PORT_PINCFG_DRVSTR_Pos: u32 = 6;
pub const REV_RTC: u32 = 257;
pub const RTC_MODE0_CTRL_OFFSET: u32 = 0;
pub const RTC_MODE0_CTRL_SWRST_Pos: u32 = 0;
pub const RTC_MODE0_CTRL_ENABLE_Pos: u32 = 1;
pub const RTC_MODE0_CTRL_MODE_Pos: u32 = 2;
pub const RTC_MODE0_CTRL_MATCHCLR_Pos: u32 = 7;
pub const RTC_MODE0_CTRL_PRESCALER_Pos: u32 = 8;
pub const RTC_MODE1_CTRL_OFFSET: u32 = 0;
pub const RTC_MODE1_CTRL_SWRST_Pos: u32 = 0;
pub const RTC_MODE1_CTRL_ENABLE_Pos: u32 = 1;
pub const RTC_MODE1_CTRL_MODE_Pos: u32 = 2;
pub const RTC_MODE1_CTRL_PRESCALER_Pos: u32 = 8;
pub const RTC_MODE2_CTRL_OFFSET: u32 = 0;
pub const RTC_MODE2_CTRL_SWRST_Pos: u32 = 0;
pub const RTC_MODE2_CTRL_ENABLE_Pos: u32 = 1;
pub const RTC_MODE2_CTRL_MODE_Pos: u32 = 2;
pub const RTC_MODE2_CTRL_CLKREP_Pos: u32 = 6;
pub const RTC_MODE2_CTRL_MATCHCLR_Pos: u32 = 7;
pub const RTC_MODE2_CTRL_PRESCALER_Pos: u32 = 8;
pub const RTC_READREQ_OFFSET: u32 = 2;
pub const RTC_READREQ_ADDR_Pos: u32 = 0;
pub const RTC_READREQ_RCONT_Pos: u32 = 14;
pub const RTC_READREQ_RREQ_Pos: u32 = 15;
pub const RTC_MODE0_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE0_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE0_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE0_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE0_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE0_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE0_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE0_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE0_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE0_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE0_EVCTRL_CMPEO0_Pos: u32 = 8;
pub const RTC_MODE0_EVCTRL_CMPEO_Pos: u32 = 8;
pub const RTC_MODE0_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE1_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE1_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE1_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE1_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE1_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE1_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE1_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE1_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE1_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE1_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE1_EVCTRL_CMPEO0_Pos: u32 = 8;
pub const RTC_MODE1_EVCTRL_CMPEO1_Pos: u32 = 9;
pub const RTC_MODE1_EVCTRL_CMPEO_Pos: u32 = 8;
pub const RTC_MODE1_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE2_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE2_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE2_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE2_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE2_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE2_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE2_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE2_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE2_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE2_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE2_EVCTRL_ALARMEO0_Pos: u32 = 8;
pub const RTC_MODE2_EVCTRL_ALARMEO_Pos: u32 = 8;
pub const RTC_MODE2_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE0_INTENCLR_OFFSET: u32 = 6;
pub const RTC_MODE0_INTENCLR_CMP0_Pos: u32 = 0;
pub const RTC_MODE0_INTENCLR_CMP_Pos: u32 = 0;
pub const RTC_MODE0_INTENCLR_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE0_INTENCLR_OVF_Pos: u32 = 7;
pub const RTC_MODE1_INTENCLR_OFFSET: u32 = 6;
pub const RTC_MODE1_INTENCLR_CMP0_Pos: u32 = 0;
pub const RTC_MODE1_INTENCLR_CMP1_Pos: u32 = 1;
pub const RTC_MODE1_INTENCLR_CMP_Pos: u32 = 0;
pub const RTC_MODE1_INTENCLR_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE1_INTENCLR_OVF_Pos: u32 = 7;
pub const RTC_MODE2_INTENCLR_OFFSET: u32 = 6;
pub const RTC_MODE2_INTENCLR_ALARM0_Pos: u32 = 0;
pub const RTC_MODE2_INTENCLR_ALARM_Pos: u32 = 0;
pub const RTC_MODE2_INTENCLR_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE2_INTENCLR_OVF_Pos: u32 = 7;
pub const RTC_MODE0_INTENSET_OFFSET: u32 = 7;
pub const RTC_MODE0_INTENSET_CMP0_Pos: u32 = 0;
pub const RTC_MODE0_INTENSET_CMP_Pos: u32 = 0;
pub const RTC_MODE0_INTENSET_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE0_INTENSET_OVF_Pos: u32 = 7;
pub const RTC_MODE1_INTENSET_OFFSET: u32 = 7;
pub const RTC_MODE1_INTENSET_CMP0_Pos: u32 = 0;
pub const RTC_MODE1_INTENSET_CMP1_Pos: u32 = 1;
pub const RTC_MODE1_INTENSET_CMP_Pos: u32 = 0;
pub const RTC_MODE1_INTENSET_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE1_INTENSET_OVF_Pos: u32 = 7;
pub const RTC_MODE2_INTENSET_OFFSET: u32 = 7;
pub const RTC_MODE2_INTENSET_ALARM0_Pos: u32 = 0;
pub const RTC_MODE2_INTENSET_ALARM_Pos: u32 = 0;
pub const RTC_MODE2_INTENSET_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE2_INTENSET_OVF_Pos: u32 = 7;
pub const RTC_MODE0_INTFLAG_OFFSET: u32 = 8;
pub const RTC_MODE0_INTFLAG_CMP0_Pos: u32 = 0;
pub const RTC_MODE0_INTFLAG_CMP_Pos: u32 = 0;
pub const RTC_MODE0_INTFLAG_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE0_INTFLAG_OVF_Pos: u32 = 7;
pub const RTC_MODE1_INTFLAG_OFFSET: u32 = 8;
pub const RTC_MODE1_INTFLAG_CMP0_Pos: u32 = 0;
pub const RTC_MODE1_INTFLAG_CMP1_Pos: u32 = 1;
pub const RTC_MODE1_INTFLAG_CMP_Pos: u32 = 0;
pub const RTC_MODE1_INTFLAG_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE1_INTFLAG_OVF_Pos: u32 = 7;
pub const RTC_MODE2_INTFLAG_OFFSET: u32 = 8;
pub const RTC_MODE2_INTFLAG_ALARM0_Pos: u32 = 0;
pub const RTC_MODE2_INTFLAG_ALARM_Pos: u32 = 0;
pub const RTC_MODE2_INTFLAG_SYNCRDY_Pos: u32 = 6;
pub const RTC_MODE2_INTFLAG_OVF_Pos: u32 = 7;
pub const RTC_STATUS_OFFSET: u32 = 10;
pub const RTC_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const RTC_DBGCTRL_OFFSET: u32 = 11;
pub const RTC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const RTC_FREQCORR_OFFSET: u32 = 12;
pub const RTC_FREQCORR_VALUE_Pos: u32 = 0;
pub const RTC_FREQCORR_SIGN_Pos: u32 = 7;
pub const RTC_MODE0_COUNT_OFFSET: u32 = 16;
pub const RTC_MODE0_COUNT_COUNT_Pos: u32 = 0;
pub const RTC_MODE1_COUNT_OFFSET: u32 = 16;
pub const RTC_MODE1_COUNT_COUNT_Pos: u32 = 0;
pub const RTC_MODE2_CLOCK_OFFSET: u32 = 16;
pub const RTC_MODE2_CLOCK_SECOND_Pos: u32 = 0;
pub const RTC_MODE2_CLOCK_MINUTE_Pos: u32 = 6;
pub const RTC_MODE2_CLOCK_HOUR_Pos: u32 = 12;
pub const RTC_MODE2_CLOCK_DAY_Pos: u32 = 17;
pub const RTC_MODE2_CLOCK_MONTH_Pos: u32 = 22;
pub const RTC_MODE2_CLOCK_YEAR_Pos: u32 = 26;
pub const RTC_MODE1_PER_OFFSET: u32 = 20;
pub const RTC_MODE1_PER_PER_Pos: u32 = 0;
pub const RTC_MODE0_COMP_OFFSET: u32 = 24;
pub const RTC_MODE0_COMP_COMP_Pos: u32 = 0;
pub const RTC_MODE1_COMP_OFFSET: u32 = 24;
pub const RTC_MODE1_COMP_COMP_Pos: u32 = 0;
pub const RTC_MODE2_ALARM_OFFSET: u32 = 24;
pub const RTC_MODE2_ALARM_SECOND_Pos: u32 = 0;
pub const RTC_MODE2_ALARM_MINUTE_Pos: u32 = 6;
pub const RTC_MODE2_ALARM_HOUR_Pos: u32 = 12;
pub const RTC_MODE2_ALARM_DAY_Pos: u32 = 17;
pub const RTC_MODE2_ALARM_MONTH_Pos: u32 = 22;
pub const RTC_MODE2_ALARM_YEAR_Pos: u32 = 26;
pub const RTC_MODE2_MASK_OFFSET: u32 = 28;
pub const RTC_MODE2_MASK_SEL_Pos: u32 = 0;
pub const REV_SERCOM: u32 = 512;
pub const SERCOM_I2CM_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_I2CM_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CM_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CM_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_I2CM_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_I2CM_CTRLA_PINOUT_Pos: u32 = 16;
pub const SERCOM_I2CM_CTRLA_SDAHOLD_Pos: u32 = 20;
pub const SERCOM_I2CM_CTRLA_MEXTTOEN_Pos: u32 = 22;
pub const SERCOM_I2CM_CTRLA_SEXTTOEN_Pos: u32 = 23;
pub const SERCOM_I2CM_CTRLA_SPEED_Pos: u32 = 24;
pub const SERCOM_I2CM_CTRLA_SCLSM_Pos: u32 = 27;
pub const SERCOM_I2CM_CTRLA_INACTOUT_Pos: u32 = 28;
pub const SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos: u32 = 30;
pub const SERCOM_I2CS_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_I2CS_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CS_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CS_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_I2CS_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_I2CS_CTRLA_PINOUT_Pos: u32 = 16;
pub const SERCOM_I2CS_CTRLA_SDAHOLD_Pos: u32 = 20;
pub const SERCOM_I2CS_CTRLA_SEXTTOEN_Pos: u32 = 23;
pub const SERCOM_I2CS_CTRLA_SPEED_Pos: u32 = 24;
pub const SERCOM_I2CS_CTRLA_SCLSM_Pos: u32 = 27;
pub const SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos: u32 = 30;
pub const SERCOM_SPI_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_SPI_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_SPI_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_SPI_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_SPI_CTRLA_IBON_Pos: u32 = 8;
pub const SERCOM_SPI_CTRLA_DOPO_Pos: u32 = 16;
pub const SERCOM_SPI_CTRLA_DIPO_Pos: u32 = 20;
pub const SERCOM_SPI_CTRLA_FORM_Pos: u32 = 24;
pub const SERCOM_SPI_CTRLA_CPHA_Pos: u32 = 28;
pub const SERCOM_SPI_CTRLA_CPOL_Pos: u32 = 29;
pub const SERCOM_SPI_CTRLA_DORD_Pos: u32 = 30;
pub const SERCOM_USART_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_USART_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_USART_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_USART_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_USART_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_USART_CTRLA_IBON_Pos: u32 = 8;
pub const SERCOM_USART_CTRLA_SAMPR_Pos: u32 = 13;
pub const SERCOM_USART_CTRLA_TXPO_Pos: u32 = 16;
pub const SERCOM_USART_CTRLA_RXPO_Pos: u32 = 20;
pub const SERCOM_USART_CTRLA_SAMPA_Pos: u32 = 22;
pub const SERCOM_USART_CTRLA_FORM_Pos: u32 = 24;
pub const SERCOM_USART_CTRLA_CMODE_Pos: u32 = 28;
pub const SERCOM_USART_CTRLA_CPOL_Pos: u32 = 29;
pub const SERCOM_USART_CTRLA_DORD_Pos: u32 = 30;
pub const SERCOM_I2CM_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_I2CM_CTRLB_SMEN_Pos: u32 = 8;
pub const SERCOM_I2CM_CTRLB_QCEN_Pos: u32 = 9;
pub const SERCOM_I2CM_CTRLB_CMD_Pos: u32 = 16;
pub const SERCOM_I2CM_CTRLB_ACKACT_Pos: u32 = 18;
pub const SERCOM_I2CS_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_I2CS_CTRLB_SMEN_Pos: u32 = 8;
pub const SERCOM_I2CS_CTRLB_GCMD_Pos: u32 = 9;
pub const SERCOM_I2CS_CTRLB_AACKEN_Pos: u32 = 10;
pub const SERCOM_I2CS_CTRLB_AMODE_Pos: u32 = 14;
pub const SERCOM_I2CS_CTRLB_CMD_Pos: u32 = 16;
pub const SERCOM_I2CS_CTRLB_ACKACT_Pos: u32 = 18;
pub const SERCOM_SPI_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_SPI_CTRLB_CHSIZE_Pos: u32 = 0;
pub const SERCOM_SPI_CTRLB_PLOADEN_Pos: u32 = 6;
pub const SERCOM_SPI_CTRLB_SSDE_Pos: u32 = 9;
pub const SERCOM_SPI_CTRLB_MSSEN_Pos: u32 = 13;
pub const SERCOM_SPI_CTRLB_AMODE_Pos: u32 = 14;
pub const SERCOM_SPI_CTRLB_RXEN_Pos: u32 = 17;
pub const SERCOM_USART_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_USART_CTRLB_CHSIZE_Pos: u32 = 0;
pub const SERCOM_USART_CTRLB_SBMODE_Pos: u32 = 6;
pub const SERCOM_USART_CTRLB_COLDEN_Pos: u32 = 8;
pub const SERCOM_USART_CTRLB_SFDE_Pos: u32 = 9;
pub const SERCOM_USART_CTRLB_ENC_Pos: u32 = 10;
pub const SERCOM_USART_CTRLB_PMODE_Pos: u32 = 13;
pub const SERCOM_USART_CTRLB_TXEN_Pos: u32 = 16;
pub const SERCOM_USART_CTRLB_RXEN_Pos: u32 = 17;
pub const SERCOM_I2CM_BAUD_OFFSET: u32 = 12;
pub const SERCOM_I2CM_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_I2CM_BAUD_BAUDLOW_Pos: u32 = 8;
pub const SERCOM_I2CM_BAUD_HSBAUD_Pos: u32 = 16;
pub const SERCOM_I2CM_BAUD_HSBAUDLOW_Pos: u32 = 24;
pub const SERCOM_SPI_BAUD_OFFSET: u32 = 12;
pub const SERCOM_SPI_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_OFFSET: u32 = 12;
pub const SERCOM_USART_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRAC_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRAC_FP_Pos: u32 = 13;
pub const SERCOM_USART_BAUD_FRACFP_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRACFP_FP_Pos: u32 = 13;
pub const SERCOM_USART_BAUD_USARTFP_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_RXPL_OFFSET: u32 = 14;
pub const SERCOM_USART_RXPL_RXPL_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_I2CM_INTENCLR_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENCLR_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_I2CS_INTENCLR_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTENCLR_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTENCLR_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_SPI_INTENCLR_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTENCLR_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTENCLR_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTENCLR_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_USART_INTENCLR_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTENCLR_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTENCLR_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTENCLR_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTENCLR_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTENCLR_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_I2CM_INTENSET_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENSET_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_I2CS_INTENSET_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTENSET_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTENSET_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_SPI_INTENSET_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTENSET_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTENSET_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTENSET_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_USART_INTENSET_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTENSET_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTENSET_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTENSET_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTENSET_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTENSET_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_I2CM_INTFLAG_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTFLAG_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_I2CS_INTFLAG_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTFLAG_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTFLAG_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_SPI_INTFLAG_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTFLAG_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTFLAG_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTFLAG_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_USART_INTFLAG_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTFLAG_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTFLAG_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTFLAG_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTFLAG_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTFLAG_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_STATUS_OFFSET: u32 = 26;
pub const SERCOM_I2CM_STATUS_BUSERR_Pos: u32 = 0;
pub const SERCOM_I2CM_STATUS_ARBLOST_Pos: u32 = 1;
pub const SERCOM_I2CM_STATUS_RXNACK_Pos: u32 = 2;
pub const SERCOM_I2CM_STATUS_BUSSTATE_Pos: u32 = 4;
pub const SERCOM_I2CM_STATUS_LOWTOUT_Pos: u32 = 6;
pub const SERCOM_I2CM_STATUS_CLKHOLD_Pos: u32 = 7;
pub const SERCOM_I2CM_STATUS_MEXTTOUT_Pos: u32 = 8;
pub const SERCOM_I2CM_STATUS_SEXTTOUT_Pos: u32 = 9;
pub const SERCOM_I2CM_STATUS_LENERR_Pos: u32 = 10;
pub const SERCOM_I2CS_STATUS_OFFSET: u32 = 26;
pub const SERCOM_I2CS_STATUS_BUSERR_Pos: u32 = 0;
pub const SERCOM_I2CS_STATUS_COLL_Pos: u32 = 1;
pub const SERCOM_I2CS_STATUS_RXNACK_Pos: u32 = 2;
pub const SERCOM_I2CS_STATUS_DIR_Pos: u32 = 3;
pub const SERCOM_I2CS_STATUS_SR_Pos: u32 = 4;
pub const SERCOM_I2CS_STATUS_LOWTOUT_Pos: u32 = 6;
pub const SERCOM_I2CS_STATUS_CLKHOLD_Pos: u32 = 7;
pub const SERCOM_I2CS_STATUS_SEXTTOUT_Pos: u32 = 9;
pub const SERCOM_I2CS_STATUS_HS_Pos: u32 = 10;
pub const SERCOM_SPI_STATUS_OFFSET: u32 = 26;
pub const SERCOM_SPI_STATUS_BUFOVF_Pos: u32 = 2;
pub const SERCOM_USART_STATUS_OFFSET: u32 = 26;
pub const SERCOM_USART_STATUS_PERR_Pos: u32 = 0;
pub const SERCOM_USART_STATUS_FERR_Pos: u32 = 1;
pub const SERCOM_USART_STATUS_BUFOVF_Pos: u32 = 2;
pub const SERCOM_USART_STATUS_CTS_Pos: u32 = 3;
pub const SERCOM_USART_STATUS_ISF_Pos: u32 = 4;
pub const SERCOM_USART_STATUS_COLL_Pos: u32 = 5;
pub const SERCOM_I2CM_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_I2CM_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CM_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CM_SYNCBUSY_SYSOP_Pos: u32 = 2;
pub const SERCOM_I2CS_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_I2CS_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CS_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_SPI_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_SPI_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const SERCOM_USART_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_USART_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_USART_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_USART_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const SERCOM_I2CM_ADDR_OFFSET: u32 = 36;
pub const SERCOM_I2CM_ADDR_ADDR_Pos: u32 = 0;
pub const SERCOM_I2CM_ADDR_LENEN_Pos: u32 = 13;
pub const SERCOM_I2CM_ADDR_HS_Pos: u32 = 14;
pub const SERCOM_I2CM_ADDR_TENBITEN_Pos: u32 = 15;
pub const SERCOM_I2CM_ADDR_LEN_Pos: u32 = 16;
pub const SERCOM_I2CS_ADDR_OFFSET: u32 = 36;
pub const SERCOM_I2CS_ADDR_GENCEN_Pos: u32 = 0;
pub const SERCOM_I2CS_ADDR_ADDR_Pos: u32 = 1;
pub const SERCOM_I2CS_ADDR_TENBITEN_Pos: u32 = 15;
pub const SERCOM_I2CS_ADDR_ADDRMASK_Pos: u32 = 17;
pub const SERCOM_SPI_ADDR_OFFSET: u32 = 36;
pub const SERCOM_SPI_ADDR_ADDR_Pos: u32 = 0;
pub const SERCOM_SPI_ADDR_ADDRMASK_Pos: u32 = 16;
pub const SERCOM_I2CM_DATA_OFFSET: u32 = 40;
pub const SERCOM_I2CM_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_I2CS_DATA_OFFSET: u32 = 40;
pub const SERCOM_I2CS_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_SPI_DATA_OFFSET: u32 = 40;
pub const SERCOM_SPI_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_USART_DATA_OFFSET: u32 = 40;
pub const SERCOM_USART_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_I2CM_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const SERCOM_SPI_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_SPI_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const SERCOM_USART_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_USART_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const REV_SYSCTRL: u32 = 513;
pub const SYSCTRL_INTENCLR_OFFSET: u32 = 0;
pub const SYSCTRL_INTENCLR_XOSCRDY_Pos: u32 = 0;
pub const SYSCTRL_INTENCLR_XOSC32KRDY_Pos: u32 = 1;
pub const SYSCTRL_INTENCLR_OSC32KRDY_Pos: u32 = 2;
pub const SYSCTRL_INTENCLR_OSC8MRDY_Pos: u32 = 3;
pub const SYSCTRL_INTENCLR_DFLLRDY_Pos: u32 = 4;
pub const SYSCTRL_INTENCLR_DFLLOOB_Pos: u32 = 5;
pub const SYSCTRL_INTENCLR_DFLLLCKF_Pos: u32 = 6;
pub const SYSCTRL_INTENCLR_DFLLLCKC_Pos: u32 = 7;
pub const SYSCTRL_INTENCLR_DFLLRCS_Pos: u32 = 8;
pub const SYSCTRL_INTENCLR_BOD33RDY_Pos: u32 = 9;
pub const SYSCTRL_INTENCLR_BOD33DET_Pos: u32 = 10;
pub const SYSCTRL_INTENCLR_B33SRDY_Pos: u32 = 11;
pub const SYSCTRL_INTENCLR_DPLLLCKR_Pos: u32 = 15;
pub const SYSCTRL_INTENCLR_DPLLLCKF_Pos: u32 = 16;
pub const SYSCTRL_INTENCLR_DPLLLTO_Pos: u32 = 17;
pub const SYSCTRL_INTENSET_OFFSET: u32 = 4;
pub const SYSCTRL_INTENSET_XOSCRDY_Pos: u32 = 0;
pub const SYSCTRL_INTENSET_XOSC32KRDY_Pos: u32 = 1;
pub const SYSCTRL_INTENSET_OSC32KRDY_Pos: u32 = 2;
pub const SYSCTRL_INTENSET_OSC8MRDY_Pos: u32 = 3;
pub const SYSCTRL_INTENSET_DFLLRDY_Pos: u32 = 4;
pub const SYSCTRL_INTENSET_DFLLOOB_Pos: u32 = 5;
pub const SYSCTRL_INTENSET_DFLLLCKF_Pos: u32 = 6;
pub const SYSCTRL_INTENSET_DFLLLCKC_Pos: u32 = 7;
pub const SYSCTRL_INTENSET_DFLLRCS_Pos: u32 = 8;
pub const SYSCTRL_INTENSET_BOD33RDY_Pos: u32 = 9;
pub const SYSCTRL_INTENSET_BOD33DET_Pos: u32 = 10;
pub const SYSCTRL_INTENSET_B33SRDY_Pos: u32 = 11;
pub const SYSCTRL_INTENSET_DPLLLCKR_Pos: u32 = 15;
pub const SYSCTRL_INTENSET_DPLLLCKF_Pos: u32 = 16;
pub const SYSCTRL_INTENSET_DPLLLTO_Pos: u32 = 17;
pub const SYSCTRL_INTFLAG_OFFSET: u32 = 8;
pub const SYSCTRL_INTFLAG_XOSCRDY_Pos: u32 = 0;
pub const SYSCTRL_INTFLAG_XOSC32KRDY_Pos: u32 = 1;
pub const SYSCTRL_INTFLAG_OSC32KRDY_Pos: u32 = 2;
pub const SYSCTRL_INTFLAG_OSC8MRDY_Pos: u32 = 3;
pub const SYSCTRL_INTFLAG_DFLLRDY_Pos: u32 = 4;
pub const SYSCTRL_INTFLAG_DFLLOOB_Pos: u32 = 5;
pub const SYSCTRL_INTFLAG_DFLLLCKF_Pos: u32 = 6;
pub const SYSCTRL_INTFLAG_DFLLLCKC_Pos: u32 = 7;
pub const SYSCTRL_INTFLAG_DFLLRCS_Pos: u32 = 8;
pub const SYSCTRL_INTFLAG_BOD33RDY_Pos: u32 = 9;
pub const SYSCTRL_INTFLAG_BOD33DET_Pos: u32 = 10;
pub const SYSCTRL_INTFLAG_B33SRDY_Pos: u32 = 11;
pub const SYSCTRL_INTFLAG_DPLLLCKR_Pos: u32 = 15;
pub const SYSCTRL_INTFLAG_DPLLLCKF_Pos: u32 = 16;
pub const SYSCTRL_INTFLAG_DPLLLTO_Pos: u32 = 17;
pub const SYSCTRL_PCLKSR_OFFSET: u32 = 12;
pub const SYSCTRL_PCLKSR_XOSCRDY_Pos: u32 = 0;
pub const SYSCTRL_PCLKSR_XOSC32KRDY_Pos: u32 = 1;
pub const SYSCTRL_PCLKSR_OSC32KRDY_Pos: u32 = 2;
pub const SYSCTRL_PCLKSR_OSC8MRDY_Pos: u32 = 3;
pub const SYSCTRL_PCLKSR_DFLLRDY_Pos: u32 = 4;
pub const SYSCTRL_PCLKSR_DFLLOOB_Pos: u32 = 5;
pub const SYSCTRL_PCLKSR_DFLLLCKF_Pos: u32 = 6;
pub const SYSCTRL_PCLKSR_DFLLLCKC_Pos: u32 = 7;
pub const SYSCTRL_PCLKSR_DFLLRCS_Pos: u32 = 8;
pub const SYSCTRL_PCLKSR_BOD33RDY_Pos: u32 = 9;
pub const SYSCTRL_PCLKSR_BOD33DET_Pos: u32 = 10;
pub const SYSCTRL_PCLKSR_B33SRDY_Pos: u32 = 11;
pub const SYSCTRL_PCLKSR_DPLLLCKR_Pos: u32 = 15;
pub const SYSCTRL_PCLKSR_DPLLLCKF_Pos: u32 = 16;
pub const SYSCTRL_PCLKSR_DPLLLTO_Pos: u32 = 17;
pub const SYSCTRL_XOSC_OFFSET: u32 = 16;
pub const SYSCTRL_XOSC_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_XOSC_XTALEN_Pos: u32 = 2;
pub const SYSCTRL_XOSC_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_XOSC_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_XOSC_GAIN_Pos: u32 = 8;
pub const SYSCTRL_XOSC_AMPGC_Pos: u32 = 11;
pub const SYSCTRL_XOSC_STARTUP_Pos: u32 = 12;
pub const SYSCTRL_XOSC32K_OFFSET: u32 = 20;
pub const SYSCTRL_XOSC32K_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_XOSC32K_XTALEN_Pos: u32 = 2;
pub const SYSCTRL_XOSC32K_EN32K_Pos: u32 = 3;
pub const SYSCTRL_XOSC32K_EN1K_Pos: u32 = 4;
pub const SYSCTRL_XOSC32K_AAMPEN_Pos: u32 = 5;
pub const SYSCTRL_XOSC32K_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_XOSC32K_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_XOSC32K_STARTUP_Pos: u32 = 8;
pub const SYSCTRL_XOSC32K_WRTLOCK_Pos: u32 = 12;
pub const SYSCTRL_OSC32K_OFFSET: u32 = 24;
pub const SYSCTRL_OSC32K_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_OSC32K_EN32K_Pos: u32 = 2;
pub const SYSCTRL_OSC32K_EN1K_Pos: u32 = 3;
pub const SYSCTRL_OSC32K_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_OSC32K_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_OSC32K_STARTUP_Pos: u32 = 8;
pub const SYSCTRL_OSC32K_WRTLOCK_Pos: u32 = 12;
pub const SYSCTRL_OSC32K_CALIB_Pos: u32 = 16;
pub const SYSCTRL_OSCULP32K_OFFSET: u32 = 28;
pub const SYSCTRL_OSCULP32K_CALIB_Pos: u32 = 0;
pub const SYSCTRL_OSCULP32K_WRTLOCK_Pos: u32 = 7;
pub const SYSCTRL_OSC8M_OFFSET: u32 = 32;
pub const SYSCTRL_OSC8M_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_OSC8M_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_OSC8M_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_OSC8M_PRESC_Pos: u32 = 8;
pub const SYSCTRL_OSC8M_CALIB_Pos: u32 = 16;
pub const SYSCTRL_OSC8M_FRANGE_Pos: u32 = 30;
pub const SYSCTRL_DFLLCTRL_OFFSET: u32 = 36;
pub const SYSCTRL_DFLLCTRL_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_DFLLCTRL_MODE_Pos: u32 = 2;
pub const SYSCTRL_DFLLCTRL_STABLE_Pos: u32 = 3;
pub const SYSCTRL_DFLLCTRL_LLAW_Pos: u32 = 4;
pub const SYSCTRL_DFLLCTRL_USBCRM_Pos: u32 = 5;
pub const SYSCTRL_DFLLCTRL_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_DFLLCTRL_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_DFLLCTRL_CCDIS_Pos: u32 = 8;
pub const SYSCTRL_DFLLCTRL_QLDIS_Pos: u32 = 9;
pub const SYSCTRL_DFLLCTRL_BPLCKC_Pos: u32 = 10;
pub const SYSCTRL_DFLLCTRL_WAITLOCK_Pos: u32 = 11;
pub const SYSCTRL_DFLLVAL_OFFSET: u32 = 40;
pub const SYSCTRL_DFLLVAL_FINE_Pos: u32 = 0;
pub const SYSCTRL_DFLLVAL_COARSE_Pos: u32 = 10;
pub const SYSCTRL_DFLLVAL_DIFF_Pos: u32 = 16;
pub const SYSCTRL_DFLLMUL_OFFSET: u32 = 44;
pub const SYSCTRL_DFLLMUL_MUL_Pos: u32 = 0;
pub const SYSCTRL_DFLLMUL_FSTEP_Pos: u32 = 16;
pub const SYSCTRL_DFLLMUL_CSTEP_Pos: u32 = 26;
pub const SYSCTRL_DFLLSYNC_OFFSET: u32 = 48;
pub const SYSCTRL_DFLLSYNC_READREQ_Pos: u32 = 7;
pub const SYSCTRL_BOD33_OFFSET: u32 = 52;
pub const SYSCTRL_BOD33_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_BOD33_HYST_Pos: u32 = 2;
pub const SYSCTRL_BOD33_ACTION_Pos: u32 = 3;
pub const SYSCTRL_BOD33_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_BOD33_MODE_Pos: u32 = 8;
pub const SYSCTRL_BOD33_CEN_Pos: u32 = 9;
pub const SYSCTRL_BOD33_PSEL_Pos: u32 = 12;
pub const SYSCTRL_BOD33_LEVEL_Pos: u32 = 16;
pub const SYSCTRL_VREG_OFFSET: u32 = 60;
pub const SYSCTRL_VREG_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_VREG_FORCELDO_Pos: u32 = 13;
pub const SYSCTRL_VREF_OFFSET: u32 = 64;
pub const SYSCTRL_VREF_TSEN_Pos: u32 = 1;
pub const SYSCTRL_VREF_BGOUTEN_Pos: u32 = 2;
pub const SYSCTRL_VREF_CALIB_Pos: u32 = 16;
pub const SYSCTRL_DPLLCTRLA_OFFSET: u32 = 68;
pub const SYSCTRL_DPLLCTRLA_ENABLE_Pos: u32 = 1;
pub const SYSCTRL_DPLLCTRLA_RUNSTDBY_Pos: u32 = 6;
pub const SYSCTRL_DPLLCTRLA_ONDEMAND_Pos: u32 = 7;
pub const SYSCTRL_DPLLRATIO_OFFSET: u32 = 72;
pub const SYSCTRL_DPLLRATIO_LDR_Pos: u32 = 0;
pub const SYSCTRL_DPLLRATIO_LDRFRAC_Pos: u32 = 16;
pub const SYSCTRL_DPLLCTRLB_OFFSET: u32 = 76;
pub const SYSCTRL_DPLLCTRLB_FILTER_Pos: u32 = 0;
pub const SYSCTRL_DPLLCTRLB_LPEN_Pos: u32 = 2;
pub const SYSCTRL_DPLLCTRLB_WUF_Pos: u32 = 3;
pub const SYSCTRL_DPLLCTRLB_REFCLK_Pos: u32 = 4;
pub const SYSCTRL_DPLLCTRLB_LTIME_Pos: u32 = 8;
pub const SYSCTRL_DPLLCTRLB_LBYPASS_Pos: u32 = 12;
pub const SYSCTRL_DPLLCTRLB_DIV_Pos: u32 = 16;
pub const SYSCTRL_DPLLSTATUS_OFFSET: u32 = 80;
pub const SYSCTRL_DPLLSTATUS_LOCK_Pos: u32 = 0;
pub const SYSCTRL_DPLLSTATUS_CLKRDY_Pos: u32 = 1;
pub const SYSCTRL_DPLLSTATUS_ENABLE_Pos: u32 = 2;
pub const SYSCTRL_DPLLSTATUS_DIV_Pos: u32 = 3;
pub const REV_TC: u32 = 289;
pub const TC_CTRLA_OFFSET: u32 = 0;
pub const TC_CTRLA_SWRST_Pos: u32 = 0;
pub const TC_CTRLA_ENABLE_Pos: u32 = 1;
pub const TC_CTRLA_MODE_Pos: u32 = 2;
pub const TC_CTRLA_WAVEGEN_Pos: u32 = 5;
pub const TC_CTRLA_PRESCALER_Pos: u32 = 8;
pub const TC_CTRLA_RUNSTDBY_Pos: u32 = 11;
pub const TC_CTRLA_PRESCSYNC_Pos: u32 = 12;
pub const TC_READREQ_OFFSET: u32 = 2;
pub const TC_READREQ_ADDR_Pos: u32 = 0;
pub const TC_READREQ_RCONT_Pos: u32 = 14;
pub const TC_READREQ_RREQ_Pos: u32 = 15;
pub const TC_CTRLBCLR_OFFSET: u32 = 4;
pub const TC_CTRLBCLR_DIR_Pos: u32 = 0;
pub const TC_CTRLBCLR_ONESHOT_Pos: u32 = 2;
pub const TC_CTRLBCLR_CMD_Pos: u32 = 6;
pub const TC_CTRLBSET_OFFSET: u32 = 5;
pub const TC_CTRLBSET_DIR_Pos: u32 = 0;
pub const TC_CTRLBSET_ONESHOT_Pos: u32 = 2;
pub const TC_CTRLBSET_CMD_Pos: u32 = 6;
pub const TC_CTRLC_OFFSET: u32 = 6;
pub const TC_CTRLC_INVEN0_Pos: u32 = 0;
pub const TC_CTRLC_INVEN1_Pos: u32 = 1;
pub const TC_CTRLC_INVEN_Pos: u32 = 0;
pub const TC_CTRLC_CPTEN0_Pos: u32 = 4;
pub const TC_CTRLC_CPTEN1_Pos: u32 = 5;
pub const TC_CTRLC_CPTEN_Pos: u32 = 4;
pub const TC_DBGCTRL_OFFSET: u32 = 8;
pub const TC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const TC_EVCTRL_OFFSET: u32 = 10;
pub const TC_EVCTRL_EVACT_Pos: u32 = 0;
pub const TC_EVCTRL_TCINV_Pos: u32 = 4;
pub const TC_EVCTRL_TCEI_Pos: u32 = 5;
pub const TC_EVCTRL_OVFEO_Pos: u32 = 8;
pub const TC_EVCTRL_MCEO0_Pos: u32 = 12;
pub const TC_EVCTRL_MCEO1_Pos: u32 = 13;
pub const TC_EVCTRL_MCEO_Pos: u32 = 12;
pub const TC_INTENCLR_OFFSET: u32 = 12;
pub const TC_INTENCLR_OVF_Pos: u32 = 0;
pub const TC_INTENCLR_ERR_Pos: u32 = 1;
pub const TC_INTENCLR_SYNCRDY_Pos: u32 = 3;
pub const TC_INTENCLR_MC0_Pos: u32 = 4;
pub const TC_INTENCLR_MC1_Pos: u32 = 5;
pub const TC_INTENCLR_MC_Pos: u32 = 4;
pub const TC_INTENSET_OFFSET: u32 = 13;
pub const TC_INTENSET_OVF_Pos: u32 = 0;
pub const TC_INTENSET_ERR_Pos: u32 = 1;
pub const TC_INTENSET_SYNCRDY_Pos: u32 = 3;
pub const TC_INTENSET_MC0_Pos: u32 = 4;
pub const TC_INTENSET_MC1_Pos: u32 = 5;
pub const TC_INTENSET_MC_Pos: u32 = 4;
pub const TC_INTFLAG_OFFSET: u32 = 14;
pub const TC_INTFLAG_OVF_Pos: u32 = 0;
pub const TC_INTFLAG_ERR_Pos: u32 = 1;
pub const TC_INTFLAG_SYNCRDY_Pos: u32 = 3;
pub const TC_INTFLAG_MC0_Pos: u32 = 4;
pub const TC_INTFLAG_MC1_Pos: u32 = 5;
pub const TC_INTFLAG_MC_Pos: u32 = 4;
pub const TC_STATUS_OFFSET: u32 = 15;
pub const TC_STATUS_STOP_Pos: u32 = 3;
pub const TC_STATUS_SLAVE_Pos: u32 = 4;
pub const TC_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const TC_COUNT16_COUNT_OFFSET: u32 = 16;
pub const TC_COUNT16_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT32_COUNT_OFFSET: u32 = 16;
pub const TC_COUNT32_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT8_COUNT_OFFSET: u32 = 16;
pub const TC_COUNT8_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT8_PER_OFFSET: u32 = 20;
pub const TC_COUNT8_PER_PER_Pos: u32 = 0;
pub const TC_COUNT16_CC_OFFSET: u32 = 24;
pub const TC_COUNT16_CC_CC_Pos: u32 = 0;
pub const TC_COUNT32_CC_OFFSET: u32 = 24;
pub const TC_COUNT32_CC_CC_Pos: u32 = 0;
pub const TC_COUNT8_CC_OFFSET: u32 = 24;
pub const TC_COUNT8_CC_CC_Pos: u32 = 0;
pub const REV_TCC: u32 = 257;
pub const TCC_CTRLA_OFFSET: u32 = 0;
pub const TCC_CTRLA_SWRST_Pos: u32 = 0;
pub const TCC_CTRLA_ENABLE_Pos: u32 = 1;
pub const TCC_CTRLA_RESOLUTION_Pos: u32 = 5;
pub const TCC_CTRLA_PRESCALER_Pos: u32 = 8;
pub const TCC_CTRLA_RUNSTDBY_Pos: u32 = 11;
pub const TCC_CTRLA_PRESCSYNC_Pos: u32 = 12;
pub const TCC_CTRLA_ALOCK_Pos: u32 = 14;
pub const TCC_CTRLA_CPTEN0_Pos: u32 = 24;
pub const TCC_CTRLA_CPTEN1_Pos: u32 = 25;
pub const TCC_CTRLA_CPTEN2_Pos: u32 = 26;
pub const TCC_CTRLA_CPTEN3_Pos: u32 = 27;
pub const TCC_CTRLA_CPTEN_Pos: u32 = 24;
pub const TCC_CTRLBCLR_OFFSET: u32 = 4;
pub const TCC_CTRLBCLR_DIR_Pos: u32 = 0;
pub const TCC_CTRLBCLR_LUPD_Pos: u32 = 1;
pub const TCC_CTRLBCLR_ONESHOT_Pos: u32 = 2;
pub const TCC_CTRLBCLR_IDXCMD_Pos: u32 = 3;
pub const TCC_CTRLBCLR_CMD_Pos: u32 = 5;
pub const TCC_CTRLBSET_OFFSET: u32 = 5;
pub const TCC_CTRLBSET_DIR_Pos: u32 = 0;
pub const TCC_CTRLBSET_LUPD_Pos: u32 = 1;
pub const TCC_CTRLBSET_ONESHOT_Pos: u32 = 2;
pub const TCC_CTRLBSET_IDXCMD_Pos: u32 = 3;
pub const TCC_CTRLBSET_CMD_Pos: u32 = 5;
pub const TCC_SYNCBUSY_OFFSET: u32 = 8;
pub const TCC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const TCC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const TCC_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const TCC_SYNCBUSY_STATUS_Pos: u32 = 3;
pub const TCC_SYNCBUSY_COUNT_Pos: u32 = 4;
pub const TCC_SYNCBUSY_PATT_Pos: u32 = 5;
pub const TCC_SYNCBUSY_WAVE_Pos: u32 = 6;
pub const TCC_SYNCBUSY_PER_Pos: u32 = 7;
pub const TCC_SYNCBUSY_CC0_Pos: u32 = 8;
pub const TCC_SYNCBUSY_CC1_Pos: u32 = 9;
pub const TCC_SYNCBUSY_CC2_Pos: u32 = 10;
pub const TCC_SYNCBUSY_CC3_Pos: u32 = 11;
pub const TCC_SYNCBUSY_CC_Pos: u32 = 8;
pub const TCC_SYNCBUSY_PATTB_Pos: u32 = 16;
pub const TCC_SYNCBUSY_WAVEB_Pos: u32 = 17;
pub const TCC_SYNCBUSY_PERB_Pos: u32 = 18;
pub const TCC_SYNCBUSY_CCB0_Pos: u32 = 19;
pub const TCC_SYNCBUSY_CCB1_Pos: u32 = 20;
pub const TCC_SYNCBUSY_CCB2_Pos: u32 = 21;
pub const TCC_SYNCBUSY_CCB3_Pos: u32 = 22;
pub const TCC_SYNCBUSY_CCB_Pos: u32 = 19;
pub const TCC_FCTRLA_OFFSET: u32 = 12;
pub const TCC_FCTRLA_SRC_Pos: u32 = 0;
pub const TCC_FCTRLA_KEEP_Pos: u32 = 3;
pub const TCC_FCTRLA_QUAL_Pos: u32 = 4;
pub const TCC_FCTRLA_BLANK_Pos: u32 = 5;
pub const TCC_FCTRLA_RESTART_Pos: u32 = 7;
pub const TCC_FCTRLA_HALT_Pos: u32 = 8;
pub const TCC_FCTRLA_CHSEL_Pos: u32 = 10;
pub const TCC_FCTRLA_CAPTURE_Pos: u32 = 12;
pub const TCC_FCTRLA_BLANKVAL_Pos: u32 = 16;
pub const TCC_FCTRLA_FILTERVAL_Pos: u32 = 24;
pub const TCC_FCTRLB_OFFSET: u32 = 16;
pub const TCC_FCTRLB_SRC_Pos: u32 = 0;
pub const TCC_FCTRLB_KEEP_Pos: u32 = 3;
pub const TCC_FCTRLB_QUAL_Pos: u32 = 4;
pub const TCC_FCTRLB_BLANK_Pos: u32 = 5;
pub const TCC_FCTRLB_RESTART_Pos: u32 = 7;
pub const TCC_FCTRLB_HALT_Pos: u32 = 8;
pub const TCC_FCTRLB_CHSEL_Pos: u32 = 10;
pub const TCC_FCTRLB_CAPTURE_Pos: u32 = 12;
pub const TCC_FCTRLB_BLANKVAL_Pos: u32 = 16;
pub const TCC_FCTRLB_FILTERVAL_Pos: u32 = 24;
pub const TCC_WEXCTRL_OFFSET: u32 = 20;
pub const TCC_WEXCTRL_OTMX_Pos: u32 = 0;
pub const TCC_WEXCTRL_DTIEN0_Pos: u32 = 8;
pub const TCC_WEXCTRL_DTIEN1_Pos: u32 = 9;
pub const TCC_WEXCTRL_DTIEN2_Pos: u32 = 10;
pub const TCC_WEXCTRL_DTIEN3_Pos: u32 = 11;
pub const TCC_WEXCTRL_DTIEN_Pos: u32 = 8;
pub const TCC_WEXCTRL_DTLS_Pos: u32 = 16;
pub const TCC_WEXCTRL_DTHS_Pos: u32 = 24;
pub const TCC_DRVCTRL_OFFSET: u32 = 24;
pub const TCC_DRVCTRL_NRE0_Pos: u32 = 0;
pub const TCC_DRVCTRL_NRE1_Pos: u32 = 1;
pub const TCC_DRVCTRL_NRE2_Pos: u32 = 2;
pub const TCC_DRVCTRL_NRE3_Pos: u32 = 3;
pub const TCC_DRVCTRL_NRE4_Pos: u32 = 4;
pub const TCC_DRVCTRL_NRE5_Pos: u32 = 5;
pub const TCC_DRVCTRL_NRE6_Pos: u32 = 6;
pub const TCC_DRVCTRL_NRE7_Pos: u32 = 7;
pub const TCC_DRVCTRL_NRE_Pos: u32 = 0;
pub const TCC_DRVCTRL_NRV0_Pos: u32 = 8;
pub const TCC_DRVCTRL_NRV1_Pos: u32 = 9;
pub const TCC_DRVCTRL_NRV2_Pos: u32 = 10;
pub const TCC_DRVCTRL_NRV3_Pos: u32 = 11;
pub const TCC_DRVCTRL_NRV4_Pos: u32 = 12;
pub const TCC_DRVCTRL_NRV5_Pos: u32 = 13;
pub const TCC_DRVCTRL_NRV6_Pos: u32 = 14;
pub const TCC_DRVCTRL_NRV7_Pos: u32 = 15;
pub const TCC_DRVCTRL_NRV_Pos: u32 = 8;
pub const TCC_DRVCTRL_INVEN0_Pos: u32 = 16;
pub const TCC_DRVCTRL_INVEN1_Pos: u32 = 17;
pub const TCC_DRVCTRL_INVEN2_Pos: u32 = 18;
pub const TCC_DRVCTRL_INVEN3_Pos: u32 = 19;
pub const TCC_DRVCTRL_INVEN4_Pos: u32 = 20;
pub const TCC_DRVCTRL_INVEN5_Pos: u32 = 21;
pub const TCC_DRVCTRL_INVEN6_Pos: u32 = 22;
pub const TCC_DRVCTRL_INVEN7_Pos: u32 = 23;
pub const TCC_DRVCTRL_INVEN_Pos: u32 = 16;
pub const TCC_DRVCTRL_FILTERVAL0_Pos: u32 = 24;
pub const TCC_DRVCTRL_FILTERVAL1_Pos: u32 = 28;
pub const TCC_DBGCTRL_OFFSET: u32 = 30;
pub const TCC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const TCC_DBGCTRL_FDDBD_Pos: u32 = 2;
pub const TCC_EVCTRL_OFFSET: u32 = 32;
pub const TCC_EVCTRL_EVACT0_Pos: u32 = 0;
pub const TCC_EVCTRL_EVACT1_Pos: u32 = 3;
pub const TCC_EVCTRL_CNTSEL_Pos: u32 = 6;
pub const TCC_EVCTRL_OVFEO_Pos: u32 = 8;
pub const TCC_EVCTRL_TRGEO_Pos: u32 = 9;
pub const TCC_EVCTRL_CNTEO_Pos: u32 = 10;
pub const TCC_EVCTRL_TCINV0_Pos: u32 = 12;
pub const TCC_EVCTRL_TCINV1_Pos: u32 = 13;
pub const TCC_EVCTRL_TCINV_Pos: u32 = 12;
pub const TCC_EVCTRL_TCEI0_Pos: u32 = 14;
pub const TCC_EVCTRL_TCEI1_Pos: u32 = 15;
pub const TCC_EVCTRL_TCEI_Pos: u32 = 14;
pub const TCC_EVCTRL_MCEI0_Pos: u32 = 16;
pub const TCC_EVCTRL_MCEI1_Pos: u32 = 17;
pub const TCC_EVCTRL_MCEI2_Pos: u32 = 18;
pub const TCC_EVCTRL_MCEI3_Pos: u32 = 19;
pub const TCC_EVCTRL_MCEI_Pos: u32 = 16;
pub const TCC_EVCTRL_MCEO0_Pos: u32 = 24;
pub const TCC_EVCTRL_MCEO1_Pos: u32 = 25;
pub const TCC_EVCTRL_MCEO2_Pos: u32 = 26;
pub const TCC_EVCTRL_MCEO3_Pos: u32 = 27;
pub const TCC_EVCTRL_MCEO_Pos: u32 = 24;
pub const TCC_INTENCLR_OFFSET: u32 = 36;
pub const TCC_INTENCLR_OVF_Pos: u32 = 0;
pub const TCC_INTENCLR_TRG_Pos: u32 = 1;
pub const TCC_INTENCLR_CNT_Pos: u32 = 2;
pub const TCC_INTENCLR_ERR_Pos: u32 = 3;
pub const TCC_INTENCLR_DFS_Pos: u32 = 11;
pub const TCC_INTENCLR_FAULTA_Pos: u32 = 12;
pub const TCC_INTENCLR_FAULTB_Pos: u32 = 13;
pub const TCC_INTENCLR_FAULT0_Pos: u32 = 14;
pub const TCC_INTENCLR_FAULT1_Pos: u32 = 15;
pub const TCC_INTENCLR_MC0_Pos: u32 = 16;
pub const TCC_INTENCLR_MC1_Pos: u32 = 17;
pub const TCC_INTENCLR_MC2_Pos: u32 = 18;
pub const TCC_INTENCLR_MC3_Pos: u32 = 19;
pub const TCC_INTENCLR_MC_Pos: u32 = 16;
pub const TCC_INTENSET_OFFSET: u32 = 40;
pub const TCC_INTENSET_OVF_Pos: u32 = 0;
pub const TCC_INTENSET_TRG_Pos: u32 = 1;
pub const TCC_INTENSET_CNT_Pos: u32 = 2;
pub const TCC_INTENSET_ERR_Pos: u32 = 3;
pub const TCC_INTENSET_DFS_Pos: u32 = 11;
pub const TCC_INTENSET_FAULTA_Pos: u32 = 12;
pub const TCC_INTENSET_FAULTB_Pos: u32 = 13;
pub const TCC_INTENSET_FAULT0_Pos: u32 = 14;
pub const TCC_INTENSET_FAULT1_Pos: u32 = 15;
pub const TCC_INTENSET_MC0_Pos: u32 = 16;
pub const TCC_INTENSET_MC1_Pos: u32 = 17;
pub const TCC_INTENSET_MC2_Pos: u32 = 18;
pub const TCC_INTENSET_MC3_Pos: u32 = 19;
pub const TCC_INTENSET_MC_Pos: u32 = 16;
pub const TCC_INTFLAG_OFFSET: u32 = 44;
pub const TCC_INTFLAG_OVF_Pos: u32 = 0;
pub const TCC_INTFLAG_TRG_Pos: u32 = 1;
pub const TCC_INTFLAG_CNT_Pos: u32 = 2;
pub const TCC_INTFLAG_ERR_Pos: u32 = 3;
pub const TCC_INTFLAG_DFS_Pos: u32 = 11;
pub const TCC_INTFLAG_FAULTA_Pos: u32 = 12;
pub const TCC_INTFLAG_FAULTB_Pos: u32 = 13;
pub const TCC_INTFLAG_FAULT0_Pos: u32 = 14;
pub const TCC_INTFLAG_FAULT1_Pos: u32 = 15;
pub const TCC_INTFLAG_MC0_Pos: u32 = 16;
pub const TCC_INTFLAG_MC1_Pos: u32 = 17;
pub const TCC_INTFLAG_MC2_Pos: u32 = 18;
pub const TCC_INTFLAG_MC3_Pos: u32 = 19;
pub const TCC_INTFLAG_MC_Pos: u32 = 16;
pub const TCC_STATUS_OFFSET: u32 = 48;
pub const TCC_STATUS_STOP_Pos: u32 = 0;
pub const TCC_STATUS_IDX_Pos: u32 = 1;
pub const TCC_STATUS_DFS_Pos: u32 = 3;
pub const TCC_STATUS_SLAVE_Pos: u32 = 4;
pub const TCC_STATUS_PATTBV_Pos: u32 = 5;
pub const TCC_STATUS_WAVEBV_Pos: u32 = 6;
pub const TCC_STATUS_PERBV_Pos: u32 = 7;
pub const TCC_STATUS_FAULTAIN_Pos: u32 = 8;
pub const TCC_STATUS_FAULTBIN_Pos: u32 = 9;
pub const TCC_STATUS_FAULT0IN_Pos: u32 = 10;
pub const TCC_STATUS_FAULT1IN_Pos: u32 = 11;
pub const TCC_STATUS_FAULTA_Pos: u32 = 12;
pub const TCC_STATUS_FAULTB_Pos: u32 = 13;
pub const TCC_STATUS_FAULT0_Pos: u32 = 14;
pub const TCC_STATUS_FAULT1_Pos: u32 = 15;
pub const TCC_STATUS_CCBV0_Pos: u32 = 16;
pub const TCC_STATUS_CCBV1_Pos: u32 = 17;
pub const TCC_STATUS_CCBV2_Pos: u32 = 18;
pub const TCC_STATUS_CCBV3_Pos: u32 = 19;
pub const TCC_STATUS_CCBV_Pos: u32 = 16;
pub const TCC_STATUS_CMP0_Pos: u32 = 24;
pub const TCC_STATUS_CMP1_Pos: u32 = 25;
pub const TCC_STATUS_CMP2_Pos: u32 = 26;
pub const TCC_STATUS_CMP3_Pos: u32 = 27;
pub const TCC_STATUS_CMP_Pos: u32 = 24;
pub const TCC_COUNT_OFFSET: u32 = 52;
pub const TCC_COUNT_DITH4_COUNT_Pos: u32 = 4;
pub const TCC_COUNT_DITH5_COUNT_Pos: u32 = 5;
pub const TCC_COUNT_DITH6_COUNT_Pos: u32 = 6;
pub const TCC_COUNT_COUNT_Pos: u32 = 0;
pub const TCC_PATT_OFFSET: u32 = 56;
pub const TCC_PATT_PGE0_Pos: u32 = 0;
pub const TCC_PATT_PGE1_Pos: u32 = 1;
pub const TCC_PATT_PGE2_Pos: u32 = 2;
pub const TCC_PATT_PGE3_Pos: u32 = 3;
pub const TCC_PATT_PGE4_Pos: u32 = 4;
pub const TCC_PATT_PGE5_Pos: u32 = 5;
pub const TCC_PATT_PGE6_Pos: u32 = 6;
pub const TCC_PATT_PGE7_Pos: u32 = 7;
pub const TCC_PATT_PGE_Pos: u32 = 0;
pub const TCC_PATT_PGV0_Pos: u32 = 8;
pub const TCC_PATT_PGV1_Pos: u32 = 9;
pub const TCC_PATT_PGV2_Pos: u32 = 10;
pub const TCC_PATT_PGV3_Pos: u32 = 11;
pub const TCC_PATT_PGV4_Pos: u32 = 12;
pub const TCC_PATT_PGV5_Pos: u32 = 13;
pub const TCC_PATT_PGV6_Pos: u32 = 14;
pub const TCC_PATT_PGV7_Pos: u32 = 15;
pub const TCC_PATT_PGV_Pos: u32 = 8;
pub const TCC_WAVE_OFFSET: u32 = 60;
pub const TCC_WAVE_WAVEGEN_Pos: u32 = 0;
pub const TCC_WAVE_RAMP_Pos: u32 = 4;
pub const TCC_WAVE_CIPEREN_Pos: u32 = 7;
pub const TCC_WAVE_CICCEN0_Pos: u32 = 8;
pub const TCC_WAVE_CICCEN1_Pos: u32 = 9;
pub const TCC_WAVE_CICCEN2_Pos: u32 = 10;
pub const TCC_WAVE_CICCEN3_Pos: u32 = 11;
pub const TCC_WAVE_CICCEN_Pos: u32 = 8;
pub const TCC_WAVE_POL0_Pos: u32 = 16;
pub const TCC_WAVE_POL1_Pos: u32 = 17;
pub const TCC_WAVE_POL2_Pos: u32 = 18;
pub const TCC_WAVE_POL3_Pos: u32 = 19;
pub const TCC_WAVE_POL_Pos: u32 = 16;
pub const TCC_WAVE_SWAP0_Pos: u32 = 24;
pub const TCC_WAVE_SWAP1_Pos: u32 = 25;
pub const TCC_WAVE_SWAP2_Pos: u32 = 26;
pub const TCC_WAVE_SWAP3_Pos: u32 = 27;
pub const TCC_WAVE_SWAP_Pos: u32 = 24;
pub const TCC_PER_OFFSET: u32 = 64;
pub const TCC_PER_DITH4_DITHERCY_Pos: u32 = 0;
pub const TCC_PER_DITH4_PER_Pos: u32 = 4;
pub const TCC_PER_DITH5_DITHERCY_Pos: u32 = 0;
pub const TCC_PER_DITH5_PER_Pos: u32 = 5;
pub const TCC_PER_DITH6_DITHERCY_Pos: u32 = 0;
pub const TCC_PER_DITH6_PER_Pos: u32 = 6;
pub const TCC_PER_PER_Pos: u32 = 0;
pub const TCC_CC_OFFSET: u32 = 68;
pub const TCC_CC_DITH4_DITHERCY_Pos: u32 = 0;
pub const TCC_CC_DITH4_CC_Pos: u32 = 4;
pub const TCC_CC_DITH5_DITHERCY_Pos: u32 = 0;
pub const TCC_CC_DITH5_CC_Pos: u32 = 5;
pub const TCC_CC_DITH6_DITHERCY_Pos: u32 = 0;
pub const TCC_CC_DITH6_CC_Pos: u32 = 6;
pub const TCC_CC_CC_Pos: u32 = 0;
pub const TCC_PATTB_OFFSET: u32 = 100;
pub const TCC_PATTB_PGEB0_Pos: u32 = 0;
pub const TCC_PATTB_PGEB1_Pos: u32 = 1;
pub const TCC_PATTB_PGEB2_Pos: u32 = 2;
pub const TCC_PATTB_PGEB3_Pos: u32 = 3;
pub const TCC_PATTB_PGEB4_Pos: u32 = 4;
pub const TCC_PATTB_PGEB5_Pos: u32 = 5;
pub const TCC_PATTB_PGEB6_Pos: u32 = 6;
pub const TCC_PATTB_PGEB7_Pos: u32 = 7;
pub const TCC_PATTB_PGEB_Pos: u32 = 0;
pub const TCC_PATTB_PGVB0_Pos: u32 = 8;
pub const TCC_PATTB_PGVB1_Pos: u32 = 9;
pub const TCC_PATTB_PGVB2_Pos: u32 = 10;
pub const TCC_PATTB_PGVB3_Pos: u32 = 11;
pub const TCC_PATTB_PGVB4_Pos: u32 = 12;
pub const TCC_PATTB_PGVB5_Pos: u32 = 13;
pub const TCC_PATTB_PGVB6_Pos: u32 = 14;
pub const TCC_PATTB_PGVB7_Pos: u32 = 15;
pub const TCC_PATTB_PGVB_Pos: u32 = 8;
pub const TCC_WAVEB_OFFSET: u32 = 104;
pub const TCC_WAVEB_WAVEGENB_Pos: u32 = 0;
pub const TCC_WAVEB_RAMPB_Pos: u32 = 4;
pub const TCC_WAVEB_CIPERENB_Pos: u32 = 7;
pub const TCC_WAVEB_CICCENB0_Pos: u32 = 8;
pub const TCC_WAVEB_CICCENB1_Pos: u32 = 9;
pub const TCC_WAVEB_CICCENB2_Pos: u32 = 10;
pub const TCC_WAVEB_CICCENB3_Pos: u32 = 11;
pub const TCC_WAVEB_CICCENB_Pos: u32 = 8;
pub const TCC_WAVEB_POLB0_Pos: u32 = 16;
pub const TCC_WAVEB_POLB1_Pos: u32 = 17;
pub const TCC_WAVEB_POLB2_Pos: u32 = 18;
pub const TCC_WAVEB_POLB3_Pos: u32 = 19;
pub const TCC_WAVEB_POLB_Pos: u32 = 16;
pub const TCC_WAVEB_SWAPB0_Pos: u32 = 24;
pub const TCC_WAVEB_SWAPB1_Pos: u32 = 25;
pub const TCC_WAVEB_SWAPB2_Pos: u32 = 26;
pub const TCC_WAVEB_SWAPB3_Pos: u32 = 27;
pub const TCC_WAVEB_SWAPB_Pos: u32 = 24;
pub const TCC_PERB_OFFSET: u32 = 108;
pub const TCC_PERB_DITH4_DITHERCYB_Pos: u32 = 0;
pub const TCC_PERB_DITH4_PERB_Pos: u32 = 4;
pub const TCC_PERB_DITH5_DITHERCYB_Pos: u32 = 0;
pub const TCC_PERB_DITH5_PERB_Pos: u32 = 5;
pub const TCC_PERB_DITH6_DITHERCYB_Pos: u32 = 0;
pub const TCC_PERB_DITH6_PERB_Pos: u32 = 6;
pub const TCC_PERB_PERB_Pos: u32 = 0;
pub const TCC_CCB_OFFSET: u32 = 112;
pub const TCC_CCB_DITH4_DITHERCYB_Pos: u32 = 0;
pub const TCC_CCB_DITH4_CCB_Pos: u32 = 4;
pub const TCC_CCB_DITH5_DITHERCYB_Pos: u32 = 0;
pub const TCC_CCB_DITH5_CCB_Pos: u32 = 5;
pub const TCC_CCB_DITH6_DITHERCYB_Pos: u32 = 0;
pub const TCC_CCB_DITH6_CCB_Pos: u32 = 6;
pub const TCC_CCB_CCB_Pos: u32 = 0;
pub const REV_USB: u32 = 257;
pub const USB_CTRLA_OFFSET: u32 = 0;
pub const USB_CTRLA_SWRST_Pos: u32 = 0;
pub const USB_CTRLA_ENABLE_Pos: u32 = 1;
pub const USB_CTRLA_RUNSTDBY_Pos: u32 = 2;
pub const USB_CTRLA_MODE_Pos: u32 = 7;
pub const USB_SYNCBUSY_OFFSET: u32 = 2;
pub const USB_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const USB_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const USB_QOSCTRL_OFFSET: u32 = 3;
pub const USB_QOSCTRL_CQOS_Pos: u32 = 0;
pub const USB_QOSCTRL_DQOS_Pos: u32 = 2;
pub const USB_DEVICE_CTRLB_OFFSET: u32 = 8;
pub const USB_DEVICE_CTRLB_DETACH_Pos: u32 = 0;
pub const USB_DEVICE_CTRLB_UPRSM_Pos: u32 = 1;
pub const USB_DEVICE_CTRLB_SPDCONF_Pos: u32 = 2;
pub const USB_DEVICE_CTRLB_NREPLY_Pos: u32 = 4;
pub const USB_DEVICE_CTRLB_TSTJ_Pos: u32 = 5;
pub const USB_DEVICE_CTRLB_TSTK_Pos: u32 = 6;
pub const USB_DEVICE_CTRLB_TSTPCKT_Pos: u32 = 7;
pub const USB_DEVICE_CTRLB_OPMODE2_Pos: u32 = 8;
pub const USB_DEVICE_CTRLB_GNAK_Pos: u32 = 9;
pub const USB_DEVICE_CTRLB_LPMHDSK_Pos: u32 = 10;
pub const USB_HOST_CTRLB_OFFSET: u32 = 8;
pub const USB_HOST_CTRLB_RESUME_Pos: u32 = 1;
pub const USB_HOST_CTRLB_SPDCONF_Pos: u32 = 2;
pub const USB_HOST_CTRLB_TSTJ_Pos: u32 = 5;
pub const USB_HOST_CTRLB_TSTK_Pos: u32 = 6;
pub const USB_HOST_CTRLB_SOFE_Pos: u32 = 8;
pub const USB_HOST_CTRLB_BUSRESET_Pos: u32 = 9;
pub const USB_HOST_CTRLB_VBUSOK_Pos: u32 = 10;
pub const USB_HOST_CTRLB_L1RESUME_Pos: u32 = 11;
pub const USB_DEVICE_DADD_OFFSET: u32 = 10;
pub const USB_DEVICE_DADD_DADD_Pos: u32 = 0;
pub const USB_DEVICE_DADD_ADDEN_Pos: u32 = 7;
pub const USB_HOST_HSOFC_OFFSET: u32 = 10;
pub const USB_HOST_HSOFC_FLENC_Pos: u32 = 0;
pub const USB_HOST_HSOFC_FLENCE_Pos: u32 = 7;
pub const USB_DEVICE_STATUS_OFFSET: u32 = 12;
pub const USB_DEVICE_STATUS_SPEED_Pos: u32 = 2;
pub const USB_DEVICE_STATUS_LINESTATE_Pos: u32 = 6;
pub const USB_HOST_STATUS_OFFSET: u32 = 12;
pub const USB_HOST_STATUS_SPEED_Pos: u32 = 2;
pub const USB_HOST_STATUS_LINESTATE_Pos: u32 = 6;
pub const USB_FSMSTATUS_OFFSET: u32 = 13;
pub const USB_FSMSTATUS_FSMSTATE_Pos: u32 = 0;
pub const USB_DEVICE_FNUM_OFFSET: u32 = 16;
pub const USB_DEVICE_FNUM_MFNUM_Pos: u32 = 0;
pub const USB_DEVICE_FNUM_FNUM_Pos: u32 = 3;
pub const USB_DEVICE_FNUM_FNCERR_Pos: u32 = 15;
pub const USB_HOST_FNUM_OFFSET: u32 = 16;
pub const USB_HOST_FNUM_MFNUM_Pos: u32 = 0;
pub const USB_HOST_FNUM_FNUM_Pos: u32 = 3;
pub const USB_HOST_FLENHIGH_OFFSET: u32 = 18;
pub const USB_HOST_FLENHIGH_FLENHIGH_Pos: u32 = 0;
pub const USB_DEVICE_INTENCLR_OFFSET: u32 = 20;
pub const USB_DEVICE_INTENCLR_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTENCLR_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTENCLR_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTENCLR_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTENCLR_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTENCLR_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTENCLR_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTENCLR_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTENCLR_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTENCLR_LPMSUSP_Pos: u32 = 9;
pub const USB_HOST_INTENCLR_OFFSET: u32 = 20;
pub const USB_HOST_INTENCLR_HSOF_Pos: u32 = 2;
pub const USB_HOST_INTENCLR_RST_Pos: u32 = 3;
pub const USB_HOST_INTENCLR_WAKEUP_Pos: u32 = 4;
pub const USB_HOST_INTENCLR_DNRSM_Pos: u32 = 5;
pub const USB_HOST_INTENCLR_UPRSM_Pos: u32 = 6;
pub const USB_HOST_INTENCLR_RAMACER_Pos: u32 = 7;
pub const USB_HOST_INTENCLR_DCONN_Pos: u32 = 8;
pub const USB_HOST_INTENCLR_DDISC_Pos: u32 = 9;
pub const USB_DEVICE_INTENSET_OFFSET: u32 = 24;
pub const USB_DEVICE_INTENSET_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTENSET_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTENSET_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTENSET_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTENSET_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTENSET_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTENSET_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTENSET_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTENSET_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTENSET_LPMSUSP_Pos: u32 = 9;
pub const USB_HOST_INTENSET_OFFSET: u32 = 24;
pub const USB_HOST_INTENSET_HSOF_Pos: u32 = 2;
pub const USB_HOST_INTENSET_RST_Pos: u32 = 3;
pub const USB_HOST_INTENSET_WAKEUP_Pos: u32 = 4;
pub const USB_HOST_INTENSET_DNRSM_Pos: u32 = 5;
pub const USB_HOST_INTENSET_UPRSM_Pos: u32 = 6;
pub const USB_HOST_INTENSET_RAMACER_Pos: u32 = 7;
pub const USB_HOST_INTENSET_DCONN_Pos: u32 = 8;
pub const USB_HOST_INTENSET_DDISC_Pos: u32 = 9;
pub const USB_DEVICE_INTFLAG_OFFSET: u32 = 28;
pub const USB_DEVICE_INTFLAG_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTFLAG_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTFLAG_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTFLAG_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTFLAG_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTFLAG_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTFLAG_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTFLAG_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTFLAG_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTFLAG_LPMSUSP_Pos: u32 = 9;
pub const USB_HOST_INTFLAG_OFFSET: u32 = 28;
pub const USB_HOST_INTFLAG_HSOF_Pos: u32 = 2;
pub const USB_HOST_INTFLAG_RST_Pos: u32 = 3;
pub const USB_HOST_INTFLAG_WAKEUP_Pos: u32 = 4;
pub const USB_HOST_INTFLAG_DNRSM_Pos: u32 = 5;
pub const USB_HOST_INTFLAG_UPRSM_Pos: u32 = 6;
pub const USB_HOST_INTFLAG_RAMACER_Pos: u32 = 7;
pub const USB_HOST_INTFLAG_DCONN_Pos: u32 = 8;
pub const USB_HOST_INTFLAG_DDISC_Pos: u32 = 9;
pub const USB_DEVICE_EPINTSMRY_OFFSET: u32 = 32;
pub const USB_DEVICE_EPINTSMRY_EPINT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTSMRY_EPINT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTSMRY_EPINT2_Pos: u32 = 2;
pub const USB_DEVICE_EPINTSMRY_EPINT3_Pos: u32 = 3;
pub const USB_DEVICE_EPINTSMRY_EPINT4_Pos: u32 = 4;
pub const USB_DEVICE_EPINTSMRY_EPINT5_Pos: u32 = 5;
pub const USB_DEVICE_EPINTSMRY_EPINT6_Pos: u32 = 6;
pub const USB_DEVICE_EPINTSMRY_EPINT7_Pos: u32 = 7;
pub const USB_DEVICE_EPINTSMRY_EPINT_Pos: u32 = 0;
pub const USB_HOST_PINTSMRY_OFFSET: u32 = 32;
pub const USB_HOST_PINTSMRY_EPINT0_Pos: u32 = 0;
pub const USB_HOST_PINTSMRY_EPINT1_Pos: u32 = 1;
pub const USB_HOST_PINTSMRY_EPINT2_Pos: u32 = 2;
pub const USB_HOST_PINTSMRY_EPINT3_Pos: u32 = 3;
pub const USB_HOST_PINTSMRY_EPINT4_Pos: u32 = 4;
pub const USB_HOST_PINTSMRY_EPINT5_Pos: u32 = 5;
pub const USB_HOST_PINTSMRY_EPINT6_Pos: u32 = 6;
pub const USB_HOST_PINTSMRY_EPINT7_Pos: u32 = 7;
pub const USB_HOST_PINTSMRY_EPINT_Pos: u32 = 0;
pub const USB_DESCADD_OFFSET: u32 = 36;
pub const USB_DESCADD_DESCADD_Pos: u32 = 0;
pub const USB_PADCAL_OFFSET: u32 = 40;
pub const USB_PADCAL_TRANSP_Pos: u32 = 0;
pub const USB_PADCAL_TRANSN_Pos: u32 = 6;
pub const USB_PADCAL_TRIM_Pos: u32 = 12;
pub const USB_DEVICE_EPCFG_OFFSET: u32 = 256;
pub const USB_DEVICE_EPCFG_EPTYPE0_Pos: u32 = 0;
pub const USB_DEVICE_EPCFG_EPTYPE1_Pos: u32 = 4;
pub const USB_DEVICE_EPCFG_NYETDIS_Pos: u32 = 7;
pub const USB_HOST_PCFG_OFFSET: u32 = 256;
pub const USB_HOST_PCFG_PTOKEN_Pos: u32 = 0;
pub const USB_HOST_PCFG_BK_Pos: u32 = 2;
pub const USB_HOST_PCFG_PTYPE_Pos: u32 = 3;
pub const USB_HOST_BINTERVAL_OFFSET: u32 = 259;
pub const USB_HOST_BINTERVAL_BITINTERVAL_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUSCLR_OFFSET: u32 = 260;
pub const USB_DEVICE_EPSTATUSCLR_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUSCLR_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUSCLR_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSCLR_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUSCLR_BK1RDY_Pos: u32 = 7;
pub const USB_HOST_PSTATUSCLR_OFFSET: u32 = 260;
pub const USB_HOST_PSTATUSCLR_DTGL_Pos: u32 = 0;
pub const USB_HOST_PSTATUSCLR_CURBK_Pos: u32 = 2;
pub const USB_HOST_PSTATUSCLR_PFREEZE_Pos: u32 = 4;
pub const USB_HOST_PSTATUSCLR_BK0RDY_Pos: u32 = 6;
pub const USB_HOST_PSTATUSCLR_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPSTATUSSET_OFFSET: u32 = 261;
pub const USB_DEVICE_EPSTATUSSET_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUSSET_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUSSET_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSSET_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUSSET_BK1RDY_Pos: u32 = 7;
pub const USB_HOST_PSTATUSSET_OFFSET: u32 = 261;
pub const USB_HOST_PSTATUSSET_DTGL_Pos: u32 = 0;
pub const USB_HOST_PSTATUSSET_CURBK_Pos: u32 = 2;
pub const USB_HOST_PSTATUSSET_PFREEZE_Pos: u32 = 4;
pub const USB_HOST_PSTATUSSET_BK0RDY_Pos: u32 = 6;
pub const USB_HOST_PSTATUSSET_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPSTATUS_OFFSET: u32 = 262;
pub const USB_DEVICE_EPSTATUS_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUS_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUS_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUS_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUS_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUS_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUS_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUS_BK1RDY_Pos: u32 = 7;
pub const USB_HOST_PSTATUS_OFFSET: u32 = 262;
pub const USB_HOST_PSTATUS_DTGL_Pos: u32 = 0;
pub const USB_HOST_PSTATUS_CURBK_Pos: u32 = 2;
pub const USB_HOST_PSTATUS_PFREEZE_Pos: u32 = 4;
pub const USB_HOST_PSTATUS_BK0RDY_Pos: u32 = 6;
pub const USB_HOST_PSTATUS_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPINTFLAG_OFFSET: u32 = 263;
pub const USB_DEVICE_EPINTFLAG_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTFLAG_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTFLAG_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTFLAG_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTFLAG_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTFLAG_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTFLAG_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTFLAG_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTFLAG_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTFLAG_STALL_Pos: u32 = 5;
pub const USB_HOST_PINTFLAG_OFFSET: u32 = 263;
pub const USB_HOST_PINTFLAG_TRCPT0_Pos: u32 = 0;
pub const USB_HOST_PINTFLAG_TRCPT1_Pos: u32 = 1;
pub const USB_HOST_PINTFLAG_TRCPT_Pos: u32 = 0;
pub const USB_HOST_PINTFLAG_TRFAIL_Pos: u32 = 2;
pub const USB_HOST_PINTFLAG_PERR_Pos: u32 = 3;
pub const USB_HOST_PINTFLAG_TXSTP_Pos: u32 = 4;
pub const USB_HOST_PINTFLAG_STALL_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENCLR_OFFSET: u32 = 264;
pub const USB_DEVICE_EPINTENCLR_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENCLR_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTENCLR_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENCLR_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENCLR_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTENCLR_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENCLR_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTENCLR_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENCLR_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTENCLR_STALL_Pos: u32 = 5;
pub const USB_HOST_PINTENCLR_OFFSET: u32 = 264;
pub const USB_HOST_PINTENCLR_TRCPT0_Pos: u32 = 0;
pub const USB_HOST_PINTENCLR_TRCPT1_Pos: u32 = 1;
pub const USB_HOST_PINTENCLR_TRCPT_Pos: u32 = 0;
pub const USB_HOST_PINTENCLR_TRFAIL_Pos: u32 = 2;
pub const USB_HOST_PINTENCLR_PERR_Pos: u32 = 3;
pub const USB_HOST_PINTENCLR_TXSTP_Pos: u32 = 4;
pub const USB_HOST_PINTENCLR_STALL_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENSET_OFFSET: u32 = 265;
pub const USB_DEVICE_EPINTENSET_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENSET_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTENSET_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENSET_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENSET_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTENSET_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENSET_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTENSET_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENSET_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTENSET_STALL_Pos: u32 = 5;
pub const USB_HOST_PINTENSET_OFFSET: u32 = 265;
pub const USB_HOST_PINTENSET_TRCPT0_Pos: u32 = 0;
pub const USB_HOST_PINTENSET_TRCPT1_Pos: u32 = 1;
pub const USB_HOST_PINTENSET_TRCPT_Pos: u32 = 0;
pub const USB_HOST_PINTENSET_TRFAIL_Pos: u32 = 2;
pub const USB_HOST_PINTENSET_PERR_Pos: u32 = 3;
pub const USB_HOST_PINTENSET_TXSTP_Pos: u32 = 4;
pub const USB_HOST_PINTENSET_STALL_Pos: u32 = 5;
pub const USB_DEVICE_ADDR_OFFSET: u32 = 0;
pub const USB_DEVICE_ADDR_ADDR_Pos: u32 = 0;
pub const USB_HOST_ADDR_OFFSET: u32 = 0;
pub const USB_HOST_ADDR_ADDR_Pos: u32 = 0;
pub const USB_DEVICE_PCKSIZE_OFFSET: u32 = 4;
pub const USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos: u32 = 0;
pub const USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos: u32 = 14;
pub const USB_DEVICE_PCKSIZE_SIZE_Pos: u32 = 28;
pub const USB_DEVICE_PCKSIZE_AUTO_ZLP_Pos: u32 = 31;
pub const USB_HOST_PCKSIZE_OFFSET: u32 = 4;
pub const USB_HOST_PCKSIZE_BYTE_COUNT_Pos: u32 = 0;
pub const USB_HOST_PCKSIZE_MULTI_PACKET_SIZE_Pos: u32 = 14;
pub const USB_HOST_PCKSIZE_SIZE_Pos: u32 = 28;
pub const USB_HOST_PCKSIZE_AUTO_ZLP_Pos: u32 = 31;
pub const USB_DEVICE_EXTREG_OFFSET: u32 = 8;
pub const USB_DEVICE_EXTREG_SUBPID_Pos: u32 = 0;
pub const USB_DEVICE_EXTREG_VARIABLE_Pos: u32 = 4;
pub const USB_HOST_EXTREG_OFFSET: u32 = 8;
pub const USB_HOST_EXTREG_SUBPID_Pos: u32 = 0;
pub const USB_HOST_EXTREG_VARIABLE_Pos: u32 = 4;
pub const USB_DEVICE_STATUS_BK_OFFSET: u32 = 10;
pub const USB_DEVICE_STATUS_BK_CRCERR_Pos: u32 = 0;
pub const USB_DEVICE_STATUS_BK_ERRORFLOW_Pos: u32 = 1;
pub const USB_HOST_STATUS_BK_OFFSET: u32 = 10;
pub const USB_HOST_STATUS_BK_CRCERR_Pos: u32 = 0;
pub const USB_HOST_STATUS_BK_ERRORFLOW_Pos: u32 = 1;
pub const USB_HOST_CTRL_PIPE_OFFSET: u32 = 12;
pub const USB_HOST_CTRL_PIPE_PDADDR_Pos: u32 = 0;
pub const USB_HOST_CTRL_PIPE_PEPNUM_Pos: u32 = 8;
pub const USB_HOST_CTRL_PIPE_PERMAX_Pos: u32 = 12;
pub const USB_HOST_STATUS_PIPE_OFFSET: u32 = 14;
pub const USB_HOST_STATUS_PIPE_DTGLER_Pos: u32 = 0;
pub const USB_HOST_STATUS_PIPE_DAPIDER_Pos: u32 = 1;
pub const USB_HOST_STATUS_PIPE_PIDER_Pos: u32 = 2;
pub const USB_HOST_STATUS_PIPE_TOUTER_Pos: u32 = 3;
pub const USB_HOST_STATUS_PIPE_CRC16ER_Pos: u32 = 4;
pub const USB_HOST_STATUS_PIPE_ERCNT_Pos: u32 = 5;
pub const REV_WDT: u32 = 512;
pub const WDT_CTRL_OFFSET: u32 = 0;
pub const WDT_CTRL_ENABLE_Pos: u32 = 1;
pub const WDT_CTRL_WEN_Pos: u32 = 2;
pub const WDT_CTRL_ALWAYSON_Pos: u32 = 7;
pub const WDT_CONFIG_OFFSET: u32 = 1;
pub const WDT_CONFIG_PER_Pos: u32 = 0;
pub const WDT_CONFIG_WINDOW_Pos: u32 = 4;
pub const WDT_EWCTRL_OFFSET: u32 = 2;
pub const WDT_EWCTRL_EWOFFSET_Pos: u32 = 0;
pub const WDT_INTENCLR_OFFSET: u32 = 4;
pub const WDT_INTENCLR_EW_Pos: u32 = 0;
pub const WDT_INTENSET_OFFSET: u32 = 5;
pub const WDT_INTENSET_EW_Pos: u32 = 0;
pub const WDT_INTFLAG_OFFSET: u32 = 6;
pub const WDT_INTFLAG_EW_Pos: u32 = 0;
pub const WDT_STATUS_OFFSET: u32 = 7;
pub const WDT_STATUS_SYNCBUSY_Pos: u32 = 7;
pub const WDT_CLEAR_OFFSET: u32 = 8;
pub const WDT_CLEAR_CLEAR_Pos: u32 = 0;
pub const AC_CMP_NUM: u32 = 2;
pub const AC_GCLK_ID_ANA: u32 = 32;
pub const AC_GCLK_ID_DIG: u32 = 31;
pub const AC_NUM_CMP: u32 = 2;
pub const AC_PAIRS: u32 = 1;
pub const ADC_DMAC_ID_RESRDY: u32 = 39;
pub const ADC_EXTCHANNEL_MSB: u32 = 19;
pub const ADC_GCLK_ID: u32 = 30;
pub const ADC_RESULT_BITS: u32 = 16;
pub const ADC_RESULT_MSB: u32 = 15;
pub const DAC_DMAC_ID_EMPTY: u32 = 40;
pub const DAC_GCLK_ID: u32 = 33;
pub const DMAC_CH_BITS: u32 = 4;
pub const DMAC_CH_NUM: u32 = 12;
pub const DMAC_CLK_AHB_ID: u32 = 5;
pub const DMAC_EVIN_NUM: u32 = 4;
pub const DMAC_EVOUT_NUM: u32 = 4;
pub const DMAC_LVL_BITS: u32 = 2;
pub const DMAC_LVL_NUM: u32 = 4;
pub const DMAC_TRIG_BITS: u32 = 6;
pub const DMAC_TRIG_NUM: u32 = 45;
pub const DSU_CLK_HSB_ID: u32 = 3;
pub const EIC_CONFIG_NUM: u32 = 2;
pub const EIC_GCLK_ID: u32 = 5;
pub const EVSYS_CHANNELS: u32 = 12;
pub const EVSYS_CHANNELS_BITS: u32 = 4;
pub const EVSYS_CHANNELS_MSB: u32 = 11;
pub const EVSYS_EXTEVT_NUM: u32 = 0;
pub const EVSYS_GCLK_ID_0: u32 = 7;
pub const EVSYS_GCLK_ID_1: u32 = 8;
pub const EVSYS_GCLK_ID_2: u32 = 9;
pub const EVSYS_GCLK_ID_3: u32 = 10;
pub const EVSYS_GCLK_ID_4: u32 = 11;
pub const EVSYS_GCLK_ID_5: u32 = 12;
pub const EVSYS_GCLK_ID_6: u32 = 13;
pub const EVSYS_GCLK_ID_7: u32 = 14;
pub const EVSYS_GCLK_ID_8: u32 = 15;
pub const EVSYS_GCLK_ID_9: u32 = 16;
pub const EVSYS_GCLK_ID_10: u32 = 17;
pub const EVSYS_GCLK_ID_11: u32 = 18;
pub const EVSYS_GCLK_ID_LSB: u32 = 7;
pub const EVSYS_GCLK_ID_MSB: u32 = 18;
pub const EVSYS_GCLK_ID_SIZE: u32 = 12;
pub const EVSYS_GENERATORS: u32 = 73;
pub const EVSYS_GENERATORS_BITS: u32 = 7;
pub const EVSYS_USERS: u32 = 29;
pub const EVSYS_USERS_BITS: u32 = 5;
pub const EVSYS_ID_GEN_RTC_CMP_0: u32 = 1;
pub const EVSYS_ID_GEN_RTC_CMP_1: u32 = 2;
pub const EVSYS_ID_GEN_RTC_OVF: u32 = 3;
pub const EVSYS_ID_GEN_RTC_PER_0: u32 = 4;
pub const EVSYS_ID_GEN_RTC_PER_1: u32 = 5;
pub const EVSYS_ID_GEN_RTC_PER_2: u32 = 6;
pub const EVSYS_ID_GEN_RTC_PER_3: u32 = 7;
pub const EVSYS_ID_GEN_RTC_PER_4: u32 = 8;
pub const EVSYS_ID_GEN_RTC_PER_5: u32 = 9;
pub const EVSYS_ID_GEN_RTC_PER_6: u32 = 10;
pub const EVSYS_ID_GEN_RTC_PER_7: u32 = 11;
pub const EVSYS_ID_GEN_EIC_EXTINT_0: u32 = 12;
pub const EVSYS_ID_GEN_EIC_EXTINT_1: u32 = 13;
pub const EVSYS_ID_GEN_EIC_EXTINT_2: u32 = 14;
pub const EVSYS_ID_GEN_EIC_EXTINT_3: u32 = 15;
pub const EVSYS_ID_GEN_EIC_EXTINT_4: u32 = 16;
pub const EVSYS_ID_GEN_EIC_EXTINT_5: u32 = 17;
pub const EVSYS_ID_GEN_EIC_EXTINT_6: u32 = 18;
pub const EVSYS_ID_GEN_EIC_EXTINT_7: u32 = 19;
pub const EVSYS_ID_GEN_EIC_EXTINT_8: u32 = 20;
pub const EVSYS_ID_GEN_EIC_EXTINT_9: u32 = 21;
pub const EVSYS_ID_GEN_EIC_EXTINT_10: u32 = 22;
pub const EVSYS_ID_GEN_EIC_EXTINT_11: u32 = 23;
pub const EVSYS_ID_GEN_EIC_EXTINT_12: u32 = 24;
pub const EVSYS_ID_GEN_EIC_EXTINT_13: u32 = 25;
pub const EVSYS_ID_GEN_EIC_EXTINT_14: u32 = 26;
pub const EVSYS_ID_GEN_EIC_EXTINT_15: u32 = 27;
pub const EVSYS_ID_GEN_EIC_EXTINT_16: u32 = 28;
pub const EVSYS_ID_GEN_EIC_EXTINT_17: u32 = 29;
pub const EVSYS_ID_GEN_DMAC_CH_0: u32 = 30;
pub const EVSYS_ID_GEN_DMAC_CH_1: u32 = 31;
pub const EVSYS_ID_GEN_DMAC_CH_2: u32 = 32;
pub const EVSYS_ID_GEN_DMAC_CH_3: u32 = 33;
pub const EVSYS_ID_GEN_TCC0_OVF: u32 = 34;
pub const EVSYS_ID_GEN_TCC0_TRG: u32 = 35;
pub const EVSYS_ID_GEN_TCC0_CNT: u32 = 36;
pub const EVSYS_ID_GEN_TCC0_MCX_0: u32 = 37;
pub const EVSYS_ID_GEN_TCC0_MCX_1: u32 = 38;
pub const EVSYS_ID_GEN_TCC0_MCX_2: u32 = 39;
pub const EVSYS_ID_GEN_TCC0_MCX_3: u32 = 40;
pub const EVSYS_ID_GEN_TCC1_OVF: u32 = 41;
pub const EVSYS_ID_GEN_TCC1_TRG: u32 = 42;
pub const EVSYS_ID_GEN_TCC1_CNT: u32 = 43;
pub const EVSYS_ID_GEN_TCC1_MCX_0: u32 = 44;
pub const EVSYS_ID_GEN_TCC1_MCX_1: u32 = 45;
pub const EVSYS_ID_GEN_TCC2_OVF: u32 = 46;
pub const EVSYS_ID_GEN_TCC2_TRG: u32 = 47;
pub const EVSYS_ID_GEN_TCC2_CNT: u32 = 48;
pub const EVSYS_ID_GEN_TCC2_MCX_0: u32 = 49;
pub const EVSYS_ID_GEN_TCC2_MCX_1: u32 = 50;
pub const EVSYS_ID_GEN_TC3_OVF: u32 = 51;
pub const EVSYS_ID_GEN_TC3_MCX_0: u32 = 52;
pub const EVSYS_ID_GEN_TC3_MCX_1: u32 = 53;
pub const EVSYS_ID_GEN_TC4_OVF: u32 = 54;
pub const EVSYS_ID_GEN_TC4_MCX_0: u32 = 55;
pub const EVSYS_ID_GEN_TC4_MCX_1: u32 = 56;
pub const EVSYS_ID_GEN_TC5_OVF: u32 = 57;
pub const EVSYS_ID_GEN_TC5_MCX_0: u32 = 58;
pub const EVSYS_ID_GEN_TC5_MCX_1: u32 = 59;
pub const EVSYS_ID_GEN_TC6_OVF: u32 = 60;
pub const EVSYS_ID_GEN_TC6_MCX_0: u32 = 61;
pub const EVSYS_ID_GEN_TC6_MCX_1: u32 = 62;
pub const EVSYS_ID_GEN_TC7_OVF: u32 = 63;
pub const EVSYS_ID_GEN_TC7_MCX_0: u32 = 64;
pub const EVSYS_ID_GEN_TC7_MCX_1: u32 = 65;
pub const EVSYS_ID_GEN_ADC_RESRDY: u32 = 66;
pub const EVSYS_ID_GEN_ADC_WINMON: u32 = 67;
pub const EVSYS_ID_GEN_AC_COMP_0: u32 = 68;
pub const EVSYS_ID_GEN_AC_COMP_1: u32 = 69;
pub const EVSYS_ID_GEN_AC_WIN_0: u32 = 70;
pub const EVSYS_ID_GEN_DAC_EMPTY: u32 = 71;
pub const EVSYS_ID_USER_DMAC_CH_0: u32 = 0;
pub const EVSYS_ID_USER_DMAC_CH_1: u32 = 1;
pub const EVSYS_ID_USER_DMAC_CH_2: u32 = 2;
pub const EVSYS_ID_USER_DMAC_CH_3: u32 = 3;
pub const EVSYS_ID_USER_TCC0_EV_0: u32 = 4;
pub const EVSYS_ID_USER_TCC0_EV_1: u32 = 5;
pub const EVSYS_ID_USER_TCC0_MC_0: u32 = 6;
pub const EVSYS_ID_USER_TCC0_MC_1: u32 = 7;
pub const EVSYS_ID_USER_TCC0_MC_2: u32 = 8;
pub const EVSYS_ID_USER_TCC0_MC_3: u32 = 9;
pub const EVSYS_ID_USER_TCC1_EV_0: u32 = 10;
pub const EVSYS_ID_USER_TCC1_EV_1: u32 = 11;
pub const EVSYS_ID_USER_TCC1_MC_0: u32 = 12;
pub const EVSYS_ID_USER_TCC1_MC_1: u32 = 13;
pub const EVSYS_ID_USER_TCC2_EV_0: u32 = 14;
pub const EVSYS_ID_USER_TCC2_EV_1: u32 = 15;
pub const EVSYS_ID_USER_TCC2_MC_0: u32 = 16;
pub const EVSYS_ID_USER_TCC2_MC_1: u32 = 17;
pub const EVSYS_ID_USER_TC3_EVU: u32 = 18;
pub const EVSYS_ID_USER_TC4_EVU: u32 = 19;
pub const EVSYS_ID_USER_TC5_EVU: u32 = 20;
pub const EVSYS_ID_USER_TC6_EVU: u32 = 21;
pub const EVSYS_ID_USER_TC7_EVU: u32 = 22;
pub const EVSYS_ID_USER_ADC_START: u32 = 23;
pub const EVSYS_ID_USER_ADC_SYNC: u32 = 24;
pub const EVSYS_ID_USER_AC_SOC_0: u32 = 25;
pub const EVSYS_ID_USER_AC_SOC_1: u32 = 26;
pub const EVSYS_ID_USER_DAC_START: u32 = 27;
pub const GCLK_GENDIV_BITS: u32 = 16;
pub const GCLK_GEN_NUM: u32 = 9;
pub const GCLK_GEN_NUM_MSB: u32 = 8;
pub const GCLK_GEN_SOURCE_NUM_MSB: u32 = 8;
pub const GCLK_NUM: u32 = 37;
pub const GCLK_SOURCE_DFLL48M: u32 = 7;
pub const GCLK_SOURCE_DPLL96M: u32 = 8;
pub const GCLK_SOURCE_GCLKGEN1: u32 = 2;
pub const GCLK_SOURCE_GCLKIN: u32 = 1;
pub const GCLK_SOURCE_NUM: u32 = 9;
pub const GCLK_SOURCE_OSCULP32K: u32 = 3;
pub const GCLK_SOURCE_OSC8M: u32 = 6;
pub const GCLK_SOURCE_OSC32K: u32 = 4;
pub const GCLK_SOURCE_XOSC: u32 = 0;
pub const GCLK_SOURCE_XOSC32K: u32 = 5;
pub const SBMATRIX_SLAVE_FLASH: u32 = 0;
pub const SBMATRIX_SLAVE_HPB0: u32 = 1;
pub const SBMATRIX_SLAVE_HPB1: u32 = 2;
pub const SBMATRIX_SLAVE_HPB2: u32 = 3;
pub const SBMATRIX_SLAVE_HMCRAMC0: u32 = 4;
pub const SBMATRIX_SLAVE_HMCRAMC0_ALT0: u32 = 5;
pub const SBMATRIX_SLAVE_HMCRAMC0_ALT1: u32 = 6;
pub const SBMATRIX_SLAVE_NUM: u32 = 7;
pub const SBMATRIX_MASTER_CM0PLUS: u32 = 0;
pub const SBMATRIX_MASTER_DSU: u32 = 1;
pub const SBMATRIX_MASTER_DMAC: u32 = 2;
pub const SBMATRIX_MASTER_NUM: u32 = 3;
pub const I2S_CLK_NUM: u32 = 2;
pub const I2S_DMAC_ID_RX_0: u32 = 41;
pub const I2S_DMAC_ID_RX_1: u32 = 42;
pub const I2S_DMAC_ID_RX_LSB: u32 = 41;
pub const I2S_DMAC_ID_RX_MSB: u32 = 42;
pub const I2S_DMAC_ID_RX_SIZE: u32 = 2;
pub const I2S_DMAC_ID_TX_0: u32 = 43;
pub const I2S_DMAC_ID_TX_1: u32 = 44;
pub const I2S_DMAC_ID_TX_LSB: u32 = 43;
pub const I2S_DMAC_ID_TX_MSB: u32 = 44;
pub const I2S_DMAC_ID_TX_SIZE: u32 = 2;
pub const I2S_GCLK_ID_0: u32 = 35;
pub const I2S_GCLK_ID_1: u32 = 36;
pub const I2S_GCLK_ID_LSB: u32 = 35;
pub const I2S_GCLK_ID_MSB: u32 = 36;
pub const I2S_GCLK_ID_SIZE: u32 = 2;
pub const I2S_MAX_SLOTS: u32 = 8;
pub const I2S_SER_NUM: u32 = 2;
pub const NVMCTRL_AUX0_ADDRESS: u32 = 8404992;
pub const NVMCTRL_AUX1_ADDRESS: u32 = 8413184;
pub const NVMCTRL_AUX2_ADDRESS: u32 = 8421376;
pub const NVMCTRL_AUX3_ADDRESS: u32 = 8429568;
pub const NVMCTRL_CLK_AHB_ID: u32 = 4;
pub const NVMCTRL_FACTORY_WORD_IMPLEMENTED_MASK: i64 = -4611685984067649537;
pub const NVMCTRL_FLASH_SIZE: u32 = 262144;
pub const NVMCTRL_LOCKBIT_ADDRESS: u32 = 8396800;
pub const NVMCTRL_PAGE_HW: u32 = 32;
pub const NVMCTRL_PAGE_SIZE: u32 = 64;
pub const NVMCTRL_PAGE_W: u32 = 16;
pub const NVMCTRL_PMSB: u32 = 3;
pub const NVMCTRL_PSZ_BITS: u32 = 6;
pub const NVMCTRL_ROW_PAGES: u32 = 4;
pub const NVMCTRL_ROW_SIZE: u32 = 256;
pub const NVMCTRL_TEMP_LOG_ADDRESS: u32 = 8413232;
pub const NVMCTRL_USER_PAGE_ADDRESS: u32 = 8388608;
pub const NVMCTRL_USER_PAGE_OFFSET: u32 = 8388608;
pub const NVMCTRL_USER_WORD_IMPLEMENTED_MASK: i64 = -4602678819172646913;
pub const PAC0_WPROT_DEFAULT_VAL: u32 = 0;
pub const PAC1_WPROT_DEFAULT_VAL: u32 = 2;
pub const PAC2_WPROT_DEFAULT_VAL: u32 = 8388608;
pub const PM_CTRL_MCSEL_DFLL48M: u32 = 3;
pub const PM_CTRL_MCSEL_GCLK: u32 = 0;
pub const PM_CTRL_MCSEL_OSC8M: u32 = 1;
pub const PM_CTRL_MCSEL_XOSC: u32 = 2;
pub const PM_PM_CLK_APB_NUM: u32 = 2;
pub const PORT_BITS: u32 = 84;
pub const PORT_DRVSTR: u32 = 1;
pub const PORT_ODRAIN: u32 = 0;
pub const PORT_SLEWLIM: u32 = 0;
pub const PTC_GCLK_ID: u32 = 34;
pub const RTC_ALARM_NUM: u32 = 1;
pub const RTC_COMP16_NUM: u32 = 2;
pub const RTC_COMP32_NUM: u32 = 1;
pub const RTC_GCLK_ID: u32 = 4;
pub const RTC_NUM_OF_ALARMS: u32 = 1;
pub const RTC_NUM_OF_COMP16: u32 = 2;
pub const RTC_NUM_OF_COMP32: u32 = 1;
pub const SERCOM0_DMAC_ID_RX: u32 = 1;
pub const SERCOM0_DMAC_ID_TX: u32 = 2;
pub const SERCOM0_GCLK_ID_CORE: u32 = 20;
pub const SERCOM0_GCLK_ID_SLOW: u32 = 19;
pub const SERCOM0_INT_MSB: u32 = 6;
pub const SERCOM1_DMAC_ID_RX: u32 = 3;
pub const SERCOM1_DMAC_ID_TX: u32 = 4;
pub const SERCOM1_GCLK_ID_CORE: u32 = 21;
pub const SERCOM1_GCLK_ID_SLOW: u32 = 19;
pub const SERCOM1_INT_MSB: u32 = 6;
pub const SERCOM2_DMAC_ID_RX: u32 = 5;
pub const SERCOM2_DMAC_ID_TX: u32 = 6;
pub const SERCOM2_GCLK_ID_CORE: u32 = 22;
pub const SERCOM2_GCLK_ID_SLOW: u32 = 19;
pub const SERCOM2_INT_MSB: u32 = 6;
pub const SERCOM3_DMAC_ID_RX: u32 = 7;
pub const SERCOM3_DMAC_ID_TX: u32 = 8;
pub const SERCOM3_GCLK_ID_CORE: u32 = 23;
pub const SERCOM3_GCLK_ID_SLOW: u32 = 19;
pub const SERCOM3_INT_MSB: u32 = 6;
pub const SYSCTRL_BGAP_CALIB_MSB: u32 = 11;
pub const SYSCTRL_BOD33_CALIB_MSB: u32 = 5;
pub const SYSCTRL_DFLL48M_COARSE_MSB: u32 = 5;
pub const SYSCTRL_DFLL48M_FINE_MSB: u32 = 9;
pub const SYSCTRL_GCLK_ID_DFLL48: u32 = 0;
pub const SYSCTRL_GCLK_ID_FDPLL: u32 = 1;
pub const SYSCTRL_GCLK_ID_FDPLL32K: u32 = 2;
pub const SYSCTRL_OSC32K_COARSE_CALIB_MSB: u32 = 6;
pub const SYSCTRL_POR33_ENTEST_MSB: u32 = 1;
pub const SYSCTRL_SYSTEM_CLOCK: u32 = 1000000;
pub const SYSCTRL_ULPVREF_DIVLEV_MSB: u32 = 3;
pub const SYSCTRL_ULPVREG_FORCEGAIN_MSB: u32 = 1;
pub const SYSCTRL_ULPVREG_RAMREFSEL_MSB: u32 = 2;
pub const SYSCTRL_VREF_CONTROL_MSB: u32 = 48;
pub const SYSCTRL_VREF_STATUS_MSB: u32 = 7;
pub const SYSCTRL_VREG_LEVEL_MSB: u32 = 2;
pub const SYSCTRL_BOD12_VERSION: u32 = 273;
pub const SYSCTRL_BOD33_VERSION: u32 = 273;
pub const SYSCTRL_DFLL48M_VERSION: u32 = 769;
pub const SYSCTRL_FDPLL_VERSION: u32 = 273;
pub const SYSCTRL_OSCULP32K_VERSION: u32 = 273;
pub const SYSCTRL_OSC8M_VERSION: u32 = 288;
pub const SYSCTRL_OSC32K_VERSION: u32 = 4353;
pub const SYSCTRL_VREF_VERSION: u32 = 512;
pub const SYSCTRL_VREG_VERSION: u32 = 513;
pub const SYSCTRL_XOSC_VERSION: u32 = 4369;
pub const SYSCTRL_XOSC32K_VERSION: u32 = 4369;
pub const TC3_CC8_NUM: u32 = 2;
pub const TC3_CC16_NUM: u32 = 2;
pub const TC3_CC32_NUM: u32 = 2;
pub const TC3_DITHERING_EXT: u32 = 0;
pub const TC3_DMAC_ID_MC_0: u32 = 25;
pub const TC3_DMAC_ID_MC_1: u32 = 26;
pub const TC3_DMAC_ID_MC_LSB: u32 = 25;
pub const TC3_DMAC_ID_MC_MSB: u32 = 26;
pub const TC3_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC3_DMAC_ID_OVF: u32 = 24;
pub const TC3_GCLK_ID: u32 = 27;
pub const TC3_MASTER: u32 = 0;
pub const TC3_OW_NUM: u32 = 2;
pub const TC3_PERIOD_EXT: u32 = 0;
pub const TC3_SHADOW_EXT: u32 = 0;
pub const TC4_CC8_NUM: u32 = 2;
pub const TC4_CC16_NUM: u32 = 2;
pub const TC4_CC32_NUM: u32 = 2;
pub const TC4_DITHERING_EXT: u32 = 0;
pub const TC4_DMAC_ID_MC_0: u32 = 28;
pub const TC4_DMAC_ID_MC_1: u32 = 29;
pub const TC4_DMAC_ID_MC_LSB: u32 = 28;
pub const TC4_DMAC_ID_MC_MSB: u32 = 29;
pub const TC4_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC4_DMAC_ID_OVF: u32 = 27;
pub const TC4_GCLK_ID: u32 = 28;
pub const TC4_MASTER: u32 = 1;
pub const TC4_OW_NUM: u32 = 2;
pub const TC4_PERIOD_EXT: u32 = 0;
pub const TC4_SHADOW_EXT: u32 = 0;
pub const TC5_CC8_NUM: u32 = 2;
pub const TC5_CC16_NUM: u32 = 2;
pub const TC5_CC32_NUM: u32 = 2;
pub const TC5_DITHERING_EXT: u32 = 0;
pub const TC5_DMAC_ID_MC_0: u32 = 31;
pub const TC5_DMAC_ID_MC_1: u32 = 32;
pub const TC5_DMAC_ID_MC_LSB: u32 = 31;
pub const TC5_DMAC_ID_MC_MSB: u32 = 32;
pub const TC5_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC5_DMAC_ID_OVF: u32 = 30;
pub const TC5_GCLK_ID: u32 = 28;
pub const TC5_MASTER: u32 = 0;
pub const TC5_OW_NUM: u32 = 2;
pub const TC5_PERIOD_EXT: u32 = 0;
pub const TC5_SHADOW_EXT: u32 = 0;
pub const TCC0_CC_NUM: u32 = 4;
pub const TCC0_DITHERING: u32 = 1;
pub const TCC0_DMAC_ID_MC_0: u32 = 14;
pub const TCC0_DMAC_ID_MC_1: u32 = 15;
pub const TCC0_DMAC_ID_MC_2: u32 = 16;
pub const TCC0_DMAC_ID_MC_3: u32 = 17;
pub const TCC0_DMAC_ID_MC_LSB: u32 = 14;
pub const TCC0_DMAC_ID_MC_MSB: u32 = 17;
pub const TCC0_DMAC_ID_MC_SIZE: u32 = 4;
pub const TCC0_DMAC_ID_OVF: u32 = 13;
pub const TCC0_DTI: u32 = 1;
pub const TCC0_EXT: u32 = 31;
pub const TCC0_GCLK_ID: u32 = 26;
pub const TCC0_OTMX: u32 = 1;
pub const TCC0_OW_NUM: u32 = 8;
pub const TCC0_PG: u32 = 1;
pub const TCC0_SIZE: u32 = 24;
pub const TCC0_SWAP: u32 = 1;
pub const TCC0_TYPE: u32 = 0;
pub const TCC1_CC_NUM: u32 = 2;
pub const TCC1_DITHERING: u32 = 1;
pub const TCC1_DMAC_ID_MC_0: u32 = 19;
pub const TCC1_DMAC_ID_MC_1: u32 = 20;
pub const TCC1_DMAC_ID_MC_LSB: u32 = 19;
pub const TCC1_DMAC_ID_MC_MSB: u32 = 20;
pub const TCC1_DMAC_ID_MC_SIZE: u32 = 2;
pub const TCC1_DMAC_ID_OVF: u32 = 18;
pub const TCC1_DTI: u32 = 0;
pub const TCC1_EXT: u32 = 24;
pub const TCC1_GCLK_ID: u32 = 26;
pub const TCC1_OTMX: u32 = 0;
pub const TCC1_OW_NUM: u32 = 4;
pub const TCC1_PG: u32 = 1;
pub const TCC1_SIZE: u32 = 24;
pub const TCC1_SWAP: u32 = 0;
pub const TCC1_TYPE: u32 = 0;
pub const TCC2_CC_NUM: u32 = 2;
pub const TCC2_DITHERING: u32 = 0;
pub const TCC2_DMAC_ID_MC_0: u32 = 22;
pub const TCC2_DMAC_ID_MC_1: u32 = 23;
pub const TCC2_DMAC_ID_MC_LSB: u32 = 22;
pub const TCC2_DMAC_ID_MC_MSB: u32 = 23;
pub const TCC2_DMAC_ID_MC_SIZE: u32 = 2;
pub const TCC2_DMAC_ID_OVF: u32 = 21;
pub const TCC2_DTI: u32 = 0;
pub const TCC2_EXT: u32 = 0;
pub const TCC2_GCLK_ID: u32 = 27;
pub const TCC2_OTMX: u32 = 0;
pub const TCC2_OW_NUM: u32 = 2;
pub const TCC2_PG: u32 = 0;
pub const TCC2_SIZE: u32 = 16;
pub const TCC2_SWAP: u32 = 0;
pub const TCC2_TYPE: u32 = 0;
pub const USB_EPT_NBR: u32 = 8;
pub const USB_EPT_NUM: u32 = 8;
pub const USB_GCLK_ID: u32 = 6;
pub const USB_PIPE_NUM: u32 = 8;
pub const WDT_GCLK_ID: u32 = 3;
pub const ID_PAC0: u32 = 0;
pub const ID_PM: u32 = 1;
pub const ID_SYSCTRL: u32 = 2;
pub const ID_GCLK: u32 = 3;
pub const ID_WDT: u32 = 4;
pub const ID_RTC: u32 = 5;
pub const ID_EIC: u32 = 6;
pub const ID_PAC1: u32 = 32;
pub const ID_DSU: u32 = 33;
pub const ID_NVMCTRL: u32 = 34;
pub const ID_PORT: u32 = 35;
pub const ID_DMAC: u32 = 36;
pub const ID_USB: u32 = 37;
pub const ID_MTB: u32 = 38;
pub const ID_SBMATRIX: u32 = 39;
pub const ID_PAC2: u32 = 64;
pub const ID_EVSYS: u32 = 65;
pub const ID_SERCOM0: u32 = 66;
pub const ID_SERCOM1: u32 = 67;
pub const ID_SERCOM2: u32 = 68;
pub const ID_SERCOM3: u32 = 69;
pub const ID_TCC0: u32 = 72;
pub const ID_TCC1: u32 = 73;
pub const ID_TCC2: u32 = 74;
pub const ID_TC3: u32 = 75;
pub const ID_TC4: u32 = 76;
pub const ID_TC5: u32 = 77;
pub const ID_ADC: u32 = 80;
pub const ID_AC: u32 = 81;
pub const ID_DAC: u32 = 82;
pub const ID_PTC: u32 = 83;
pub const ID_I2S: u32 = 84;
pub const ID_PERIPH_COUNT: u32 = 85;
pub const AC_INST_NUM: u32 = 1;
pub const ADC_INST_NUM: u32 = 1;
pub const DAC_INST_NUM: u32 = 1;
pub const DMAC_INST_NUM: u32 = 1;
pub const DSU_INST_NUM: u32 = 1;
pub const EIC_INST_NUM: u32 = 1;
pub const EVSYS_INST_NUM: u32 = 1;
pub const GCLK_INST_NUM: u32 = 1;
pub const HMATRIXB_INST_NUM: u32 = 1;
pub const I2S_INST_NUM: u32 = 1;
pub const MTB_INST_NUM: u32 = 1;
pub const NVMCTRL_CAL: u32 = 8388608;
pub const NVMCTRL_LOCKBIT: u32 = 8396800;
pub const NVMCTRL_OTP1: u32 = 8413184;
pub const NVMCTRL_OTP2: u32 = 8413192;
pub const NVMCTRL_OTP4: u32 = 8413216;
pub const NVMCTRL_TEMP_LOG: u32 = 8413232;
pub const NVMCTRL_USER: u32 = 8404992;
pub const NVMCTRL_INST_NUM: u32 = 1;
pub const PAC_INST_NUM: u32 = 3;
pub const PM_INST_NUM: u32 = 1;
pub const PORT_INST_NUM: u32 = 1;
pub const PORT_IOBUS_INST_NUM: u32 = 1;
pub const PTC_INST_NUM: u32 = 1;
pub const RTC_INST_NUM: u32 = 1;
pub const SERCOM_INST_NUM: u32 = 4;
pub const SYSCTRL_INST_NUM: u32 = 1;
pub const TC_INST_NUM: u32 = 3;
pub const TCC_INST_NUM: u32 = 3;
pub const USB_INST_NUM: u32 = 1;
pub const WDT_INST_NUM: u32 = 1;
pub const PIN_PA00: u32 = 0;
pub const PIN_PA01: u32 = 1;
pub const PIN_PA02: u32 = 2;
pub const PIN_PA03: u32 = 3;
pub const PIN_PA04: u32 = 4;
pub const PIN_PA05: u32 = 5;
pub const PIN_PA06: u32 = 6;
pub const PIN_PA07: u32 = 7;
pub const PIN_PA08: u32 = 8;
pub const PIN_PA09: u32 = 9;
pub const PIN_PA10: u32 = 10;
pub const PIN_PA11: u32 = 11;
pub const PIN_PA14: u32 = 14;
pub const PIN_PA15: u32 = 15;
pub const PIN_PA16: u32 = 16;
pub const PIN_PA17: u32 = 17;
pub const PIN_PA18: u32 = 18;
pub const PIN_PA19: u32 = 19;
pub const PIN_PA22: u32 = 22;
pub const PIN_PA23: u32 = 23;
pub const PIN_PA24: u32 = 24;
pub const PIN_PA25: u32 = 25;
pub const PIN_PA27: u32 = 27;
pub const PIN_PA28: u32 = 28;
pub const PIN_PA30: u32 = 30;
pub const PIN_PA31: u32 = 31;
pub const FLASH_PAGE_SIZE: u32 = 64;
pub const FLASH_NB_OF_PAGES: u32 = 4096;
pub const FLASH_USER_PAGE_SIZE: u32 = 64;
pub const EIC_EXTINT_NUM: u32 = 16;
pub const PORT_GROUPS: u32 = 1;
pub const ERR_NONE: u32 = 0;
pub const ERR_INVALID_DATA: i32 = -1;
pub const ERR_NO_CHANGE: i32 = -2;
pub const ERR_ABORTED: i32 = -3;
pub const ERR_BUSY: i32 = -4;
pub const ERR_SUSPEND: i32 = -5;
pub const ERR_IO: i32 = -6;
pub const ERR_REQ_FLUSHED: i32 = -7;
pub const ERR_TIMEOUT: i32 = -8;
pub const ERR_BAD_DATA: i32 = -9;
pub const ERR_NOT_FOUND: i32 = -10;
pub const ERR_UNSUPPORTED_DEV: i32 = -11;
pub const ERR_NO_MEMORY: i32 = -12;
pub const ERR_INVALID_ARG: i32 = -13;
pub const ERR_BAD_ADDRESS: i32 = -14;
pub const ERR_BAD_FORMAT: i32 = -15;
pub const ERR_BAD_FRQ: i32 = -16;
pub const ERR_DENIED: i32 = -17;
pub const ERR_ALREADY_INITIALIZED: i32 = -18;
pub const ERR_OVERFLOW: i32 = -19;
pub const ERR_NOT_INITIALIZED: i32 = -20;
pub const ERR_SAMPLERATE_UNAVAILABLE: i32 = -21;
pub const ERR_RESOLUTION_UNAVAILABLE: i32 = -22;
pub const ERR_BAUDRATE_UNAVAILABLE: i32 = -23;
pub const ERR_PACKET_COLLISION: i32 = -24;
pub const ERR_PROTOCOL: i32 = -25;
pub const ERR_PIN_MUX_INVALID: i32 = -26;
pub const ERR_UNSUPPORTED_OP: i32 = -27;
pub const ERR_NO_RESOURCE: i32 = -28;
pub const ERR_NOT_READY: i32 = -29;
pub const ERR_FAILURE: i32 = -30;
pub const ERR_WRONG_LENGTH: i32 = -31;
pub const GPIO_PIN_FUNCTION_OFF: u32 = 4294967295;
pub const GPIO_PIN_FUNCTION_A: u32 = 0;
pub const GPIO_PIN_FUNCTION_B: u32 = 1;
pub const GPIO_PIN_FUNCTION_C: u32 = 2;
pub const GPIO_PIN_FUNCTION_D: u32 = 3;
pub const GPIO_PIN_FUNCTION_E: u32 = 4;
pub const GPIO_PIN_FUNCTION_F: u32 = 5;
pub const GPIO_PIN_FUNCTION_G: u32 = 6;
pub const GPIO_PIN_FUNCTION_H: u32 = 7;
pub const USB_bmRequestType_Offset: u32 = 0;
pub const USB_bRequest_Offset: u32 = 1;
pub const USB_wValue_Offset: u32 = 2;
pub const USB_wIndex_Offset: u32 = 4;
pub const USB_wLength_Offset: u32 = 6;
pub const USB_REQ_TYPE_IN: u32 = 128;
pub const USB_EP_N_MASK: u32 = 15;
pub const USB_EP_DIR: u32 = 128;
pub const USB_EP_XTYPE_CTRL: u32 = 0;
pub const USB_EP_XTYPE_ISOCH: u32 = 1;
pub const USB_EP_XTYPE_BULK: u32 = 2;
pub const USB_EP_XTYPE_INTERRUPT: u32 = 3;
pub const USB_EP_XTYPE_MASK: u32 = 3;
pub const USB_OK: u32 = 0;
pub const USB_BUSY: u32 = 1;
pub const USB_HALTED: u32 = 2;
pub const USB_ERROR: u32 = 16;
pub const USB_ERR_DENIED: u32 = 17;
pub const USB_ERR_PARAM: u32 = 18;
pub const USB_ERR_FUNC: u32 = 19;
pub const USB_ERR_REDO: u32 = 20;
pub const USB_ERR_ALLOC_FAIL: u32 = 21;
pub const CONF_USB_N_0: u32 = 0;
pub const CONF_USB_N_1: u32 = 1;
pub const CONF_USB_N_2: u32 = 2;
pub const CONF_USB_N_3: u32 = 3;
pub const CONF_USB_N_4: u32 = 4;
pub const CONF_USB_N_5: u32 = 5;
pub const CONF_USB_N_6: u32 = 6;
pub const CONF_USB_N_7: u32 = 7;
pub const CONF_USB_N_8: u32 = 8;
pub const CONF_USB_N_9: u32 = 9;
pub const CONF_USB_N_10: u32 = 10;
pub const CONF_USB_N_11: u32 = 11;
pub const CONF_USB_N_12: u32 = 12;
pub const CONF_USB_N_13: u32 = 13;
pub const CONF_USB_N_14: u32 = 14;
pub const CONF_USB_N_15: u32 = 15;
pub const CONF_USB_D_EP_N_MAX: u32 = 7;
pub const CONF_USB_D_N_EP_MAX: u32 = 13;
pub const CONF_USB_D_NUM_EP_SP: u32 = 4;
pub const CONF_USB_D_MAX_EP_N: u32 = 2;
pub const CONF_USB_EP0_CACHE: u32 = 64;
pub const CONF_USB_EP1_CACHE: u32 = 64;
pub const CONF_USB_EP1_I_CACHE: u32 = 0;
pub const CONF_USB_EP2_CACHE: u32 = 64;
pub const CONF_USB_EP2_I_CACHE: u32 = 0;
pub const CONF_USB_EP3_CACHE: u32 = 64;
pub const CONF_USB_EP3_I_CACHE: u32 = 0;
pub const CONF_USB_EP4_CACHE: u32 = 64;
pub const CONF_USB_EP4_I_CACHE: u32 = 0;
pub const CONF_USB_EP5_CACHE: u32 = 64;
pub const CONF_USB_EP5_I_CACHE: u32 = 0;
pub const CONF_USB_EP6_CACHE: u32 = 64;
pub const CONF_USB_EP6_I_CACHE: u32 = 0;
pub const CONF_USB_EP7_CACHE: u32 = 64;
pub const CONF_USB_EP7_I_CACHE: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const USB_V2_0: u32 = 512;
pub const USB_V2_1: u32 = 513;
pub const USB_CLASS_NO: u32 = 0;
pub const USB_SUBCLASS_NO: u32 = 0;
pub const USB_PROTOCOL_NO: u32 = 0;
pub const USB_CLASS_IAD: u32 = 239;
pub const USB_SUBCLASS_IAD: u32 = 2;
pub const USB_PROTOCOL_IAD: u32 = 1;
pub const USB_REQT_DIR_OUT: u32 = 0;
pub const USB_REQT_DIR_H2D: u32 = 0;
pub const USB_REQT_DIR_IN: u32 = 128;
pub const USB_REQT_DIR_D2H: u32 = 128;
pub const USB_REQT_DIR_MASK: u32 = 128;
pub const USB_REQT_TYPE_STANDARD: u32 = 0;
pub const USB_REQT_TYPE_CLASS: u32 = 32;
pub const USB_REQT_TYPE_VENDOR: u32 = 64;
pub const USB_REQT_TYPE_MASK: u32 = 96;
pub const USB_REQT_RECIP_DEVICE: u32 = 0;
pub const USB_REQT_RECIP_INTERFACE: u32 = 1;
pub const USB_REQT_RECIP_ENDPOINT: u32 = 2;
pub const USB_REQT_RECIP_OTHER: u32 = 3;
pub const USB_REQT_RECIP_MASK: u32 = 31;
pub const USB_EP_ADDR_MASK: u32 = 15;
pub const USB_EP_DIR_IN: u32 = 128;
pub const USB_EP_DIR_OUT: u32 = 0;
pub const USB_DESC_LEN_MAX: u32 = 255;
pub const USB_CONFIG_ATTR_MUST_SET: u32 = 128;
pub const USB_CONFIG_ATTR_BUS_POWERED: u32 = 0;
pub const USB_CONFIG_ATTR_SELF_POWERED: u32 = 64;
pub const USB_CONFIG_ATTR_REMOTE_WAKEUP: u32 = 32;
pub const USB_DEV_DESC_LEN: u32 = 18;
pub const USB_CONFIG_DESC_LEN: u32 = 9;
pub const USB_IAD_DESC_LEN: u32 = 8;
pub const USB_IFACE_DESC_LEN: u32 = 9;
pub const USB_ENDP_DESC_LEN: u32 = 7;
pub const CONF_USBD_HS_SP: u32 = 0;
pub const CONF_USB_CDCD_ACM_STR_EN: u32 = 0;
pub const CONF_USB_CDCD_ACM_LANGID: &'static [u8; 7usize] = b"0x0409\0";
pub const CONF_USB_CDCD_ACM_BCDUSB: u32 = 512;
pub const CONF_USB_CDCD_ACM_BMAXPKSZ0: u32 = 64;
pub const CONF_USB_CDCD_ACM_IDVENDER: u32 = 1003;
pub const CONF_USB_CDCD_ACM_IDPRODUCT: u32 = 9220;
pub const CONF_USB_CDCD_ACM_BCDDEVICE: u32 = 256;
pub const CONF_USB_CDCD_ACM_IMANUFACT_EN: u32 = 0;
pub const CONF_USB_CDCD_ACM_IMANUFACT: u32 = 0;
pub const CONF_USB_CDCD_ACM_IMANUFACT_STR: &'static [u8; 6usize] = b"Atmel\0";
pub const CONF_USB_CDCD_ACM_IPRODUCT_EN: u32 = 0;
pub const CONF_USB_CDCD_ACM_IPRODUCT: u32 = 0;
pub const CONF_USB_CDCD_ACM_IPRODUCT_STR: &'static [u8; 27usize] = b"CDC ACM Serial Bridge Demo\0";
pub const CONF_USB_CDCD_ACM_ISERIALNUM_EN: u32 = 0;
pub const CONF_USB_CDCD_ACM_ISERIALNUM: u32 = 0;
pub const CONF_USB_CDCD_ACM_ISERIALNUM_STR: &'static [u8; 16usize] = b"123456789ABCDEF\0";
pub const CONF_USB_CDCD_ACM_BNUMCONFIG: u32 = 1;
pub const CONF_USB_CDCD_ACM_BCONFIGVAL: u32 = 1;
pub const CONF_USB_CDCD_ACM_ICONFIG_EN: u32 = 0;
pub const CONF_USB_CDCD_ACM_ICONFIG: u32 = 0;
pub const CONF_USB_CDCD_ACM_ICONFIG_STR: &'static [u8; 1usize] = b"\0";
pub const CONF_USB_CDCD_ACM_BMATTRI: u32 = 128;
pub const CONF_USB_CDCD_ACM_BMAXPOWER: u32 = 50;
pub const CONF_USB_CDCD_ACM_COMM_BIFCNUM: u32 = 0;
pub const CONF_USB_CDCD_ACM_COMM_BALTSET: u32 = 0;
pub const CONF_USB_CDCD_ACM_COMM_IIFC: u32 = 0;
pub const CONF_USB_CDCD_ACM_COMM_INT_EPADDR: u32 = 130;
pub const CONF_USB_CDCD_ACM_COMM_INT_MAXPKSZ: u32 = 64;
pub const CONF_USB_CDCD_ACM_COMM_INT_INTERVAL: u32 = 10;
pub const CONF_USB_CDCD_ACM_DATA_BIFCNUM: u32 = 1;
pub const CONF_USB_CDCD_ACM_DATA_BALTSET: u32 = 0;
pub const CONF_USB_CDCD_ACM_DATA_IIFC: u32 = 0;
pub const CONF_USB_CDCD_ACM_DATA_BULKIN_EPADDR: u32 = 129;
pub const CONF_USB_CDCD_ACM_DATA_BULKIN_MAXPKSZ: u32 = 64;
pub const CONF_USB_CDCD_ACM_DATA_BULKIN_MAXPKSZ_HS: u32 = 512;
pub const CONF_USB_CDCD_ACM_DATA_BULKOUT_EPADDR: u32 = 1;
pub const CONF_USB_CDCD_ACM_DATA_BULKOUT_MAXPKSZ: u32 = 64;
pub const CONF_USB_CDCD_ACM_DATA_BULKOUT_MAXPKSZ_HS: u32 = 512;
pub const CDC_CLASS_DEVICE: u32 = 2;
pub const CDC_CLASS_COMM: u32 = 2;
pub const CDC_CLASS_DATA: u32 = 10;
pub const CDC_SUBCLASS_DLCM: u32 = 1;
pub const CDC_SUBCLASS_ACM: u32 = 2;
pub const CDC_SUBCLASS_TCM: u32 = 3;
pub const CDC_SUBCLASS_MCCM: u32 = 4;
pub const CDC_SUBCLASS_CCM: u32 = 5;
pub const CDC_SUBCLASS_ETH: u32 = 6;
pub const CDC_SUBCLASS_ATM: u32 = 7;
pub const CDC_PROTOCOL_V25TER: u32 = 1;
pub const CDC_PROTOCOL_I430: u32 = 48;
pub const CDC_PROTOCOL_HDLC: u32 = 49;
pub const CDC_PROTOCOL_TRANS: u32 = 50;
pub const CDC_PROTOCOL_Q921M: u32 = 80;
pub const CDC_PROTOCOL_Q921: u32 = 81;
pub const CDC_PROTOCOL_Q921TM: u32 = 82;
pub const CDC_PROTOCOL_V42BIS: u32 = 144;
pub const CDC_PROTOCOL_Q931: u32 = 145;
pub const CDC_PROTOCOL_V120: u32 = 146;
pub const CDC_PROTOCOL_CAPI20: u32 = 147;
pub const CDC_PROTOCOL_HOST: u32 = 253;
pub const CDC_PROTOCOL_PUFD: u32 = 254;
pub const CDC_CS_INTERFACE: u32 = 36;
pub const CDC_CS_ENDPOINT: u32 = 37;
pub const CDC_SCS_HEADER: u32 = 0;
pub const CDC_SCS_CALL_MGMT: u32 = 1;
pub const CDC_SCS_ACM: u32 = 2;
pub const CDC_SCS_UNION: u32 = 6;
pub const USB_REQ_CDC_SEND_ENCAPSULATED_COMMAND: u32 = 0;
pub const USB_REQ_CDC_GET_ENCAPSULATED_RESPONSE: u32 = 1;
pub const USB_REQ_CDC_SET_COMM_FEATURE: u32 = 2;
pub const USB_REQ_CDC_GET_COMM_FEATURE: u32 = 3;
pub const USB_REQ_CDC_CLEAR_COMM_FEATURE: u32 = 4;
pub const USB_REQ_CDC_SET_AUX_LINE_STATE: u32 = 16;
pub const USB_REQ_CDC_SET_HOOK_STATE: u32 = 17;
pub const USB_REQ_CDC_PULSE_SETUP: u32 = 18;
pub const USB_REQ_CDC_SEND_PULSE: u32 = 19;
pub const USB_REQ_CDC_SET_PULSE_TIME: u32 = 20;
pub const USB_REQ_CDC_RING_AUX_JACK: u32 = 21;
pub const USB_REQ_CDC_SET_LINE_CODING: u32 = 32;
pub const USB_REQ_CDC_GET_LINE_CODING: u32 = 33;
pub const USB_REQ_CDC_SET_CONTROL_LINE_STATE: u32 = 34;
pub const USB_REQ_CDC_SEND_BREAK: u32 = 35;
pub const USB_REQ_CDC_SET_RINGER_PARMS: u32 = 48;
pub const USB_REQ_CDC_GET_RINGER_PARMS: u32 = 49;
pub const USB_REQ_CDC_SET_OPERATION_PARMS: u32 = 50;
pub const USB_REQ_CDC_GET_OPERATION_PARMS: u32 = 51;
pub const USB_REQ_CDC_SET_LINE_PARMS: u32 = 52;
pub const USB_REQ_CDC_GET_LINE_PARMS: u32 = 53;
pub const USB_REQ_CDC_DIAL_DIGITS: u32 = 54;
pub const USB_REQ_CDC_SET_UNIT_PARAMETER: u32 = 55;
pub const USB_REQ_CDC_GET_UNIT_PARAMETER: u32 = 56;
pub const USB_REQ_CDC_CLEAR_UNIT_PARAMETER: u32 = 57;
pub const USB_REQ_CDC_GET_PROFILE: u32 = 58;
pub const USB_REQ_CDC_SET_ETHERNET_MULTICAST_FILTERS: u32 = 64;
pub const USB_REQ_CDC_SET_ETHERNET_POWER_MANAGEMENT_PATTERNFILTER: u32 = 65;
pub const USB_REQ_CDC_GET_ETHERNET_POWER_MANAGEMENT_PATTERNFILTER: u32 = 66;
pub const USB_REQ_CDC_SET_ETHERNET_PACKET_FILTER: u32 = 67;
pub const USB_REQ_CDC_GET_ETHERNET_STATISTIC: u32 = 68;
pub const USB_REQ_CDC_SET_ATM_DATA_FORMAT: u32 = 80;
pub const USB_REQ_CDC_GET_ATM_DEVICE_STATISTICS: u32 = 81;
pub const USB_REQ_CDC_SET_ATM_DEFAULT_VC: u32 = 82;
pub const USB_REQ_CDC_GET_ATM_VC_STATISTICS: u32 = 83;
pub const USB_REQ_CDC_NOTIFY_RING_DETECT: u32 = 9;
pub const USB_REQ_CDC_NOTIFY_SERIAL_STATE: u32 = 32;
pub const USB_REQ_CDC_NOTIFY_CALL_STATE_CHANGE: u32 = 40;
pub const USB_REQ_CDC_NOTIFY_LINE_STATE_CHANGE: u32 = 41;
pub const USB_CDC_HDR_DESC_LEN: u32 = 5;
pub const USB_CDC_CALL_MGMT_DESC_LEN: u32 = 5;
pub const USB_CDC_ACM_DESC_LEN: u32 = 4;
pub const USB_CDC_UNION_DESC_LEN: u32 = 5;
pub const CDC_CALL_MGMT_SUPPORTED: u32 = 1;
pub const CDC_CALL_MGMT_OVER_DCI: u32 = 2;
pub const CDC_ACM_SUPPORT_FEATURE_REQUESTS: u32 = 1;
pub const CDC_ACM_SUPPORT_LINE_REQUESTS: u32 = 2;
pub const CDC_ACM_SUPPORT_SENDBREAK_REQUESTS: u32 = 4;
pub const CDC_ACM_SUPPORT_NOTIFY_REQUESTS: u32 = 8;
pub const CDC_CTRL_SIGNAL_ACTIVATE_CARRIER: u32 = 2;
pub const CDC_CTRL_SIGNAL_DTE_PRESENT: u32 = 1;
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
pub type RoReg = u32;
pub type RoReg16 = u16;
pub type RoReg8 = u8;
pub type WoReg = u32;
pub type WoReg16 = u16;
pub type WoReg8 = u8;
pub type RwReg = u32;
pub type RwReg16 = u16;
pub type RwReg8 = u8;
#[doc = "<  2 Non Maskable Interrupt"]
pub const IRQn_NonMaskableInt_IRQn: IRQn = -14;
#[doc = "<  3 Hard Fault Interrupt"]
pub const IRQn_HardFault_IRQn: IRQn = -13;
#[doc = "< 11 SV Call Interrupt"]
pub const IRQn_SVCall_IRQn: IRQn = -5;
#[doc = "< 14 Pend SV Interrupt"]
pub const IRQn_PendSV_IRQn: IRQn = -2;
#[doc = "< 15 System Tick Interrupt"]
pub const IRQn_SysTick_IRQn: IRQn = -1;
#[doc = "<  0 SAMD21E18A Power Manager (PM)"]
pub const IRQn_PM_IRQn: IRQn = 0;
#[doc = "<  1 SAMD21E18A System Control (SYSCTRL)"]
pub const IRQn_SYSCTRL_IRQn: IRQn = 1;
#[doc = "<  2 SAMD21E18A Watchdog Timer (WDT)"]
pub const IRQn_WDT_IRQn: IRQn = 2;
#[doc = "<  3 SAMD21E18A Real-Time Counter (RTC)"]
pub const IRQn_RTC_IRQn: IRQn = 3;
#[doc = "<  4 SAMD21E18A External Interrupt Controller (EIC)"]
pub const IRQn_EIC_IRQn: IRQn = 4;
#[doc = "<  5 SAMD21E18A Non-Volatile Memory Controller (NVMCTRL)"]
pub const IRQn_NVMCTRL_IRQn: IRQn = 5;
#[doc = "<  6 SAMD21E18A Direct Memory Access Controller (DMAC)"]
pub const IRQn_DMAC_IRQn: IRQn = 6;
#[doc = "<  7 SAMD21E18A Universal Serial Bus (USB)"]
pub const IRQn_USB_IRQn: IRQn = 7;
#[doc = "<  8 SAMD21E18A Event System Interface (EVSYS)"]
pub const IRQn_EVSYS_IRQn: IRQn = 8;
#[doc = "<  9 SAMD21E18A Serial Communication Interface 0 (SERCOM0)"]
pub const IRQn_SERCOM0_IRQn: IRQn = 9;
#[doc = "< 10 SAMD21E18A Serial Communication Interface 1 (SERCOM1)"]
pub const IRQn_SERCOM1_IRQn: IRQn = 10;
#[doc = "< 11 SAMD21E18A Serial Communication Interface 2 (SERCOM2)"]
pub const IRQn_SERCOM2_IRQn: IRQn = 11;
#[doc = "< 12 SAMD21E18A Serial Communication Interface 3 (SERCOM3)"]
pub const IRQn_SERCOM3_IRQn: IRQn = 12;
#[doc = "< 15 SAMD21E18A Timer Counter Control 0 (TCC0)"]
pub const IRQn_TCC0_IRQn: IRQn = 15;
#[doc = "< 16 SAMD21E18A Timer Counter Control 1 (TCC1)"]
pub const IRQn_TCC1_IRQn: IRQn = 16;
#[doc = "< 17 SAMD21E18A Timer Counter Control 2 (TCC2)"]
pub const IRQn_TCC2_IRQn: IRQn = 17;
#[doc = "< 18 SAMD21E18A Basic Timer Counter 3 (TC3)"]
pub const IRQn_TC3_IRQn: IRQn = 18;
#[doc = "< 19 SAMD21E18A Basic Timer Counter 4 (TC4)"]
pub const IRQn_TC4_IRQn: IRQn = 19;
#[doc = "< 20 SAMD21E18A Basic Timer Counter 5 (TC5)"]
pub const IRQn_TC5_IRQn: IRQn = 20;
#[doc = "< 23 SAMD21E18A Analog Digital Converter (ADC)"]
pub const IRQn_ADC_IRQn: IRQn = 23;
#[doc = "< 24 SAMD21E18A Analog Comparators (AC)"]
pub const IRQn_AC_IRQn: IRQn = 24;
#[doc = "< 25 SAMD21E18A Digital Analog Converter (DAC)"]
pub const IRQn_DAC_IRQn: IRQn = 25;
#[doc = "< 26 SAMD21E18A Peripheral Touch Controller (PTC)"]
pub const IRQn_PTC_IRQn: IRQn = 26;
#[doc = "< 27 SAMD21E18A Inter-IC Sound Interface (I2S)"]
pub const IRQn_I2S_IRQn: IRQn = 27;
#[doc = "< Number of peripheral IDs"]
pub const IRQn_PERIPH_COUNT_IRQn: IRQn = 28;
#[doc = " Interrupt Number Definition"]
pub type IRQn = i32;
pub use self::IRQn as IRQn_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DeviceVectors {
    pub pvStack: *mut cty::c_void,
    pub pfnReset_Handler: *mut cty::c_void,
    pub pfnNonMaskableInt_Handler: *mut cty::c_void,
    pub pfnHardFault_Handler: *mut cty::c_void,
    pub pvReservedM12: *mut cty::c_void,
    pub pvReservedM11: *mut cty::c_void,
    pub pvReservedM10: *mut cty::c_void,
    pub pvReservedM9: *mut cty::c_void,
    pub pvReservedM8: *mut cty::c_void,
    pub pvReservedM7: *mut cty::c_void,
    pub pvReservedM6: *mut cty::c_void,
    pub pfnSVCall_Handler: *mut cty::c_void,
    pub pvReservedM4: *mut cty::c_void,
    pub pvReservedM3: *mut cty::c_void,
    pub pfnPendSV_Handler: *mut cty::c_void,
    pub pfnSysTick_Handler: *mut cty::c_void,
    pub pfnPM_Handler: *mut cty::c_void,
    pub pfnSYSCTRL_Handler: *mut cty::c_void,
    pub pfnWDT_Handler: *mut cty::c_void,
    pub pfnRTC_Handler: *mut cty::c_void,
    pub pfnEIC_Handler: *mut cty::c_void,
    pub pfnNVMCTRL_Handler: *mut cty::c_void,
    pub pfnDMAC_Handler: *mut cty::c_void,
    pub pfnUSB_Handler: *mut cty::c_void,
    pub pfnEVSYS_Handler: *mut cty::c_void,
    pub pfnSERCOM0_Handler: *mut cty::c_void,
    pub pfnSERCOM1_Handler: *mut cty::c_void,
    pub pfnSERCOM2_Handler: *mut cty::c_void,
    pub pfnSERCOM3_Handler: *mut cty::c_void,
    pub pvReserved13: *mut cty::c_void,
    pub pvReserved14: *mut cty::c_void,
    pub pfnTCC0_Handler: *mut cty::c_void,
    pub pfnTCC1_Handler: *mut cty::c_void,
    pub pfnTCC2_Handler: *mut cty::c_void,
    pub pfnTC3_Handler: *mut cty::c_void,
    pub pfnTC4_Handler: *mut cty::c_void,
    pub pfnTC5_Handler: *mut cty::c_void,
    pub pvReserved21: *mut cty::c_void,
    pub pvReserved22: *mut cty::c_void,
    pub pfnADC_Handler: *mut cty::c_void,
    pub pfnAC_Handler: *mut cty::c_void,
    pub pfnDAC_Handler: *mut cty::c_void,
    pub pfnPTC_Handler: *mut cty::c_void,
    pub pfnI2S_Handler: *mut cty::c_void,
    pub pvReserved28: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout__DeviceVectors() {
    assert_eq!(
        ::core::mem::size_of::<_DeviceVectors>(),
        180usize,
        concat!("Size of: ", stringify!(_DeviceVectors))
    );
    assert_eq!(
        ::core::mem::align_of::<_DeviceVectors>(),
        4usize,
        concat!("Alignment of ", stringify!(_DeviceVectors))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvStack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvStack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnReset_Handler as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnReset_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnNonMaskableInt_Handler as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnNonMaskableInt_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnHardFault_Handler as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnHardFault_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM12 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM11 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM10 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM9 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM8 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM7 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM6 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSVCall_Handler as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSVCall_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM4 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReservedM3 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnPendSV_Handler as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnPendSV_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSysTick_Handler as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSysTick_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnPM_Handler as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnPM_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSYSCTRL_Handler as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSYSCTRL_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnWDT_Handler as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnWDT_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnRTC_Handler as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnRTC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnEIC_Handler as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnEIC_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnNVMCTRL_Handler as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnNVMCTRL_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnDMAC_Handler as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnDMAC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnUSB_Handler as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnUSB_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnEVSYS_Handler as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnEVSYS_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSERCOM0_Handler as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM0_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSERCOM1_Handler as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM1_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSERCOM2_Handler as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM2_Handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_DeviceVectors>())).pfnSERCOM3_Handler as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM3_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReserved13 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReserved14 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTCC0_Handler as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTCC0_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTCC1_Handler as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTCC1_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTCC2_Handler as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTCC2_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTC3_Handler as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC3_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTC4_Handler as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC4_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnTC5_Handler as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC5_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReserved21 as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved21)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReserved22 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved22)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnADC_Handler as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnADC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnAC_Handler as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnAC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnDAC_Handler as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnDAC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnPTC_Handler as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnPTC_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pfnI2S_Handler as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnI2S_Handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_DeviceVectors>())).pvReserved28 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved28)
        )
    );
}
pub type DeviceVectors = _DeviceVectors;
extern "C" {
    pub fn Reset_Handler();
}
extern "C" {
    pub fn NonMaskableInt_Handler();
}
extern "C" {
    pub fn HardFault_Handler();
}
extern "C" {
    pub fn SVCall_Handler();
}
extern "C" {
    pub fn PendSV_Handler();
}
extern "C" {
    pub fn SysTick_Handler();
}
extern "C" {
    pub fn PM_Handler();
}
extern "C" {
    pub fn SYSCTRL_Handler();
}
extern "C" {
    pub fn WDT_Handler();
}
extern "C" {
    pub fn RTC_Handler();
}
extern "C" {
    pub fn EIC_Handler();
}
extern "C" {
    pub fn NVMCTRL_Handler();
}
extern "C" {
    pub fn DMAC_Handler();
}
extern "C" {
    pub fn USB_Handler();
}
extern "C" {
    pub fn EVSYS_Handler();
}
extern "C" {
    pub fn SERCOM0_Handler();
}
extern "C" {
    pub fn SERCOM1_Handler();
}
extern "C" {
    pub fn SERCOM2_Handler();
}
extern "C" {
    pub fn SERCOM3_Handler();
}
extern "C" {
    pub fn TCC0_Handler();
}
extern "C" {
    pub fn TCC1_Handler();
}
extern "C" {
    pub fn TCC2_Handler();
}
extern "C" {
    pub fn TC3_Handler();
}
extern "C" {
    pub fn TC4_Handler();
}
extern "C" {
    pub fn TC5_Handler();
}
extern "C" {
    pub fn ADC_Handler();
}
extern "C" {
    pub fn AC_Handler();
}
extern "C" {
    pub fn DAC_Handler();
}
extern "C" {
    pub fn PTC_Handler();
}
extern "C" {
    pub fn I2S_Handler();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32 {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT16_WRITE {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_WRITE() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_WRITE>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT16_WRITE>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT16_READ {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_READ() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_READ>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT16_READ>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32_WRITE {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_WRITE() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_WRITE>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32_WRITE>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32_READ {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_READ() {
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_READ>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<T_UINT32_READ>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    pub b: APSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    pub b: IPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    pub b: xPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        T: u32,
        _reserved1: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    pub b: CONTROL_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        _reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVIC_Type {
    pub ISER: [u32; 1usize],
    pub RESERVED0: [u32; 31usize],
    pub ICER: [u32; 1usize],
    pub RSERVED1: [u32; 31usize],
    pub ISPR: [u32; 1usize],
    pub RESERVED2: [u32; 31usize],
    pub ICPR: [u32; 1usize],
    pub RESERVED3: [u32; 31usize],
    pub RESERVED4: [u32; 64usize],
    pub IP: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        800usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICER as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RSERVED1 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RSERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISPR as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED2 as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICPR as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED3 as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED4 as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).IP as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCB_Type {
    pub CPUID: u32,
    pub ICSR: u32,
    pub VTOR: u32,
    pub AIRCR: u32,
    pub SCR: u32,
    pub CCR: u32,
    pub RESERVED1: u32,
    pub SHP: [u32; 2usize],
    pub SHCSR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        40usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CPUID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ICSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).VTOR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).AIRCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SCR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHP as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHCSR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysTick_Type {
    pub CTRL: u32,
    pub LOAD: u32,
    pub VAL: u32,
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).LOAD as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).VAL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CALIB as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
extern "C" {
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn SystemInit();
}
extern "C" {
    pub fn SystemCoreClockUpdate();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLA_Type__bindgen_ty_1))
    );
}
impl AC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMUX(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LPMUX(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
        LPMUX: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LPMUX: u8 = unsafe { ::core::mem::transmute(LPMUX) };
            LPMUX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_CTRLB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type__bindgen_ty_1))
    );
}
impl AC_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn START0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn START1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(START0: u8, START1: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let START0: u8 = unsafe { ::core::mem::transmute(START0) };
            START0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let START1: u8 = unsafe { ::core::mem::transmute(START1) };
            START1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type__bindgen_ty_2))
    );
}
impl AC_CTRLB_Type__bindgen_ty_2 {
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(START: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_CTRLB_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct AC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl AC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMPEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMPEO0: u16,
        COMPEO1: u16,
        WINEO0: u16,
        COMPEI0: u16,
        COMPEI1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMPEO0: u16 = unsafe { ::core::mem::transmute(COMPEO0) };
            COMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMPEO1: u16 = unsafe { ::core::mem::transmute(COMPEO1) };
            COMPEO1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WINEO0: u16 = unsafe { ::core::mem::transmute(WINEO0) };
            WINEO0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let COMPEI0: u16 = unsafe { ::core::mem::transmute(COMPEI0) };
            COMPEI0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let COMPEI1: u16 = unsafe { ::core::mem::transmute(COMPEI1) };
            COMPEI1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct AC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl AC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMPEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WINEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMPEO: u16,
        WINEO: u16,
        COMPEI: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMPEO: u16 = unsafe { ::core::mem::transmute(COMPEO) };
            COMPEO as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WINEO: u16 = unsafe { ::core::mem::transmute(WINEO) };
            WINEO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let COMPEI: u16 = unsafe { ::core::mem::transmute(COMPEI) };
            COMPEI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl AC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMP0: u8,
        COMP1: u8,
        WIN0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl AC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type__bindgen_ty_1))
    );
}
impl AC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMP0: u8,
        COMP1: u8,
        WIN0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type__bindgen_ty_2))
    );
}
impl AC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl AC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMP0: u8,
        COMP1: u8,
        WIN0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl AC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_STATUSA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_STATUSA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_STATUSA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type__bindgen_ty_1))
    );
}
impl AC_STATUSA_Type__bindgen_ty_1 {
    #[inline]
    pub fn STATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATE1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WSTATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WSTATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STATE0: u8,
        STATE1: u8,
        WSTATE0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STATE0: u8 = unsafe { ::core::mem::transmute(STATE0) };
            STATE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let STATE1: u8 = unsafe { ::core::mem::transmute(STATE1) };
            STATE1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let WSTATE0: u8 = unsafe { ::core::mem::transmute(WSTATE0) };
            WSTATE0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSA_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type__bindgen_ty_2))
    );
}
impl AC_STATUSA_Type__bindgen_ty_2 {
    #[inline]
    pub fn STATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let STATE: u8 = unsafe { ::core::mem::transmute(STATE) };
            STATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSA_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_STATUSB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_STATUSB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_STATUSB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type__bindgen_ty_1))
    );
}
impl AC_STATUSB_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn READY1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        READY0: u8,
        READY1: u8,
        SYNCBUSY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY0: u8 = unsafe { ::core::mem::transmute(READY0) };
            READY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let READY1: u8 = unsafe { ::core::mem::transmute(READY1) };
            READY1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type__bindgen_ty_2))
    );
}
impl AC_STATUSB_Type__bindgen_ty_2 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSB_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_STATUSC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_STATUSC_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_STATUSC_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSC_Type__bindgen_ty_1))
    );
}
impl AC_STATUSC_Type__bindgen_ty_1 {
    #[inline]
    pub fn STATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATE1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WSTATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WSTATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STATE0: u8,
        STATE1: u8,
        WSTATE0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STATE0: u8 = unsafe { ::core::mem::transmute(STATE0) };
            STATE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let STATE1: u8 = unsafe { ::core::mem::transmute(STATE1) };
            STATE1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let WSTATE0: u8 = unsafe { ::core::mem::transmute(WSTATE0) };
            WSTATE0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSC_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_STATUSC_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSC_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSC_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSC_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSC_Type__bindgen_ty_2))
    );
}
impl AC_STATUSC_Type__bindgen_ty_2 {
    #[inline]
    pub fn STATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let STATE: u8 = unsafe { ::core::mem::transmute(STATE) };
            STATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_STATUSC_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSC_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSC_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_STATUSC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_WINCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_WINCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_WINCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_WINCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_WINCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_WINCTRL_Type__bindgen_ty_1))
    );
}
impl AC_WINCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn WEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINTSEL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WINTSEL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WEN0: u8, WINTSEL0: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WEN0: u8 = unsafe { ::core::mem::transmute(WEN0) };
            WEN0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let WINTSEL0: u8 = unsafe { ::core::mem::transmute(WINTSEL0) };
            WINTSEL0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_WINCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_WINCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_WINCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_WINCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_WINCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_WINCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_WINCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_WINCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_WINCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_COMPCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_COMPCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct AC_COMPCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_COMPCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_COMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(AC_COMPCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_COMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_COMPCTRL_Type__bindgen_ty_1))
    );
}
impl AC_COMPCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SINGLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SINGLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn INTSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_INTSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXNEG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MUXNEG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXPOS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_MUXPOS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_OUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn HYST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HYST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FLEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FLEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        SINGLE: u32,
        SPEED: u32,
        INTSEL: u32,
        MUXNEG: u32,
        MUXPOS: u32,
        SWAP: u32,
        OUT: u32,
        HYST: u32,
        FLEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SINGLE: u32 = unsafe { ::core::mem::transmute(SINGLE) };
            SINGLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let INTSEL: u32 = unsafe { ::core::mem::transmute(INTSEL) };
            INTSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let MUXNEG: u32 = unsafe { ::core::mem::transmute(MUXNEG) };
            MUXNEG as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let MUXPOS: u32 = unsafe { ::core::mem::transmute(MUXPOS) };
            MUXPOS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SWAP: u32 = unsafe { ::core::mem::transmute(SWAP) };
            SWAP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let OUT: u32 = unsafe { ::core::mem::transmute(OUT) };
            OUT as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let HYST: u32 = unsafe { ::core::mem::transmute(HYST) };
            HYST as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let FLEN: u32 = unsafe { ::core::mem::transmute(FLEN) };
            FLEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_COMPCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_COMPCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AC_COMPCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_COMPCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_COMPCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_COMPCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_COMPCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_COMPCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_COMPCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_SCALER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_SCALER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_SCALER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_AC_SCALER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_SCALER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_SCALER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SCALER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_SCALER_Type__bindgen_ty_1))
    );
}
impl AC_SCALER_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALUE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_VALUE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VALUE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let VALUE: u8 = unsafe { ::core::mem::transmute(VALUE) };
            VALUE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_SCALER_Type() {
    assert_eq!(
        ::core::mem::size_of::<AC_SCALER_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_SCALER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SCALER_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_SCALER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_SCALER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SCALER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AC_SCALER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SCALER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Ac {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: AC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 ( /W  8) Control B"]
    pub CTRLB: AC_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Event Control"]
    pub EVCTRL: AC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: AC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: AC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: AC_INTFLAG_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x08 (R/   8) Status A"]
    pub STATUSA: AC_STATUSA_Type,
    #[doc = "< \\brief Offset: 0x09 (R/   8) Status B"]
    pub STATUSB: AC_STATUSB_Type,
    #[doc = "< \\brief Offset: 0x0A (R/   8) Status C"]
    pub STATUSC: AC_STATUSC_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Window Control"]
    pub WINCTRL: AC_WINCTRL_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Comparator Control n"]
    pub COMPCTRL: [AC_COMPCTRL_Type; 2usize],
    pub Reserved4: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x20 (R/W  8) Scaler n"]
    pub SCALER: [AC_SCALER_Type; 2usize],
}
#[test]
fn bindgen_test_layout_Ac() {
    assert_eq!(
        ::core::mem::size_of::<Ac>(),
        36usize,
        concat!("Size of: ", stringify!(Ac))
    );
    assert_eq!(
        ::core::mem::align_of::<Ac>(),
        4usize,
        concat!("Alignment of ", stringify!(Ac))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).CTRLA as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ac), "::", stringify!(CTRLA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).CTRLB as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(Ac), "::", stringify!(CTRLB))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).EVCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).INTENCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).INTENSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).INTFLAG as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).Reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).STATUSA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(STATUSA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).STATUSB as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(STATUSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).STATUSC as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(STATUSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).Reserved2 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).WINCTRL as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(WINCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).Reserved3 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).COMPCTRL as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(COMPCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).Reserved4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Ac>())).SCALER as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(SCALER)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLA_Type__bindgen_ty_1))
    );
}
impl ADC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_REFCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_REFCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_REFCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_REFCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_REFCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_REFCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_REFCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_REFCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_REFCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn REFSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_REFSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn REFCOMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_REFCOMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(REFSEL: u8, REFCOMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let REFSEL: u8 = unsafe { ::core::mem::transmute(REFSEL) };
            REFSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let REFCOMP: u8 = unsafe { ::core::mem::transmute(REFCOMP) };
            REFCOMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_REFCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_REFCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_REFCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_REFCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_REFCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_REFCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_REFCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_REFCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_REFCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_AVGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_AVGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_AVGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_AVGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_AVGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_AVGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AVGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_AVGCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_AVGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLENUM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SAMPLENUM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ADJRES(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ADJRES(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLENUM: u8, ADJRES: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SAMPLENUM: u8 = unsafe { ::core::mem::transmute(SAMPLENUM) };
            SAMPLENUM as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let ADJRES: u8 = unsafe { ::core::mem::transmute(ADJRES) };
            ADJRES as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_AVGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_AVGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_AVGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AVGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_AVGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_AVGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AVGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_AVGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AVGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SAMPCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SAMPCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SAMPCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_SAMPCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SAMPCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SAMPCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SAMPCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SAMPCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_SAMPCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_SAMPLEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SAMPLEN: u8 = unsafe { ::core::mem::transmute(SAMPLEN) };
            SAMPLEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SAMPCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SAMPCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SAMPCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SAMPCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SAMPCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_SAMPCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SAMPCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_SAMPCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SAMPCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CTRLB_Type__bindgen_ty_1))
    );
}
impl ADC_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIFFMODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DIFFMODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LEFTADJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LEFTADJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREERUN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FREERUN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CORREN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CORREN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RESSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIFFMODE: u16,
        LEFTADJ: u16,
        FREERUN: u16,
        CORREN: u16,
        RESSEL: u16,
        PRESCALER: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIFFMODE: u16 = unsafe { ::core::mem::transmute(DIFFMODE) };
            DIFFMODE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LEFTADJ: u16 = unsafe { ::core::mem::transmute(LEFTADJ) };
            LEFTADJ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FREERUN: u16 = unsafe { ::core::mem::transmute(FREERUN) };
            FREERUN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CORREN: u16 = unsafe { ::core::mem::transmute(CORREN) };
            CORREN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RESSEL: u16 = unsafe { ::core::mem::transmute(RESSEL) };
            RESSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_WINCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_WINCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_WINCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_WINCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_WINCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_WINCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_WINCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn WINMODE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_WINMODE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WINMODE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let WINMODE: u8 = unsafe { ::core::mem::transmute(WINMODE) };
            WINMODE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_WINCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_WINCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_WINCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SWTRIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SWTRIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SWTRIG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_SWTRIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SWTRIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SWTRIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SWTRIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SWTRIG_Type__bindgen_ty_1))
    );
}
impl ADC_SWTRIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLUSH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FLUSH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FLUSH: u8, START: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FLUSH: u8 = unsafe { ::core::mem::transmute(FLUSH) };
            FLUSH as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SWTRIG_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SWTRIG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SWTRIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SWTRIG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SWTRIG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_SWTRIG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SWTRIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_SWTRIG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SWTRIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INPUTCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INPUTCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INPUTCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_INPUTCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INPUTCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ADC_INPUTCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INPUTCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ADC_INPUTCTRL_Type__bindgen_ty_1)
        )
    );
}
impl ADC_INPUTCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn MUXPOS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MUXPOS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXNEG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MUXNEG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn INPUTSCAN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_INPUTSCAN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn INPUTOFFSET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_INPUTOFFSET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn GAIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GAIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MUXPOS: u32,
        MUXNEG: u32,
        INPUTSCAN: u32,
        INPUTOFFSET: u32,
        GAIN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MUXPOS: u32 = unsafe { ::core::mem::transmute(MUXPOS) };
            MUXPOS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let MUXNEG: u32 = unsafe { ::core::mem::transmute(MUXNEG) };
            MUXNEG as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let INPUTSCAN: u32 = unsafe { ::core::mem::transmute(INPUTSCAN) };
            INPUTSCAN as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let INPUTOFFSET: u32 = unsafe { ::core::mem::transmute(INPUTOFFSET) };
            INPUTOFFSET as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let GAIN: u32 = unsafe { ::core::mem::transmute(GAIN) };
            GAIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INPUTCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INPUTCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(ADC_INPUTCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INPUTCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_INPUTCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INPUTCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INPUTCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INPUTCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INPUTCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn STARTEI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STARTEI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCEI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCEI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESRDYEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDYEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMONEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMONEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STARTEI: u8,
        SYNCEI: u8,
        RESRDYEO: u8,
        WINMONEO: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STARTEI: u8 = unsafe { ::core::mem::transmute(STARTEI) };
            STARTEI as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SYNCEI: u8 = unsafe { ::core::mem::transmute(SYNCEI) };
            SYNCEI as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RESRDYEO: u8 = unsafe { ::core::mem::transmute(RESRDYEO) };
            RESRDYEO as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WINMONEO: u8 = unsafe { ::core::mem::transmute(WINMONEO) };
            WINMONEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl ADC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENSET_Type__bindgen_ty_1))
    );
}
impl ADC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl ADC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_STATUS_Type__bindgen_ty_1))
    );
}
impl ADC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_RESULT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_RESULT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_RESULT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ADC_RESULT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_RESULT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_RESULT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_RESULT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_RESULT_Type__bindgen_ty_1))
    );
}
impl ADC_RESULT_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESULT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_RESULT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RESULT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let RESULT: u16 = unsafe { ::core::mem::transmute(RESULT) };
            RESULT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_RESULT_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_RESULT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_RESULT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_RESULT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_RESULT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_RESULT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_RESULT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_RESULT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_RESULT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_WINLT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_WINLT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_WINLT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ADC_WINLT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINLT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINLT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINLT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINLT_Type__bindgen_ty_1))
    );
}
impl ADC_WINLT_Type__bindgen_ty_1 {
    #[inline]
    pub fn WINLT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_WINLT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WINLT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let WINLT: u16 = unsafe { ::core::mem::transmute(WINLT) };
            WINLT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_WINLT_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINLT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINLT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINLT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINLT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINLT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINLT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINLT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINLT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_WINUT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_WINUT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_WINUT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ADC_WINUT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINUT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINUT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINUT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINUT_Type__bindgen_ty_1))
    );
}
impl ADC_WINUT_Type__bindgen_ty_1 {
    #[inline]
    pub fn WINUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_WINUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WINUT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let WINUT: u16 = unsafe { ::core::mem::transmute(WINUT) };
            WINUT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_WINUT_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINUT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINUT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINUT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINUT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINUT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINUT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_WINUT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINUT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_GAINCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_GAINCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_GAINCORR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ADC_GAINCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_GAINCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_GAINCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_GAINCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_GAINCORR_Type__bindgen_ty_1))
    );
}
impl ADC_GAINCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn GAINCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_GAINCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(GAINCORR: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let GAINCORR: u16 = unsafe { ::core::mem::transmute(GAINCORR) };
            GAINCORR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_GAINCORR_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_GAINCORR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_GAINCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_GAINCORR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_GAINCORR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_GAINCORR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_GAINCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_GAINCORR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_GAINCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_OFFSETCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_OFFSETCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_OFFSETCORR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_ADC_OFFSETCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_OFFSETCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_OFFSETCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_OFFSETCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ADC_OFFSETCORR_Type__bindgen_ty_1)
        )
    );
}
impl ADC_OFFSETCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OFFSETCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_OFFSETCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OFFSETCORR: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let OFFSETCORR: u16 = unsafe { ::core::mem::transmute(OFFSETCORR) };
            OFFSETCORR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_OFFSETCORR_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_OFFSETCORR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_OFFSETCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_OFFSETCORR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_OFFSETCORR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_OFFSETCORR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OFFSETCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_OFFSETCORR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OFFSETCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CALIB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CALIB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CALIB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_CALIB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CALIB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CALIB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CALIB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CALIB_Type__bindgen_ty_1))
    );
}
impl ADC_CALIB_Type__bindgen_ty_1 {
    #[inline]
    pub fn LINEARITY_CAL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_LINEARITY_CAL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BIAS_CAL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_BIAS_CAL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LINEARITY_CAL: u16,
        BIAS_CAL: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let LINEARITY_CAL: u16 = unsafe { ::core::mem::transmute(LINEARITY_CAL) };
            LINEARITY_CAL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let BIAS_CAL: u16 = unsafe { ::core::mem::transmute(BIAS_CAL) };
            BIAS_CAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CALIB_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CALIB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CALIB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CALIB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CALIB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CALIB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CALIB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_CALIB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CALIB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_ADC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<ADC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ADC_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Adc {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: ADC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 (R/W  8) Reference Control"]
    pub REFCTRL: ADC_REFCTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W  8) Average Control"]
    pub AVGCTRL: ADC_AVGCTRL_Type,
    #[doc = "< \\brief Offset: 0x03 (R/W  8) Sampling Time Control"]
    pub SAMPCTRL: ADC_SAMPCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 16) Control B"]
    pub CTRLB: ADC_CTRLB_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Window Monitor Control"]
    pub WINCTRL: ADC_WINCTRL_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Software Trigger"]
    pub SWTRIG: ADC_SWTRIG_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Input Control"]
    pub INPUTCTRL: ADC_INPUTCTRL_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Event Control"]
    pub EVCTRL: ADC_EVCTRL_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: ADC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x17 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: ADC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: ADC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x19 (R/   8) Status"]
    pub STATUS: ADC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1A (R/  16) Result"]
    pub RESULT: ADC_RESULT_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 16) Window Monitor Lower Threshold"]
    pub WINLT: ADC_WINLT_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 16) Window Monitor Upper Threshold"]
    pub WINUT: ADC_WINUT_Type,
    pub Reserved6: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 16) Gain Correction"]
    pub GAINCORR: ADC_GAINCORR_Type,
    #[doc = "< \\brief Offset: 0x26 (R/W 16) Offset Correction"]
    pub OFFSETCORR: ADC_OFFSETCORR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 16) Calibration"]
    pub CALIB: ADC_CALIB_Type,
    #[doc = "< \\brief Offset: 0x2A (R/W  8) Debug Control"]
    pub DBGCTRL: ADC_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_Adc() {
    assert_eq!(
        ::core::mem::size_of::<Adc>(),
        44usize,
        concat!("Size of: ", stringify!(Adc))
    );
    assert_eq!(
        ::core::mem::align_of::<Adc>(),
        4usize,
        concat!("Alignment of ", stringify!(Adc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).REFCTRL as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(REFCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).AVGCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(AVGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).SAMPCTRL as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SAMPCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).WINCTRL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(WINCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).SWTRIG as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SWTRIG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved3 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).INPUTCTRL as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INPUTCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).EVCTRL as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved4 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).INTENCLR as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).INTENSET as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).STATUS as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).RESULT as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(RESULT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).WINLT as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(WINLT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved5 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).WINUT as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(WINUT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).Reserved6 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).GAINCORR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(GAINCORR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).OFFSETCORR as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(OFFSETCORR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).CALIB as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CALIB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Adc>())).DBGCTRL as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_CTRLA_Type__bindgen_ty_1))
    );
}
impl DAC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_CTRLB_Type__bindgen_ty_1))
    );
}
impl DAC_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn EOEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EOEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IOEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IOEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LEFTADJ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LEFTADJ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BDWP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BDWP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn REFSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_REFSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EOEN: u8,
        IOEN: u8,
        LEFTADJ: u8,
        VPD: u8,
        BDWP: u8,
        REFSEL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EOEN: u8 = unsafe { ::core::mem::transmute(EOEN) };
            EOEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IOEN: u8 = unsafe { ::core::mem::transmute(IOEN) };
            IOEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LEFTADJ: u8 = unsafe { ::core::mem::transmute(LEFTADJ) };
            LEFTADJ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VPD: u8 = unsafe { ::core::mem::transmute(VPD) };
            VPD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BDWP: u8 = unsafe { ::core::mem::transmute(BDWP) };
            BDWP as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let REFSEL: u8 = unsafe { ::core::mem::transmute(REFSEL) };
            REFSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl DAC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn STARTEI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STARTEI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EMPTYEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EMPTYEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STARTEI: u8, EMPTYEO: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STARTEI: u8 = unsafe { ::core::mem::transmute(STARTEI) };
            STARTEI as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EMPTYEO: u8 = unsafe { ::core::mem::transmute(EMPTYEO) };
            EMPTYEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl DAC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn UNDERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UNDERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EMPTY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EMPTY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UNDERRUN: u8,
        EMPTY: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UNDERRUN: u8 = unsafe { ::core::mem::transmute(UNDERRUN) };
            UNDERRUN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EMPTY: u8 = unsafe { ::core::mem::transmute(EMPTY) };
            EMPTY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTENSET_Type__bindgen_ty_1))
    );
}
impl DAC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn UNDERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UNDERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EMPTY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EMPTY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UNDERRUN: u8,
        EMPTY: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UNDERRUN: u8 = unsafe { ::core::mem::transmute(UNDERRUN) };
            UNDERRUN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EMPTY: u8 = unsafe { ::core::mem::transmute(EMPTY) };
            EMPTY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl DAC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn UNDERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_UNDERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EMPTY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EMPTY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UNDERRUN: u8,
        EMPTY: u8,
        SYNCRDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UNDERRUN: u8 = unsafe { ::core::mem::transmute(UNDERRUN) };
            UNDERRUN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EMPTY: u8 = unsafe { ::core::mem::transmute(EMPTY) };
            EMPTY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DAC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DAC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_STATUS_Type__bindgen_ty_1))
    );
}
impl DAC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DAC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DAC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DAC_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_DAC_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DAC_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DAC_DATA_Type__bindgen_ty_1))
    );
}
impl DAC_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DATA: u16 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_DATA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DAC_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_DATA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DAC_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DAC_DATABUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DAC_DATABUF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DAC_DATABUF_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_DAC_DATABUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DAC_DATABUF_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DAC_DATABUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_DATABUF_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DAC_DATABUF_Type__bindgen_ty_1))
    );
}
impl DAC_DATABUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATABUF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_DATABUF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATABUF: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let DATABUF: u16 = unsafe { ::core::mem::transmute(DATABUF) };
            DATABUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DAC_DATABUF_Type() {
    assert_eq!(
        ::core::mem::size_of::<DAC_DATABUF_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DAC_DATABUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DAC_DATABUF_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DAC_DATABUF_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_DATABUF_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_DATABUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DAC_DATABUF_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DAC_DATABUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dac {
    #[doc = "< \\brief Offset: 0x0 (R/W  8) Control A"]
    pub CTRLA: DAC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x1 (R/W  8) Control B"]
    pub CTRLB: DAC_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x2 (R/W  8) Event Control"]
    pub EVCTRL: DAC_EVCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x4 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: DAC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x5 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: DAC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x6 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: DAC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x7 (R/   8) Status"]
    pub STATUS: DAC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x8 (R/W 16) Data"]
    pub DATA: DAC_DATA_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0xC (R/W 16) Data Buffer"]
    pub DATABUF: DAC_DATABUF_Type,
}
#[test]
fn bindgen_test_layout_Dac() {
    assert_eq!(
        ::core::mem::size_of::<Dac>(),
        14usize,
        concat!("Size of: ", stringify!(Dac))
    );
    assert_eq!(
        ::core::mem::align_of::<Dac>(),
        2usize,
        concat!("Alignment of ", stringify!(Dac))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).CTRLB as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).EVCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).Reserved1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).INTENCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).INTENSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).INTFLAG as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).STATUS as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).DATA as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Dac), "::", stringify!(DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).Reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dac>())).DATABUF as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dac),
            "::",
            stringify!(DATABUF)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_CTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DMAENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CRCENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        DMAENABLE: u16,
        CRCENABLE: u16,
        LVLEN0: u16,
        LVLEN1: u16,
        LVLEN2: u16,
        LVLEN3: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DMAENABLE: u16 = unsafe { ::core::mem::transmute(DMAENABLE) };
            DMAENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CRCENABLE: u16 = unsafe { ::core::mem::transmute(CRCENABLE) };
            CRCENABLE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LVLEN0: u16 = unsafe { ::core::mem::transmute(LVLEN0) };
            LVLEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LVLEN1: u16 = unsafe { ::core::mem::transmute(LVLEN1) };
            LVLEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LVLEN2: u16 = unsafe { ::core::mem::transmute(LVLEN2) };
            LVLEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let LVLEN3: u16 = unsafe { ::core::mem::transmute(LVLEN3) };
            LVLEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type__bindgen_ty_2))
    );
}
impl DMAC_CTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn LVLEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LVLEN: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let LVLEN: u16 = unsafe { ::core::mem::transmute(LVLEN) };
            LVLEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CRCCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_CRCCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCBEATSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CRCBEATSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCPOLY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CRCPOLY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCSRC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_CRCSRC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CRCBEATSIZE: u16,
        CRCPOLY: u16,
        CRCSRC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CRCBEATSIZE: u16 = unsafe { ::core::mem::transmute(CRCBEATSIZE) };
            CRCBEATSIZE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CRCPOLY: u16 = unsafe { ::core::mem::transmute(CRCPOLY) };
            CRCPOLY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let CRCSRC: u16 = unsafe { ::core::mem::transmute(CRCSRC) };
            CRCSRC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CRCCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCDATAIN_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCDATAIN_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCDATAIN_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCDATAIN_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCDATAIN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCDATAIN_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCDATAIN_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCDATAIN_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCDATAIN_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCDATAIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CRCDATAIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCDATAIN: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CRCDATAIN: u32 = unsafe { ::core::mem::transmute(CRCDATAIN) };
            CRCDATAIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCDATAIN_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCDATAIN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCDATAIN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCDATAIN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CRCDATAIN_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCDATAIN_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCDATAIN_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCDATAIN_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCDATAIN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCCHKSUM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCCHKSUM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCCHKSUM_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCCHKSUM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCHKSUM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCCHKSUM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCHKSUM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCCHKSUM_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCCHKSUM_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCCHKSUM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CRCCHKSUM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCCHKSUM: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CRCCHKSUM: u32 = unsafe { ::core::mem::transmute(CRCCHKSUM) };
            CRCCHKSUM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCCHKSUM_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCHKSUM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCCHKSUM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCHKSUM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCHKSUM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCCHKSUM_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCHKSUM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCCHKSUM_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCHKSUM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CRCSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCZERO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCZERO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCBUSY: u8, CRCZERO: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRCBUSY: u8 = unsafe { ::core::mem::transmute(CRCBUSY) };
            CRCBUSY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CRCZERO: u8 = unsafe { ::core::mem::transmute(CRCZERO) };
            CRCZERO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CRCSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CRCSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CRCSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_QOSCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_QOSCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_QOSCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_QOSCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_QOSCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_QOSCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_QOSCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRBQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WRBQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_FQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WRBQOS: u8,
        FQOS: u8,
        DQOS: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let WRBQOS: u8 = unsafe { ::core::mem::transmute(WRBQOS) };
            WRBQOS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let FQOS: u8 = unsafe { ::core::mem::transmute(FQOS) };
            FQOS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let DQOS: u8 = unsafe { ::core::mem::transmute(DQOS) };
            DQOS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_QOSCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_QOSCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_QOSCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_QOSCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_QOSCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_QOSCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_QOSCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_QOSCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_QOSCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_SWTRIGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_SWTRIGCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_SWTRIGCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SWTRIGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_SWTRIGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWTRIG0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWTRIG0: u32,
        SWTRIG1: u32,
        SWTRIG2: u32,
        SWTRIG3: u32,
        SWTRIG4: u32,
        SWTRIG5: u32,
        SWTRIG6: u32,
        SWTRIG7: u32,
        SWTRIG8: u32,
        SWTRIG9: u32,
        SWTRIG10: u32,
        SWTRIG11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWTRIG0: u32 = unsafe { ::core::mem::transmute(SWTRIG0) };
            SWTRIG0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SWTRIG1: u32 = unsafe { ::core::mem::transmute(SWTRIG1) };
            SWTRIG1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SWTRIG2: u32 = unsafe { ::core::mem::transmute(SWTRIG2) };
            SWTRIG2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SWTRIG3: u32 = unsafe { ::core::mem::transmute(SWTRIG3) };
            SWTRIG3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SWTRIG4: u32 = unsafe { ::core::mem::transmute(SWTRIG4) };
            SWTRIG4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SWTRIG5: u32 = unsafe { ::core::mem::transmute(SWTRIG5) };
            SWTRIG5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SWTRIG6: u32 = unsafe { ::core::mem::transmute(SWTRIG6) };
            SWTRIG6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SWTRIG7: u32 = unsafe { ::core::mem::transmute(SWTRIG7) };
            SWTRIG7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SWTRIG8: u32 = unsafe { ::core::mem::transmute(SWTRIG8) };
            SWTRIG8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SWTRIG9: u32 = unsafe { ::core::mem::transmute(SWTRIG9) };
            SWTRIG9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SWTRIG10: u32 = unsafe { ::core::mem::transmute(SWTRIG10) };
            SWTRIG10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SWTRIG11: u32 = unsafe { ::core::mem::transmute(SWTRIG11) };
            SWTRIG11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SWTRIGCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_2)
        )
    );
}
impl DMAC_SWTRIGCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn SWTRIG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWTRIG: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let SWTRIG: u32 = unsafe { ::core::mem::transmute(SWTRIG) };
            SWTRIG as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SWTRIGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_SWTRIGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_SWTRIGCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_SWTRIGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_PRICTRL0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_PRICTRL0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PRICTRL0_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_PRICTRL0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PRICTRL0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PRICTRL0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PRICTRL0_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_PRICTRL0_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_PRICTRL0_Type__bindgen_ty_1 {
    #[inline]
    pub fn LVLPRI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LVLPRI0: u32,
        RRLVLEN0: u32,
        LVLPRI1: u32,
        RRLVLEN1: u32,
        LVLPRI2: u32,
        RRLVLEN2: u32,
        LVLPRI3: u32,
        RRLVLEN3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let LVLPRI0: u32 = unsafe { ::core::mem::transmute(LVLPRI0) };
            LVLPRI0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RRLVLEN0: u32 = unsafe { ::core::mem::transmute(RRLVLEN0) };
            RRLVLEN0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let LVLPRI1: u32 = unsafe { ::core::mem::transmute(LVLPRI1) };
            LVLPRI1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RRLVLEN1: u32 = unsafe { ::core::mem::transmute(RRLVLEN1) };
            RRLVLEN1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LVLPRI2: u32 = unsafe { ::core::mem::transmute(LVLPRI2) };
            LVLPRI2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let RRLVLEN2: u32 = unsafe { ::core::mem::transmute(RRLVLEN2) };
            RRLVLEN2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let LVLPRI3: u32 = unsafe { ::core::mem::transmute(LVLPRI3) };
            LVLPRI3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let RRLVLEN3: u32 = unsafe { ::core::mem::transmute(RRLVLEN3) };
            RRLVLEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_PRICTRL0_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PRICTRL0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PRICTRL0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PRICTRL0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PRICTRL0_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_PRICTRL0_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PRICTRL0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_PRICTRL0_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PRICTRL0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_INTPEND_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_INTPEND_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTPEND_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_INTPEND_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTPEND_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_INTPEND_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTPEND_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_INTPEND_Type__bindgen_ty_1))
    );
}
impl DMAC_INTPEND_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn TERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ID: u16,
        TERR: u16,
        TCMPL: u16,
        SUSP: u16,
        FERR: u16,
        BUSY: u16,
        PEND: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u16 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TERR: u16 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TCMPL: u16 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SUSP: u16 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FERR: u16 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let BUSY: u16 = unsafe { ::core::mem::transmute(BUSY) };
            BUSY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PEND: u16 = unsafe { ::core::mem::transmute(PEND) };
            PEND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_INTPEND_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTPEND_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_INTPEND_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTPEND_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_INTPEND_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_INTPEND_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTPEND_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_INTPEND_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTPEND_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_INTSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_INTSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_INTSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_INTSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_INTSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHINT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHINT0: u32,
        CHINT1: u32,
        CHINT2: u32,
        CHINT3: u32,
        CHINT4: u32,
        CHINT5: u32,
        CHINT6: u32,
        CHINT7: u32,
        CHINT8: u32,
        CHINT9: u32,
        CHINT10: u32,
        CHINT11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CHINT0: u32 = unsafe { ::core::mem::transmute(CHINT0) };
            CHINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CHINT1: u32 = unsafe { ::core::mem::transmute(CHINT1) };
            CHINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CHINT2: u32 = unsafe { ::core::mem::transmute(CHINT2) };
            CHINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CHINT3: u32 = unsafe { ::core::mem::transmute(CHINT3) };
            CHINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CHINT4: u32 = unsafe { ::core::mem::transmute(CHINT4) };
            CHINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CHINT5: u32 = unsafe { ::core::mem::transmute(CHINT5) };
            CHINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CHINT6: u32 = unsafe { ::core::mem::transmute(CHINT6) };
            CHINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CHINT7: u32 = unsafe { ::core::mem::transmute(CHINT7) };
            CHINT7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CHINT8: u32 = unsafe { ::core::mem::transmute(CHINT8) };
            CHINT8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CHINT9: u32 = unsafe { ::core::mem::transmute(CHINT9) };
            CHINT9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CHINT10: u32 = unsafe { ::core::mem::transmute(CHINT10) };
            CHINT10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CHINT11: u32 = unsafe { ::core::mem::transmute(CHINT11) };
            CHINT11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_INTSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl DMAC_INTSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn CHINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CHINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let CHINT: u32 = unsafe { ::core::mem::transmute(CHINT) };
            CHINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_INTSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_INTSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_INTSTATUS_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_INTSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BUSYCH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BUSYCH_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_BUSYCH_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BUSYCH_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_1))
    );
}
impl DMAC_BUSYCH_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSYCH0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSYCH0: u32,
        BUSYCH1: u32,
        BUSYCH2: u32,
        BUSYCH3: u32,
        BUSYCH4: u32,
        BUSYCH5: u32,
        BUSYCH6: u32,
        BUSYCH7: u32,
        BUSYCH8: u32,
        BUSYCH9: u32,
        BUSYCH10: u32,
        BUSYCH11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSYCH0: u32 = unsafe { ::core::mem::transmute(BUSYCH0) };
            BUSYCH0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BUSYCH1: u32 = unsafe { ::core::mem::transmute(BUSYCH1) };
            BUSYCH1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUSYCH2: u32 = unsafe { ::core::mem::transmute(BUSYCH2) };
            BUSYCH2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BUSYCH3: u32 = unsafe { ::core::mem::transmute(BUSYCH3) };
            BUSYCH3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BUSYCH4: u32 = unsafe { ::core::mem::transmute(BUSYCH4) };
            BUSYCH4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BUSYCH5: u32 = unsafe { ::core::mem::transmute(BUSYCH5) };
            BUSYCH5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BUSYCH6: u32 = unsafe { ::core::mem::transmute(BUSYCH6) };
            BUSYCH6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BUSYCH7: u32 = unsafe { ::core::mem::transmute(BUSYCH7) };
            BUSYCH7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let BUSYCH8: u32 = unsafe { ::core::mem::transmute(BUSYCH8) };
            BUSYCH8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BUSYCH9: u32 = unsafe { ::core::mem::transmute(BUSYCH9) };
            BUSYCH9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BUSYCH10: u32 = unsafe { ::core::mem::transmute(BUSYCH10) };
            BUSYCH10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let BUSYCH11: u32 = unsafe { ::core::mem::transmute(BUSYCH11) };
            BUSYCH11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BUSYCH_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_2))
    );
}
impl DMAC_BUSYCH_Type__bindgen_ty_2 {
    #[inline]
    pub fn BUSYCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUSYCH: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let BUSYCH: u32 = unsafe { ::core::mem::transmute(BUSYCH) };
            BUSYCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BUSYCH_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BUSYCH_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BUSYCH_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_PENDCH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_PENDCH_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_PENDCH_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PENDCH_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type__bindgen_ty_1))
    );
}
impl DMAC_PENDCH_Type__bindgen_ty_1 {
    #[inline]
    pub fn PENDCH0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PENDCH0: u32,
        PENDCH1: u32,
        PENDCH2: u32,
        PENDCH3: u32,
        PENDCH4: u32,
        PENDCH5: u32,
        PENDCH6: u32,
        PENDCH7: u32,
        PENDCH8: u32,
        PENDCH9: u32,
        PENDCH10: u32,
        PENDCH11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PENDCH0: u32 = unsafe { ::core::mem::transmute(PENDCH0) };
            PENDCH0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PENDCH1: u32 = unsafe { ::core::mem::transmute(PENDCH1) };
            PENDCH1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PENDCH2: u32 = unsafe { ::core::mem::transmute(PENDCH2) };
            PENDCH2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PENDCH3: u32 = unsafe { ::core::mem::transmute(PENDCH3) };
            PENDCH3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PENDCH4: u32 = unsafe { ::core::mem::transmute(PENDCH4) };
            PENDCH4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PENDCH5: u32 = unsafe { ::core::mem::transmute(PENDCH5) };
            PENDCH5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PENDCH6: u32 = unsafe { ::core::mem::transmute(PENDCH6) };
            PENDCH6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PENDCH7: u32 = unsafe { ::core::mem::transmute(PENDCH7) };
            PENDCH7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PENDCH8: u32 = unsafe { ::core::mem::transmute(PENDCH8) };
            PENDCH8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PENDCH9: u32 = unsafe { ::core::mem::transmute(PENDCH9) };
            PENDCH9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PENDCH10: u32 = unsafe { ::core::mem::transmute(PENDCH10) };
            PENDCH10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PENDCH11: u32 = unsafe { ::core::mem::transmute(PENDCH11) };
            PENDCH11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PENDCH_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type__bindgen_ty_2))
    );
}
impl DMAC_PENDCH_Type__bindgen_ty_2 {
    #[inline]
    pub fn PENDCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PENDCH: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PENDCH: u32 = unsafe { ::core::mem::transmute(PENDCH) };
            PENDCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_PENDCH_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_PENDCH_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_PENDCH_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_ACTIVE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_ACTIVE_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_ACTIVE_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_ACTIVE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_1))
    );
}
impl DMAC_ACTIVE_Type__bindgen_ty_1 {
    #[inline]
    pub fn LVLEX0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ABUSY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ABUSY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BTCNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_BTCNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LVLEX0: u32,
        LVLEX1: u32,
        LVLEX2: u32,
        LVLEX3: u32,
        ID: u32,
        ABUSY: u32,
        BTCNT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LVLEX0: u32 = unsafe { ::core::mem::transmute(LVLEX0) };
            LVLEX0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LVLEX1: u32 = unsafe { ::core::mem::transmute(LVLEX1) };
            LVLEX1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LVLEX2: u32 = unsafe { ::core::mem::transmute(LVLEX2) };
            LVLEX2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LVLEX3: u32 = unsafe { ::core::mem::transmute(LVLEX3) };
            LVLEX3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let ID: u32 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ABUSY: u32 = unsafe { ::core::mem::transmute(ABUSY) };
            ABUSY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let BTCNT: u32 = unsafe { ::core::mem::transmute(BTCNT) };
            BTCNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_ACTIVE_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_2))
    );
}
impl DMAC_ACTIVE_Type__bindgen_ty_2 {
    #[inline]
    pub fn LVLEX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LVLEX: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let LVLEX: u32 = unsafe { ::core::mem::transmute(LVLEX) };
            LVLEX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_ACTIVE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_ACTIVE_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_ACTIVE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BASEADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BASEADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BASEADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_BASEADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BASEADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BASEADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BASEADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_BASEADDR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_BASEADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn BASEADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_BASEADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BASEADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let BASEADDR: u32 = unsafe { ::core::mem::transmute(BASEADDR) };
            BASEADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BASEADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BASEADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BASEADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BASEADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BASEADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BASEADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BASEADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BASEADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BASEADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_WRBADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_WRBADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_WRBADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_WRBADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_WRBADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_WRBADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_WRBADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_WRBADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_WRBADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRBADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_WRBADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WRBADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let WRBADDR: u32 = unsafe { ::core::mem::transmute(WRBADDR) };
            WRBADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_WRBADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_WRBADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_WRBADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_WRBADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_WRBADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_WRBADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_WRBADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_WRBADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_WRBADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHID_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHID_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHID_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHID_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHID_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHID_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHID_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHID_Type__bindgen_ty_1))
    );
}
impl DMAC_CHID_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHID_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHID_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHID_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHID_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHID_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHID_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHID_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLA_Type__bindgen_ty_1))
    );
}
impl DMAC_CHCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHCTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHCTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLB_Type__bindgen_ty_1))
    );
}
impl DMAC_CHCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EVIE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVIE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVOE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVOE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_LVL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIGSRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_TRIGSRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIGACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TRIGACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT: u32,
        EVIE: u32,
        EVOE: u32,
        LVL: u32,
        TRIGSRC: u32,
        TRIGACT: u32,
        CMD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT: u32 = unsafe { ::core::mem::transmute(EVACT) };
            EVACT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EVIE: u32 = unsafe { ::core::mem::transmute(EVIE) };
            EVIE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EVOE: u32 = unsafe { ::core::mem::transmute(EVOE) };
            EVOE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let LVL: u32 = unsafe { ::core::mem::transmute(LVL) };
            LVL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let TRIGSRC: u32 = unsafe { ::core::mem::transmute(TRIGSRC) };
            TRIGSRC as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let TRIGACT: u32 = unsafe { ::core::mem::transmute(TRIGACT) };
            TRIGACT as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHCTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHCTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TERR: u8,
        TCMPL: u8,
        SUSP: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTENSET_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TERR: u8,
        TCMPL: u8,
        SUSP: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TERR: u8,
        TCMPL: u8,
        SUSP: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHINTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_CHSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PEND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEND: u8, BUSY: u8, FERR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEND: u8 = unsafe { ::core::mem::transmute(PEND) };
            PEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BUSY: u8 = unsafe { ::core::mem::transmute(BUSY) };
            BUSY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FERR: u8 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_CHSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BTCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BTCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BTCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_DMAC_BTCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_BTCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VALID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVOSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_EVOSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BLOCKACT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BLOCKACT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BEATSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BEATSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SRCINC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SRCINC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSTINC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DSTINC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STEPSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_STEPSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STEPSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_STEPSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VALID: u16,
        EVOSEL: u16,
        BLOCKACT: u16,
        BEATSIZE: u16,
        SRCINC: u16,
        DSTINC: u16,
        STEPSEL: u16,
        STEPSIZE: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VALID: u16 = unsafe { ::core::mem::transmute(VALID) };
            VALID as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let EVOSEL: u16 = unsafe { ::core::mem::transmute(EVOSEL) };
            EVOSEL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let BLOCKACT: u16 = unsafe { ::core::mem::transmute(BLOCKACT) };
            BLOCKACT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let BEATSIZE: u16 = unsafe { ::core::mem::transmute(BEATSIZE) };
            BEATSIZE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SRCINC: u16 = unsafe { ::core::mem::transmute(SRCINC) };
            SRCINC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DSTINC: u16 = unsafe { ::core::mem::transmute(DSTINC) };
            DSTINC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let STEPSEL: u16 = unsafe { ::core::mem::transmute(STEPSEL) };
            STEPSEL as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let STEPSIZE: u16 = unsafe { ::core::mem::transmute(STEPSIZE) };
            STEPSIZE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BTCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BTCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BTCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BTCNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BTCNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BTCNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_DMAC_BTCNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCNT_Type__bindgen_ty_1))
    );
}
impl DMAC_BTCNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn BTCNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BTCNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BTCNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BTCNT: u16 = unsafe { ::core::mem::transmute(BTCNT) };
            BTCNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BTCNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BTCNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_BTCNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_SRCADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_SRCADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SRCADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_SRCADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SRCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SRCADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SRCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SRCADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_SRCADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRCADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SRCADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SRCADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SRCADDR: u32 = unsafe { ::core::mem::transmute(SRCADDR) };
            SRCADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_SRCADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SRCADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SRCADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SRCADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SRCADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_SRCADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SRCADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_SRCADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SRCADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DSTADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DSTADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DSTADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_DSTADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DSTADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DSTADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DSTADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DSTADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_DSTADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DSTADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DSTADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DSTADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DSTADDR: u32 = unsafe { ::core::mem::transmute(DSTADDR) };
            DSTADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DSTADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DSTADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DSTADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DSTADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DSTADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DSTADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DSTADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DSTADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DSTADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DESCADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DESCADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DESCADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DMAC_DESCADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DESCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DESCADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DESCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_DESCADDR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_DESCADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DESCADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DESCADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DESCADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DESCADDR: u32 = unsafe { ::core::mem::transmute(DESCADDR) };
            DESCADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DESCADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DESCADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DESCADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DESCADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DESCADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DESCADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DESCADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DMAC_DESCADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DESCADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dmac {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control"]
    pub CTRL: DMAC_CTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) CRC Control"]
    pub CRCCTRL: DMAC_CRCCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) CRC Data Input"]
    pub CRCDATAIN: DMAC_CRCDATAIN_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) CRC Checksum"]
    pub CRCCHKSUM: DMAC_CRCCHKSUM_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) CRC Status"]
    pub CRCSTATUS: DMAC_CRCSTATUS_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Debug Control"]
    pub DBGCTRL: DMAC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) QOS Control"]
    pub QOSCTRL: DMAC_QOSCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Software Trigger Control"]
    pub SWTRIGCTRL: DMAC_SWTRIGCTRL_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Priority Control 0"]
    pub PRICTRL0: DMAC_PRICTRL0_Type,
    pub Reserved2: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 16) Interrupt Pending"]
    pub INTPEND: DMAC_INTPEND_Type,
    pub Reserved3: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x24 (R/  32) Interrupt Status"]
    pub INTSTATUS: DMAC_INTSTATUS_Type,
    #[doc = "< \\brief Offset: 0x28 (R/  32) Busy Channels"]
    pub BUSYCH: DMAC_BUSYCH_Type,
    #[doc = "< \\brief Offset: 0x2C (R/  32) Pending Channels"]
    pub PENDCH: DMAC_PENDCH_Type,
    #[doc = "< \\brief Offset: 0x30 (R/  32) Active Channel and Levels"]
    pub ACTIVE: DMAC_ACTIVE_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W 32) Descriptor Memory Section Base Address"]
    pub BASEADDR: DMAC_BASEADDR_Type,
    #[doc = "< \\brief Offset: 0x38 (R/W 32) Write-Back Memory Section Base Address"]
    pub WRBADDR: DMAC_WRBADDR_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x3F (R/W  8) Channel ID"]
    pub CHID: DMAC_CHID_Type,
    #[doc = "< \\brief Offset: 0x40 (R/W  8) Channel Control A"]
    pub CHCTRLA: DMAC_CHCTRLA_Type,
    pub Reserved5: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x44 (R/W 32) Channel Control B"]
    pub CHCTRLB: DMAC_CHCTRLB_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x4C (R/W  8) Channel Interrupt Enable Clear"]
    pub CHINTENCLR: DMAC_CHINTENCLR_Type,
    #[doc = "< \\brief Offset: 0x4D (R/W  8) Channel Interrupt Enable Set"]
    pub CHINTENSET: DMAC_CHINTENSET_Type,
    #[doc = "< \\brief Offset: 0x4E (R/W  8) Channel Interrupt Flag Status and Clear"]
    pub CHINTFLAG: DMAC_CHINTFLAG_Type,
    #[doc = "< \\brief Offset: 0x4F (R/   8) Channel Status"]
    pub CHSTATUS: DMAC_CHSTATUS_Type,
}
#[test]
fn bindgen_test_layout_Dmac() {
    assert_eq!(
        ::core::mem::size_of::<Dmac>(),
        80usize,
        concat!("Size of: ", stringify!(Dmac))
    );
    assert_eq!(
        ::core::mem::align_of::<Dmac>(),
        4usize,
        concat!("Alignment of ", stringify!(Dmac))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CRCCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CRCDATAIN as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCDATAIN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CRCCHKSUM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCCHKSUM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CRCSTATUS as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).DBGCTRL as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).QOSCTRL as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(QOSCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved1 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).SWTRIGCTRL as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(SWTRIGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).PRICTRL0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(PRICTRL0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).INTPEND as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(INTPEND)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved3 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).INTSTATUS as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(INTSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).BUSYCH as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(BUSYCH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).PENDCH as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(PENDCH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).ACTIVE as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(ACTIVE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).BASEADDR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(BASEADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).WRBADDR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(WRBADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved4 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHID as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHCTRLA as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHCTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved5 as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHCTRLB as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHCTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).Reserved6 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHINTENCLR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHINTENSET as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHINTFLAG as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dmac>())).CHSTATUS as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHSTATUS)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DmacDescriptor {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Block Transfer Control"]
    pub BTCTRL: DMAC_BTCTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Block Transfer Count"]
    pub BTCNT: DMAC_BTCNT_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Block Transfer Source Address"]
    pub SRCADDR: DMAC_SRCADDR_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Block Transfer Destination Address"]
    pub DSTADDR: DMAC_DSTADDR_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Next Descriptor Address"]
    pub DESCADDR: DMAC_DESCADDR_Type,
}
#[test]
fn bindgen_test_layout_DmacDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<DmacDescriptor>(),
        16usize,
        concat!("Size of: ", stringify!(DmacDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<DmacDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(DmacDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DmacDescriptor>())).BTCTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(BTCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DmacDescriptor>())).BTCNT as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(BTCNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DmacDescriptor>())).SRCADDR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(SRCADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DmacDescriptor>())).DSTADDR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(DSTADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DmacDescriptor>())).DESCADDR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(DESCADDR)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_CTRL_Type__bindgen_ty_1))
    );
}
impl DSU_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MBIST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MBIST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        CRC: u8,
        MBIST: u8,
        CE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CRC: u8 = unsafe { ::core::mem::transmute(CRC) };
            CRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MBIST: u8 = unsafe { ::core::mem::transmute(MBIST) };
            MBIST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CE: u8 = unsafe { ::core::mem::transmute(CE) };
            CE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_STATUSA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_STATUSA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSA_Type__bindgen_ty_1))
    );
}
impl DSU_STATUSA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DONE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DONE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRSTEXT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRSTEXT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DONE: u8,
        CRSTEXT: u8,
        BERR: u8,
        FAIL: u8,
        PERR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DONE: u8 = unsafe { ::core::mem::transmute(DONE) };
            DONE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CRSTEXT: u8 = unsafe { ::core::mem::transmute(CRSTEXT) };
            CRSTEXT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BERR: u8 = unsafe { ::core::mem::transmute(BERR) };
            BERR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FAIL: u8 = unsafe { ::core::mem::transmute(FAIL) };
            FAIL as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PERR: u8 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_STATUSA_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_STATUSA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_STATUSA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_STATUSB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_STATUSB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DSU_STATUSB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type__bindgen_ty_1))
    );
}
impl DSU_STATUSB_Type__bindgen_ty_1 {
    #[inline]
    pub fn PROT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PROT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DBGPRES(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGPRES(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCCD0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCCD1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HPE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PROT: u8,
        DBGPRES: u8,
        DCCD0: u8,
        DCCD1: u8,
        HPE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PROT: u8 = unsafe { ::core::mem::transmute(PROT) };
            PROT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DBGPRES: u8 = unsafe { ::core::mem::transmute(DBGPRES) };
            DBGPRES as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DCCD0: u8 = unsafe { ::core::mem::transmute(DCCD0) };
            DCCD0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DCCD1: u8 = unsafe { ::core::mem::transmute(DCCD1) };
            DCCD1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HPE: u8 = unsafe { ::core::mem::transmute(HPE) };
            HPE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type__bindgen_ty_2))
    );
}
impl DSU_STATUSB_Type__bindgen_ty_2 {
    #[inline]
    pub fn DCCD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DCCD: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let DCCD: u8 = unsafe { ::core::mem::transmute(DCCD) };
            DCCD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_STATUSB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_STATUSB_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_STATUSB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ADDR_Type__bindgen_ty_1))
    );
}
impl DSU_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_LENGTH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_LENGTH_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_LENGTH_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_LENGTH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_LENGTH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_LENGTH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_LENGTH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_LENGTH_Type__bindgen_ty_1))
    );
}
impl DSU_LENGTH_Type__bindgen_ty_1 {
    #[inline]
    pub fn LENGTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_LENGTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LENGTH: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let LENGTH: u32 = unsafe { ::core::mem::transmute(LENGTH) };
            LENGTH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_LENGTH_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_LENGTH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_LENGTH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_LENGTH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_LENGTH_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_LENGTH_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_LENGTH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_LENGTH_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_LENGTH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DATA_Type__bindgen_ty_1))
    );
}
impl DSU_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DCC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DCC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DCC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_DCC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DCC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCC_Type__bindgen_ty_1))
    );
}
impl DSU_DCC_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DCC_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DCC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DCC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DCC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DID_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DID_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DID_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_DID_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DID_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DID_Type__bindgen_ty_1))
    );
}
impl DSU_DID_Type__bindgen_ty_1 {
    #[inline]
    pub fn DEVSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DEVSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn REVISION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVISION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DIE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DIE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SERIES(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SERIES(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn FAMILY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_FAMILY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PROCESSOR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PROCESSOR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DEVSEL: u32,
        REVISION: u32,
        DIE: u32,
        SERIES: u32,
        FAMILY: u32,
        PROCESSOR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DEVSEL: u32 = unsafe { ::core::mem::transmute(DEVSEL) };
            DEVSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let REVISION: u32 = unsafe { ::core::mem::transmute(REVISION) };
            REVISION as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let DIE: u32 = unsafe { ::core::mem::transmute(DIE) };
            DIE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let SERIES: u32 = unsafe { ::core::mem::transmute(SERIES) };
            SERIES as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let FAMILY: u32 = unsafe { ::core::mem::transmute(FAMILY) };
            FAMILY as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let PROCESSOR: u32 = unsafe { ::core::mem::transmute(PROCESSOR) };
            PROCESSOR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DID_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DID_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DID_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DID_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DID_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DID_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_DID_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ENTRY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_ENTRY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_ENTRY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_ENTRY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY_Type__bindgen_ty_1))
    );
}
impl DSU_ENTRY_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPRES(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EPRES(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FMT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FMT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDOFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ADDOFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPRES: u32,
        FMT: u32,
        ADDOFF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EPRES: u32 = unsafe { ::core::mem::transmute(EPRES) };
            EPRES as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FMT: u32 = unsafe { ::core::mem::transmute(FMT) };
            FMT as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ADDOFF: u32 = unsafe { ::core::mem::transmute(ADDOFF) };
            ADDOFF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_ENTRY_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_ENTRY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_ENTRY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ENTRY1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_DSU_ENTRY1_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY1_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_ENTRY1_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_END_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_END_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_END_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_DSU_END_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_END_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_END_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_END_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_END_Type__bindgen_ty_1))
    );
}
impl DSU_END_Type__bindgen_ty_1 {
    #[inline]
    pub fn END(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_END(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(END: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let END: u32 = unsafe { ::core::mem::transmute(END) };
            END as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_END_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_END_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_END_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_END_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_END_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_END_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_END_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_END_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_END_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_MEMTYPE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_MEMTYPE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_MEMTYPE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_MEMTYPE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_MEMTYPE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_MEMTYPE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_MEMTYPE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_MEMTYPE_Type__bindgen_ty_1))
    );
}
impl DSU_MEMTYPE_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SMEMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SMEMP: u32 = unsafe { ::core::mem::transmute(SMEMP) };
            SMEMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_MEMTYPE_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_MEMTYPE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_MEMTYPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_MEMTYPE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_MEMTYPE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_MEMTYPE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_MEMTYPE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_MEMTYPE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_MEMTYPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID4_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID4_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID4_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_PID4_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID4_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID4_Type__bindgen_ty_1))
    );
}
impl DSU_PID4_Type__bindgen_ty_1 {
    #[inline]
    pub fn JEPCC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_JEPCC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn FKBC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FKBC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(JEPCC: u32, FKBC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let JEPCC: u32 = unsafe { ::core::mem::transmute(JEPCC) };
            JEPCC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let FKBC: u32 = unsafe { ::core::mem::transmute(FKBC) };
            FKBC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID4_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID4_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID4_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID4_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID4_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID0_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_PID0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID0_Type__bindgen_ty_1))
    );
}
impl DSU_PID0_Type__bindgen_ty_1 {
    #[inline]
    pub fn PARTNBL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PARTNBL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PARTNBL: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PARTNBL: u32 = unsafe { ::core::mem::transmute(PARTNBL) };
            PARTNBL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID0_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID0_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID0_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID0_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID1_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_PID1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID1_Type__bindgen_ty_1))
    );
}
impl DSU_PID1_Type__bindgen_ty_1 {
    #[inline]
    pub fn PARTNBH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PARTNBH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn JEPIDCL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_JEPIDCL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PARTNBH: u32, JEPIDCL: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PARTNBH: u32 = unsafe { ::core::mem::transmute(PARTNBH) };
            PARTNBH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let JEPIDCL: u32 = unsafe { ::core::mem::transmute(JEPIDCL) };
            JEPIDCL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID1_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID1_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID1_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID1_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID2_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_PID2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID2_Type__bindgen_ty_1))
    );
}
impl DSU_PID2_Type__bindgen_ty_1 {
    #[inline]
    pub fn JEPIDCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_JEPIDCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn JEPU(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JEPU(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn REVISION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVISION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        JEPIDCH: u32,
        JEPU: u32,
        REVISION: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let JEPIDCH: u32 = unsafe { ::core::mem::transmute(JEPIDCH) };
            JEPIDCH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let JEPU: u32 = unsafe { ::core::mem::transmute(JEPU) };
            JEPU as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let REVISION: u32 = unsafe { ::core::mem::transmute(REVISION) };
            REVISION as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID2_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID2_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID2_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID2_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID3_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_PID3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID3_Type__bindgen_ty_1))
    );
}
impl DSU_PID3_Type__bindgen_ty_1 {
    #[inline]
    pub fn CUSMOD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CUSMOD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn REVAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CUSMOD: u32, REVAND: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CUSMOD: u32 = unsafe { ::core::mem::transmute(CUSMOD) };
            CUSMOD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let REVAND: u32 = unsafe { ::core::mem::transmute(REVAND) };
            REVAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID3_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID3_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID3_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_PID3_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID0_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_CID0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID0_Type__bindgen_ty_1))
    );
}
impl DSU_CID0_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB0: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB0: u32 = unsafe { ::core::mem::transmute(PREAMBLEB0) };
            PREAMBLEB0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID0_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID0_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID0_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID0_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID1_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_CID1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID1_Type__bindgen_ty_1))
    );
}
impl DSU_CID1_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CCLASS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCLASS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLE: u32, CCLASS: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PREAMBLE: u32 = unsafe { ::core::mem::transmute(PREAMBLE) };
            PREAMBLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let CCLASS: u32 = unsafe { ::core::mem::transmute(CCLASS) };
            CCLASS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID1_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID1_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID1_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID1_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID2_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_CID2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID2_Type__bindgen_ty_1))
    );
}
impl DSU_CID2_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB2: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB2: u32 = unsafe { ::core::mem::transmute(PREAMBLEB2) };
            PREAMBLEB2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID2_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID2_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID2_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID2_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID3_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_DSU_CID3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID3_Type__bindgen_ty_1))
    );
}
impl DSU_CID3_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB3: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB3: u32 = unsafe { ::core::mem::transmute(PREAMBLEB3) };
            PREAMBLEB3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID3_Type() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID3_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID3_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DSU_CID3_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dsu {
    #[doc = "< \\brief Offset: 0x0000 ( /W  8) Control"]
    pub CTRL: DSU_CTRL_Type,
    #[doc = "< \\brief Offset: 0x0001 (R/W  8) Status A"]
    pub STATUSA: DSU_STATUSA_Type,
    #[doc = "< \\brief Offset: 0x0002 (R/   8) Status B"]
    pub STATUSB: DSU_STATUSB_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0004 (R/W 32) Address"]
    pub ADDR: DSU_ADDR_Type,
    #[doc = "< \\brief Offset: 0x0008 (R/W 32) Length"]
    pub LENGTH: DSU_LENGTH_Type,
    #[doc = "< \\brief Offset: 0x000C (R/W 32) Data"]
    pub DATA: DSU_DATA_Type,
    #[doc = "< \\brief Offset: 0x0010 (R/W 32) Debug Communication Channel n"]
    pub DCC: [DSU_DCC_Type; 2usize],
    #[doc = "< \\brief Offset: 0x0018 (R/  32) Device Identification"]
    pub DID: DSU_DID_Type,
    pub Reserved2: [RoReg8; 4068usize],
    #[doc = "< \\brief Offset: 0x1000 (R/  32) CoreSight ROM Table Entry 0"]
    pub ENTRY: DSU_ENTRY_Type,
    #[doc = "< \\brief Offset: 0x1004 (R/  32) CoreSight ROM Table Entry 1"]
    pub ENTRY1: DSU_ENTRY1_Type,
    #[doc = "< \\brief Offset: 0x1008 (R/  32) CoreSight ROM Table End"]
    pub END: DSU_END_Type,
    pub Reserved3: [RoReg8; 4032usize],
    #[doc = "< \\brief Offset: 0x1FCC (R/  32) CoreSight ROM Table Memory Type"]
    pub MEMTYPE: DSU_MEMTYPE_Type,
    #[doc = "< \\brief Offset: 0x1FD0 (R/  32) Peripheral Identification 4"]
    pub PID4: DSU_PID4_Type,
    pub Reserved4: [RoReg8; 12usize],
    #[doc = "< \\brief Offset: 0x1FE0 (R/  32) Peripheral Identification 0"]
    pub PID0: DSU_PID0_Type,
    #[doc = "< \\brief Offset: 0x1FE4 (R/  32) Peripheral Identification 1"]
    pub PID1: DSU_PID1_Type,
    #[doc = "< \\brief Offset: 0x1FE8 (R/  32) Peripheral Identification 2"]
    pub PID2: DSU_PID2_Type,
    #[doc = "< \\brief Offset: 0x1FEC (R/  32) Peripheral Identification 3"]
    pub PID3: DSU_PID3_Type,
    #[doc = "< \\brief Offset: 0x1FF0 (R/  32) Component Identification 0"]
    pub CID0: DSU_CID0_Type,
    #[doc = "< \\brief Offset: 0x1FF4 (R/  32) Component Identification 1"]
    pub CID1: DSU_CID1_Type,
    #[doc = "< \\brief Offset: 0x1FF8 (R/  32) Component Identification 2"]
    pub CID2: DSU_CID2_Type,
    #[doc = "< \\brief Offset: 0x1FFC (R/  32) Component Identification 3"]
    pub CID3: DSU_CID3_Type,
}
#[test]
fn bindgen_test_layout_Dsu() {
    assert_eq!(
        ::core::mem::size_of::<Dsu>(),
        8192usize,
        concat!("Size of: ", stringify!(Dsu))
    );
    assert_eq!(
        ::core::mem::align_of::<Dsu>(),
        4usize,
        concat!("Alignment of ", stringify!(Dsu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).CTRL as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).STATUSA as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(STATUSA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).STATUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(STATUSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).Reserved1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).ADDR as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(ADDR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).LENGTH as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(LENGTH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).DATA as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DATA))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).DCC as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DCC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).DID as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).Reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).ENTRY as *const _ as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(ENTRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).ENTRY1 as *const _ as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(ENTRY1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).END as *const _ as usize },
        4104usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(END))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).Reserved3 as *const _ as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).MEMTYPE as *const _ as usize },
        8140usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(MEMTYPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).PID4 as *const _ as usize },
        8144usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).Reserved4 as *const _ as usize },
        8148usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).PID0 as *const _ as usize },
        8160usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).PID1 as *const _ as usize },
        8164usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).PID2 as *const _ as usize },
        8168usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).PID3 as *const _ as usize },
        8172usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).CID0 as *const _ as usize },
        8176usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).CID1 as *const _ as usize },
        8180usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).CID2 as *const _ as usize },
        8184usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Dsu>())).CID3 as *const _ as usize },
        8188usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID3))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_CTRL_Type__bindgen_ty_1))
    );
}
impl EIC_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_STATUS_Type__bindgen_ty_1))
    );
}
impl EIC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_NMICTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_NMICTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_NMICTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_NMICTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMICTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMICTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMICTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMICTRL_Type__bindgen_ty_1))
    );
}
impl EIC_NMICTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn NMISENSE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_NMISENSE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NMIFILTEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NMIFILTEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NMISENSE: u8, NMIFILTEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let NMISENSE: u8 = unsafe { ::core::mem::transmute(NMISENSE) };
            NMISENSE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NMIFILTEN: u8 = unsafe { ::core::mem::transmute(NMIFILTEN) };
            NMIFILTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_NMICTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMICTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMICTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMICTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMICTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_NMICTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMICTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_NMICTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMICTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_NMIFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_NMIFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_NMIFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_NMIFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMIFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMIFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMIFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMIFLAG_Type__bindgen_ty_1))
    );
}
impl EIC_NMIFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn NMI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NMI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NMI: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NMI: u8 = unsafe { ::core::mem::transmute(NMI) };
            NMI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_NMIFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMIFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMIFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMIFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMIFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_NMIFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMIFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_NMIFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMIFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EIC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl EIC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINTEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINTEO15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EXTINTEO0: u32,
        EXTINTEO1: u32,
        EXTINTEO2: u32,
        EXTINTEO3: u32,
        EXTINTEO4: u32,
        EXTINTEO5: u32,
        EXTINTEO6: u32,
        EXTINTEO7: u32,
        EXTINTEO8: u32,
        EXTINTEO9: u32,
        EXTINTEO10: u32,
        EXTINTEO11: u32,
        EXTINTEO12: u32,
        EXTINTEO13: u32,
        EXTINTEO14: u32,
        EXTINTEO15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EXTINTEO0: u32 = unsafe { ::core::mem::transmute(EXTINTEO0) };
            EXTINTEO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EXTINTEO1: u32 = unsafe { ::core::mem::transmute(EXTINTEO1) };
            EXTINTEO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EXTINTEO2: u32 = unsafe { ::core::mem::transmute(EXTINTEO2) };
            EXTINTEO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EXTINTEO3: u32 = unsafe { ::core::mem::transmute(EXTINTEO3) };
            EXTINTEO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXTINTEO4: u32 = unsafe { ::core::mem::transmute(EXTINTEO4) };
            EXTINTEO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EXTINTEO5: u32 = unsafe { ::core::mem::transmute(EXTINTEO5) };
            EXTINTEO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EXTINTEO6: u32 = unsafe { ::core::mem::transmute(EXTINTEO6) };
            EXTINTEO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EXTINTEO7: u32 = unsafe { ::core::mem::transmute(EXTINTEO7) };
            EXTINTEO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EXTINTEO8: u32 = unsafe { ::core::mem::transmute(EXTINTEO8) };
            EXTINTEO8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EXTINTEO9: u32 = unsafe { ::core::mem::transmute(EXTINTEO9) };
            EXTINTEO9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EXTINTEO10: u32 = unsafe { ::core::mem::transmute(EXTINTEO10) };
            EXTINTEO10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EXTINTEO11: u32 = unsafe { ::core::mem::transmute(EXTINTEO11) };
            EXTINTEO11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EXTINTEO12: u32 = unsafe { ::core::mem::transmute(EXTINTEO12) };
            EXTINTEO12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EXTINTEO13: u32 = unsafe { ::core::mem::transmute(EXTINTEO13) };
            EXTINTEO13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EXTINTEO14: u32 = unsafe { ::core::mem::transmute(EXTINTEO14) };
            EXTINTEO14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EXTINTEO15: u32 = unsafe { ::core::mem::transmute(EXTINTEO15) };
            EXTINTEO15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_EIC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EIC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl EIC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn EXTINTEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINTEO: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINTEO: u32 = unsafe { ::core::mem::transmute(EXTINTEO) };
            EXTINTEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EIC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl EIC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EXTINT0: u32,
        EXTINT1: u32,
        EXTINT2: u32,
        EXTINT3: u32,
        EXTINT4: u32,
        EXTINT5: u32,
        EXTINT6: u32,
        EXTINT7: u32,
        EXTINT8: u32,
        EXTINT9: u32,
        EXTINT10: u32,
        EXTINT11: u32,
        EXTINT12: u32,
        EXTINT13: u32,
        EXTINT14: u32,
        EXTINT15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EXTINT0: u32 = unsafe { ::core::mem::transmute(EXTINT0) };
            EXTINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EXTINT1: u32 = unsafe { ::core::mem::transmute(EXTINT1) };
            EXTINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EXTINT2: u32 = unsafe { ::core::mem::transmute(EXTINT2) };
            EXTINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EXTINT3: u32 = unsafe { ::core::mem::transmute(EXTINT3) };
            EXTINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXTINT4: u32 = unsafe { ::core::mem::transmute(EXTINT4) };
            EXTINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EXTINT5: u32 = unsafe { ::core::mem::transmute(EXTINT5) };
            EXTINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EXTINT6: u32 = unsafe { ::core::mem::transmute(EXTINT6) };
            EXTINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EXTINT7: u32 = unsafe { ::core::mem::transmute(EXTINT7) };
            EXTINT7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EXTINT8: u32 = unsafe { ::core::mem::transmute(EXTINT8) };
            EXTINT8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EXTINT9: u32 = unsafe { ::core::mem::transmute(EXTINT9) };
            EXTINT9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EXTINT10: u32 = unsafe { ::core::mem::transmute(EXTINT10) };
            EXTINT10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EXTINT11: u32 = unsafe { ::core::mem::transmute(EXTINT11) };
            EXTINT11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EXTINT12: u32 = unsafe { ::core::mem::transmute(EXTINT12) };
            EXTINT12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EXTINT13: u32 = unsafe { ::core::mem::transmute(EXTINT13) };
            EXTINT13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EXTINT14: u32 = unsafe { ::core::mem::transmute(EXTINT14) };
            EXTINT14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EXTINT15: u32 = unsafe { ::core::mem::transmute(EXTINT15) };
            EXTINT15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_EIC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl EIC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EIC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENSET_Type__bindgen_ty_1))
    );
}
impl EIC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EXTINT0: u32,
        EXTINT1: u32,
        EXTINT2: u32,
        EXTINT3: u32,
        EXTINT4: u32,
        EXTINT5: u32,
        EXTINT6: u32,
        EXTINT7: u32,
        EXTINT8: u32,
        EXTINT9: u32,
        EXTINT10: u32,
        EXTINT11: u32,
        EXTINT12: u32,
        EXTINT13: u32,
        EXTINT14: u32,
        EXTINT15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EXTINT0: u32 = unsafe { ::core::mem::transmute(EXTINT0) };
            EXTINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EXTINT1: u32 = unsafe { ::core::mem::transmute(EXTINT1) };
            EXTINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EXTINT2: u32 = unsafe { ::core::mem::transmute(EXTINT2) };
            EXTINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EXTINT3: u32 = unsafe { ::core::mem::transmute(EXTINT3) };
            EXTINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXTINT4: u32 = unsafe { ::core::mem::transmute(EXTINT4) };
            EXTINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EXTINT5: u32 = unsafe { ::core::mem::transmute(EXTINT5) };
            EXTINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EXTINT6: u32 = unsafe { ::core::mem::transmute(EXTINT6) };
            EXTINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EXTINT7: u32 = unsafe { ::core::mem::transmute(EXTINT7) };
            EXTINT7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EXTINT8: u32 = unsafe { ::core::mem::transmute(EXTINT8) };
            EXTINT8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EXTINT9: u32 = unsafe { ::core::mem::transmute(EXTINT9) };
            EXTINT9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EXTINT10: u32 = unsafe { ::core::mem::transmute(EXTINT10) };
            EXTINT10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EXTINT11: u32 = unsafe { ::core::mem::transmute(EXTINT11) };
            EXTINT11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EXTINT12: u32 = unsafe { ::core::mem::transmute(EXTINT12) };
            EXTINT12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EXTINT13: u32 = unsafe { ::core::mem::transmute(EXTINT13) };
            EXTINT13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EXTINT14: u32 = unsafe { ::core::mem::transmute(EXTINT14) };
            EXTINT14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EXTINT15: u32 = unsafe { ::core::mem::transmute(EXTINT15) };
            EXTINT15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_EIC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENSET_Type__bindgen_ty_2))
    );
}
impl EIC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EIC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl EIC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTINT15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EXTINT0: u32,
        EXTINT1: u32,
        EXTINT2: u32,
        EXTINT3: u32,
        EXTINT4: u32,
        EXTINT5: u32,
        EXTINT6: u32,
        EXTINT7: u32,
        EXTINT8: u32,
        EXTINT9: u32,
        EXTINT10: u32,
        EXTINT11: u32,
        EXTINT12: u32,
        EXTINT13: u32,
        EXTINT14: u32,
        EXTINT15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EXTINT0: u32 = unsafe { ::core::mem::transmute(EXTINT0) };
            EXTINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EXTINT1: u32 = unsafe { ::core::mem::transmute(EXTINT1) };
            EXTINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EXTINT2: u32 = unsafe { ::core::mem::transmute(EXTINT2) };
            EXTINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EXTINT3: u32 = unsafe { ::core::mem::transmute(EXTINT3) };
            EXTINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXTINT4: u32 = unsafe { ::core::mem::transmute(EXTINT4) };
            EXTINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EXTINT5: u32 = unsafe { ::core::mem::transmute(EXTINT5) };
            EXTINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EXTINT6: u32 = unsafe { ::core::mem::transmute(EXTINT6) };
            EXTINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EXTINT7: u32 = unsafe { ::core::mem::transmute(EXTINT7) };
            EXTINT7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EXTINT8: u32 = unsafe { ::core::mem::transmute(EXTINT8) };
            EXTINT8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EXTINT9: u32 = unsafe { ::core::mem::transmute(EXTINT9) };
            EXTINT9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EXTINT10: u32 = unsafe { ::core::mem::transmute(EXTINT10) };
            EXTINT10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EXTINT11: u32 = unsafe { ::core::mem::transmute(EXTINT11) };
            EXTINT11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EXTINT12: u32 = unsafe { ::core::mem::transmute(EXTINT12) };
            EXTINT12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EXTINT13: u32 = unsafe { ::core::mem::transmute(EXTINT13) };
            EXTINT13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EXTINT14: u32 = unsafe { ::core::mem::transmute(EXTINT14) };
            EXTINT14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EXTINT15: u32 = unsafe { ::core::mem::transmute(EXTINT15) };
            EXTINT15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_EIC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl EIC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_WAKEUP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_WAKEUP_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EIC_WAKEUP_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_WAKEUP_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_WAKEUP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_WAKEUP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_WAKEUP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_WAKEUP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_WAKEUP_Type__bindgen_ty_1))
    );
}
impl EIC_WAKEUP_Type__bindgen_ty_1 {
    #[inline]
    pub fn WAKEUPEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUPEN15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WAKEUPEN0: u32,
        WAKEUPEN1: u32,
        WAKEUPEN2: u32,
        WAKEUPEN3: u32,
        WAKEUPEN4: u32,
        WAKEUPEN5: u32,
        WAKEUPEN6: u32,
        WAKEUPEN7: u32,
        WAKEUPEN8: u32,
        WAKEUPEN9: u32,
        WAKEUPEN10: u32,
        WAKEUPEN11: u32,
        WAKEUPEN12: u32,
        WAKEUPEN13: u32,
        WAKEUPEN14: u32,
        WAKEUPEN15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WAKEUPEN0: u32 = unsafe { ::core::mem::transmute(WAKEUPEN0) };
            WAKEUPEN0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let WAKEUPEN1: u32 = unsafe { ::core::mem::transmute(WAKEUPEN1) };
            WAKEUPEN1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WAKEUPEN2: u32 = unsafe { ::core::mem::transmute(WAKEUPEN2) };
            WAKEUPEN2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WAKEUPEN3: u32 = unsafe { ::core::mem::transmute(WAKEUPEN3) };
            WAKEUPEN3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUPEN4: u32 = unsafe { ::core::mem::transmute(WAKEUPEN4) };
            WAKEUPEN4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WAKEUPEN5: u32 = unsafe { ::core::mem::transmute(WAKEUPEN5) };
            WAKEUPEN5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WAKEUPEN6: u32 = unsafe { ::core::mem::transmute(WAKEUPEN6) };
            WAKEUPEN6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let WAKEUPEN7: u32 = unsafe { ::core::mem::transmute(WAKEUPEN7) };
            WAKEUPEN7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let WAKEUPEN8: u32 = unsafe { ::core::mem::transmute(WAKEUPEN8) };
            WAKEUPEN8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let WAKEUPEN9: u32 = unsafe { ::core::mem::transmute(WAKEUPEN9) };
            WAKEUPEN9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let WAKEUPEN10: u32 = unsafe { ::core::mem::transmute(WAKEUPEN10) };
            WAKEUPEN10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WAKEUPEN11: u32 = unsafe { ::core::mem::transmute(WAKEUPEN11) };
            WAKEUPEN11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WAKEUPEN12: u32 = unsafe { ::core::mem::transmute(WAKEUPEN12) };
            WAKEUPEN12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WAKEUPEN13: u32 = unsafe { ::core::mem::transmute(WAKEUPEN13) };
            WAKEUPEN13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let WAKEUPEN14: u32 = unsafe { ::core::mem::transmute(WAKEUPEN14) };
            WAKEUPEN14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WAKEUPEN15: u32 = unsafe { ::core::mem::transmute(WAKEUPEN15) };
            WAKEUPEN15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_WAKEUP_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_EIC_WAKEUP_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EIC_WAKEUP_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_WAKEUP_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_WAKEUP_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_WAKEUP_Type__bindgen_ty_2))
    );
}
impl EIC_WAKEUP_Type__bindgen_ty_2 {
    #[inline]
    pub fn WAKEUPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEUPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WAKEUPEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let WAKEUPEN: u32 = unsafe { ::core::mem::transmute(WAKEUPEN) };
            WAKEUPEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_WAKEUP_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_WAKEUP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_WAKEUP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_WAKEUP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_WAKEUP_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_WAKEUP_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_WAKEUP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_WAKEUP_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_WAKEUP_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_WAKEUP_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_WAKEUP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_CONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_CONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_CONFIG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EIC_CONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_CONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_CONFIG_Type__bindgen_ty_1))
    );
}
impl EIC_CONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SENSE0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SENSE0: u32,
        FILTEN0: u32,
        SENSE1: u32,
        FILTEN1: u32,
        SENSE2: u32,
        FILTEN2: u32,
        SENSE3: u32,
        FILTEN3: u32,
        SENSE4: u32,
        FILTEN4: u32,
        SENSE5: u32,
        FILTEN5: u32,
        SENSE6: u32,
        FILTEN6: u32,
        SENSE7: u32,
        FILTEN7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SENSE0: u32 = unsafe { ::core::mem::transmute(SENSE0) };
            SENSE0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FILTEN0: u32 = unsafe { ::core::mem::transmute(FILTEN0) };
            FILTEN0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let SENSE1: u32 = unsafe { ::core::mem::transmute(SENSE1) };
            SENSE1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let FILTEN1: u32 = unsafe { ::core::mem::transmute(FILTEN1) };
            FILTEN1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let SENSE2: u32 = unsafe { ::core::mem::transmute(SENSE2) };
            SENSE2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FILTEN2: u32 = unsafe { ::core::mem::transmute(FILTEN2) };
            FILTEN2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let SENSE3: u32 = unsafe { ::core::mem::transmute(SENSE3) };
            SENSE3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FILTEN3: u32 = unsafe { ::core::mem::transmute(FILTEN3) };
            FILTEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let SENSE4: u32 = unsafe { ::core::mem::transmute(SENSE4) };
            SENSE4 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let FILTEN4: u32 = unsafe { ::core::mem::transmute(FILTEN4) };
            FILTEN4 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let SENSE5: u32 = unsafe { ::core::mem::transmute(SENSE5) };
            SENSE5 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let FILTEN5: u32 = unsafe { ::core::mem::transmute(FILTEN5) };
            FILTEN5 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let SENSE6: u32 = unsafe { ::core::mem::transmute(SENSE6) };
            SENSE6 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let FILTEN6: u32 = unsafe { ::core::mem::transmute(FILTEN6) };
            FILTEN6 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let SENSE7: u32 = unsafe { ::core::mem::transmute(SENSE7) };
            SENSE7 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let FILTEN7: u32 = unsafe { ::core::mem::transmute(FILTEN7) };
            FILTEN7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_CONFIG_Type() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CONFIG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_CONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CONFIG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_CONFIG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_CONFIG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EIC_CONFIG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Eic {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control"]
    pub CTRL: EIC_CTRL_Type,
    #[doc = "< \\brief Offset: 0x01 (R/   8) Status"]
    pub STATUS: EIC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W  8) Non-Maskable Interrupt Control"]
    pub NMICTRL: EIC_NMICTRL_Type,
    #[doc = "< \\brief Offset: 0x03 (R/W  8) Non-Maskable Interrupt Flag Status and Clear"]
    pub NMIFLAG: EIC_NMIFLAG_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Event Control"]
    pub EVCTRL: EIC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: EIC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Interrupt Enable Set"]
    pub INTENSET: EIC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: EIC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Wake-Up Enable"]
    pub WAKEUP: EIC_WAKEUP_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Configuration n"]
    pub CONFIG: [EIC_CONFIG_Type; 2usize],
}
#[test]
fn bindgen_test_layout_Eic() {
    assert_eq!(
        ::core::mem::size_of::<Eic>(),
        32usize,
        concat!("Size of: ", stringify!(Eic))
    );
    assert_eq!(
        ::core::mem::align_of::<Eic>(),
        4usize,
        concat!("Alignment of ", stringify!(Eic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).CTRL as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Eic), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).STATUS as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).NMICTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(NMICTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).NMIFLAG as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(NMIFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).EVCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).INTENCLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).INTENSET as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).INTFLAG as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).WAKEUP as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(WAKEUP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Eic>())).CONFIG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(CONFIG)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EVSYS_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EVSYS_CTRL_Type__bindgen_ty_1))
    );
}
impl EVSYS_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCLKREQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GCLKREQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, GCLKREQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let GCLKREQ: u8 = unsafe { ::core::mem::transmute(GCLKREQ) };
            GCLKREQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EVSYS_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EVSYS_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CHANNEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CHANNEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHANNEL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHANNEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHANNEL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHANNEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHANNEL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHANNEL_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_CHANNEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHANNEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SWEVT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWEVT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVGEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_EVGEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn PATH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PATH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EDGSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EDGSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHANNEL: u32,
        SWEVT: u32,
        EVGEN: u32,
        PATH: u32,
        EDGSEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CHANNEL: u32 = unsafe { ::core::mem::transmute(CHANNEL) };
            CHANNEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SWEVT: u32 = unsafe { ::core::mem::transmute(SWEVT) };
            SWEVT as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let EVGEN: u32 = unsafe { ::core::mem::transmute(EVGEN) };
            EVGEN as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let PATH: u32 = unsafe { ::core::mem::transmute(PATH) };
            PATH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 2u8, {
            let EDGSEL: u32 = unsafe { ::core::mem::transmute(EDGSEL) };
            EDGSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CHANNEL_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHANNEL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHANNEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHANNEL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_CHANNEL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CHANNEL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHANNEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CHANNEL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHANNEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_USER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_USER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_USER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_USER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_USER_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(EVSYS_USER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_USER_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(EVSYS_USER_Type__bindgen_ty_1))
    );
}
impl EVSYS_USER_Type__bindgen_ty_1 {
    #[inline]
    pub fn USER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_USER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_CHANNEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(USER: u16, CHANNEL: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let USER: u16 = unsafe { ::core::mem::transmute(USER) };
            USER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let CHANNEL: u16 = unsafe { ::core::mem::transmute(CHANNEL) };
            CHANNEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_USER_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_USER_Type>(),
        2usize,
        concat!("Size of: ", stringify!(EVSYS_USER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_USER_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(EVSYS_USER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_USER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_USER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_USER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_USER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CHSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CHSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_CHSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_CHSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn USRRDY0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USRRDY0: u32,
        USRRDY1: u32,
        USRRDY2: u32,
        USRRDY3: u32,
        USRRDY4: u32,
        USRRDY5: u32,
        USRRDY6: u32,
        USRRDY7: u32,
        CHBUSY0: u32,
        CHBUSY1: u32,
        CHBUSY2: u32,
        CHBUSY3: u32,
        CHBUSY4: u32,
        CHBUSY5: u32,
        CHBUSY6: u32,
        CHBUSY7: u32,
        USRRDY8: u32,
        USRRDY9: u32,
        USRRDY10: u32,
        USRRDY11: u32,
        CHBUSY8: u32,
        CHBUSY9: u32,
        CHBUSY10: u32,
        CHBUSY11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let USRRDY0: u32 = unsafe { ::core::mem::transmute(USRRDY0) };
            USRRDY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let USRRDY1: u32 = unsafe { ::core::mem::transmute(USRRDY1) };
            USRRDY1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let USRRDY2: u32 = unsafe { ::core::mem::transmute(USRRDY2) };
            USRRDY2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let USRRDY3: u32 = unsafe { ::core::mem::transmute(USRRDY3) };
            USRRDY3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let USRRDY4: u32 = unsafe { ::core::mem::transmute(USRRDY4) };
            USRRDY4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let USRRDY5: u32 = unsafe { ::core::mem::transmute(USRRDY5) };
            USRRDY5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let USRRDY6: u32 = unsafe { ::core::mem::transmute(USRRDY6) };
            USRRDY6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let USRRDY7: u32 = unsafe { ::core::mem::transmute(USRRDY7) };
            USRRDY7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CHBUSY0: u32 = unsafe { ::core::mem::transmute(CHBUSY0) };
            CHBUSY0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CHBUSY1: u32 = unsafe { ::core::mem::transmute(CHBUSY1) };
            CHBUSY1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CHBUSY2: u32 = unsafe { ::core::mem::transmute(CHBUSY2) };
            CHBUSY2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CHBUSY3: u32 = unsafe { ::core::mem::transmute(CHBUSY3) };
            CHBUSY3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let CHBUSY4: u32 = unsafe { ::core::mem::transmute(CHBUSY4) };
            CHBUSY4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let CHBUSY5: u32 = unsafe { ::core::mem::transmute(CHBUSY5) };
            CHBUSY5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CHBUSY6: u32 = unsafe { ::core::mem::transmute(CHBUSY6) };
            CHBUSY6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CHBUSY7: u32 = unsafe { ::core::mem::transmute(CHBUSY7) };
            CHBUSY7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let USRRDY8: u32 = unsafe { ::core::mem::transmute(USRRDY8) };
            USRRDY8 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let USRRDY9: u32 = unsafe { ::core::mem::transmute(USRRDY9) };
            USRRDY9 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let USRRDY10: u32 = unsafe { ::core::mem::transmute(USRRDY10) };
            USRRDY10 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let USRRDY11: u32 = unsafe { ::core::mem::transmute(USRRDY11) };
            USRRDY11 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CHBUSY8: u32 = unsafe { ::core::mem::transmute(CHBUSY8) };
            CHBUSY8 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CHBUSY9: u32 = unsafe { ::core::mem::transmute(CHBUSY9) };
            CHBUSY9 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CHBUSY10: u32 = unsafe { ::core::mem::transmute(CHBUSY10) };
            CHBUSY10 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let CHBUSY11: u32 = unsafe { ::core::mem::transmute(CHBUSY11) };
            CHBUSY11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_CHSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn USRRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDYp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDYp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSYp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSYp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USRRDY: u32,
        CHBUSY: u32,
        USRRDYp8: u32,
        CHBUSYp8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let USRRDY: u32 = unsafe { ::core::mem::transmute(USRRDY) };
            USRRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CHBUSY: u32 = unsafe { ::core::mem::transmute(CHBUSY) };
            CHBUSY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let USRRDYp8: u32 = unsafe { ::core::mem::transmute(USRRDYp8) };
            USRRDYp8 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let CHBUSYp8: u32 = unsafe { ::core::mem::transmute(CHBUSYp8) };
            CHBUSYp8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_CHSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CHSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CHSTATUS_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_CHSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
        OVR8: u32,
        OVR9: u32,
        OVR10: u32,
        OVR11: u32,
        EVD8: u32,
        EVD9: u32,
        EVD10: u32,
        EVD11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let OVR8: u32 = unsafe { ::core::mem::transmute(OVR8) };
            OVR8 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let OVR9: u32 = unsafe { ::core::mem::transmute(OVR9) };
            OVR9 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let OVR10: u32 = unsafe { ::core::mem::transmute(OVR10) };
            OVR10 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OVR11: u32 = unsafe { ::core::mem::transmute(OVR11) };
            OVR11 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EVD8: u32 = unsafe { ::core::mem::transmute(EVD8) };
            EVD8 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let EVD9: u32 = unsafe { ::core::mem::transmute(EVD9) };
            EVD9 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let EVD10: u32 = unsafe { ::core::mem::transmute(EVD10) };
            EVD10 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let EVD11: u32 = unsafe { ::core::mem::transmute(EVD11) };
            EVD11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OVRp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_OVRp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EVDp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EVDp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR: u32,
        EVD: u32,
        OVRp8: u32,
        EVDp8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let OVRp8: u32 = unsafe { ::core::mem::transmute(OVRp8) };
            OVRp8 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let EVDp8: u32 = unsafe { ::core::mem::transmute(EVDp8) };
            EVDp8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
        OVR8: u32,
        OVR9: u32,
        OVR10: u32,
        OVR11: u32,
        EVD8: u32,
        EVD9: u32,
        EVD10: u32,
        EVD11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let OVR8: u32 = unsafe { ::core::mem::transmute(OVR8) };
            OVR8 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let OVR9: u32 = unsafe { ::core::mem::transmute(OVR9) };
            OVR9 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let OVR10: u32 = unsafe { ::core::mem::transmute(OVR10) };
            OVR10 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OVR11: u32 = unsafe { ::core::mem::transmute(OVR11) };
            OVR11 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EVD8: u32 = unsafe { ::core::mem::transmute(EVD8) };
            EVD8 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let EVD9: u32 = unsafe { ::core::mem::transmute(EVD9) };
            EVD9 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let EVD10: u32 = unsafe { ::core::mem::transmute(EVD10) };
            EVD10 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let EVD11: u32 = unsafe { ::core::mem::transmute(EVD11) };
            EVD11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OVRp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_OVRp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EVDp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EVDp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR: u32,
        EVD: u32,
        OVRp8: u32,
        EVDp8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let OVRp8: u32 = unsafe { ::core::mem::transmute(OVRp8) };
            OVRp8 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let EVDp8: u32 = unsafe { ::core::mem::transmute(EVDp8) };
            EVDp8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
        OVR8: u32,
        OVR9: u32,
        OVR10: u32,
        OVR11: u32,
        EVD8: u32,
        EVD9: u32,
        EVD10: u32,
        EVD11: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let OVR8: u32 = unsafe { ::core::mem::transmute(OVR8) };
            OVR8 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let OVR9: u32 = unsafe { ::core::mem::transmute(OVR9) };
            OVR9 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let OVR10: u32 = unsafe { ::core::mem::transmute(OVR10) };
            OVR10 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OVR11: u32 = unsafe { ::core::mem::transmute(OVR11) };
            OVR11 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EVD8: u32 = unsafe { ::core::mem::transmute(EVD8) };
            EVD8 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let EVD9: u32 = unsafe { ::core::mem::transmute(EVD9) };
            EVD9 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let EVD10: u32 = unsafe { ::core::mem::transmute(EVD10) };
            EVD10 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let EVD11: u32 = unsafe { ::core::mem::transmute(EVD11) };
            EVD11 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OVRp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_OVRp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EVDp8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EVDp8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR: u32,
        EVD: u32,
        OVRp8: u32,
        EVDp8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let OVRp8: u32 = unsafe { ::core::mem::transmute(OVRp8) };
            OVRp8 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let EVDp8: u32 = unsafe { ::core::mem::transmute(EVDp8) };
            EVDp8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EVSYS_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Evsys {
    #[doc = "< \\brief Offset: 0x00 ( /W  8) Control"]
    pub CTRL: EVSYS_CTRL_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Channel"]
    pub CHANNEL: EVSYS_CHANNEL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 16) User Multiplexer"]
    pub USER: EVSYS_USER_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x0C (R/  32) Channel Status"]
    pub CHSTATUS: EVSYS_CHSTATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: EVSYS_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: EVSYS_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: EVSYS_INTFLAG_Type,
}
#[test]
fn bindgen_test_layout_Evsys() {
    assert_eq!(
        ::core::mem::size_of::<Evsys>(),
        28usize,
        concat!("Size of: ", stringify!(Evsys))
    );
    assert_eq!(
        ::core::mem::align_of::<Evsys>(),
        4usize,
        concat!("Alignment of ", stringify!(Evsys))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).CHANNEL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CHANNEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).USER as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(USER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).Reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).CHSTATUS as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CHSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).INTENCLR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).INTENSET as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Evsys>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTFLAG)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_GCLK_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_CTRL_Type__bindgen_ty_1))
    );
}
impl GCLK_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_GCLK_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_STATUS_Type__bindgen_ty_1))
    );
}
impl GCLK_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_CLKCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_CLKCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_CLKCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_GCLK_CLKCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_CLKCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(GCLK_CLKCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CLKCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(GCLK_CLKCTRL_Type__bindgen_ty_1))
    );
}
impl GCLK_CLKCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn GEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_GEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ID: u16,
        GEN: u16,
        CLKEN: u16,
        WRTLOCK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u16 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let GEN: u16 = unsafe { ::core::mem::transmute(GEN) };
            GEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CLKEN: u16 = unsafe { ::core::mem::transmute(CLKEN) };
            CLKEN as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WRTLOCK: u16 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_CLKCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_CLKCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(GCLK_CLKCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CLKCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(GCLK_CLKCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_CLKCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CLKCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_CLKCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CLKCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_GENCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_GENCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_GENCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_GCLK_GENCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENCTRL_Type__bindgen_ty_1))
    );
}
impl GCLK_GENCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn GENEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OOV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OOV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIVSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DIVSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ID: u32,
        SRC: u32,
        GENEN: u32,
        IDC: u32,
        OOV: u32,
        OE: u32,
        DIVSEL: u32,
        RUNSTDBY: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u32 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let GENEN: u32 = unsafe { ::core::mem::transmute(GENEN) };
            GENEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let IDC: u32 = unsafe { ::core::mem::transmute(IDC) };
            IDC as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let OOV: u32 = unsafe { ::core::mem::transmute(OOV) };
            OOV as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let OE: u32 = unsafe { ::core::mem::transmute(OE) };
            OE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let DIVSEL: u32 = unsafe { ::core::mem::transmute(DIVSEL) };
            DIVSEL as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_GENCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_GENCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_GENCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_GENDIV_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_GENDIV_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_GENDIV_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_GCLK_GENDIV_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENDIV_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENDIV_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENDIV_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENDIV_Type__bindgen_ty_1))
    );
}
impl GCLK_GENDIV_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: u32, DIV: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u32 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let DIV: u32 = unsafe { ::core::mem::transmute(DIV) };
            DIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_GENDIV_Type() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENDIV_Type>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENDIV_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENDIV_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENDIV_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_GENDIV_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENDIV_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GCLK_GENDIV_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENDIV_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Gclk {
    #[doc = "< \\brief Offset: 0x0 (R/W  8) Control"]
    pub CTRL: GCLK_CTRL_Type,
    #[doc = "< \\brief Offset: 0x1 (R/   8) Status"]
    pub STATUS: GCLK_STATUS_Type,
    #[doc = "< \\brief Offset: 0x2 (R/W 16) Generic Clock Control"]
    pub CLKCTRL: GCLK_CLKCTRL_Type,
    #[doc = "< \\brief Offset: 0x4 (R/W 32) Generic Clock Generator Control"]
    pub GENCTRL: GCLK_GENCTRL_Type,
    #[doc = "< \\brief Offset: 0x8 (R/W 32) Generic Clock Generator Division"]
    pub GENDIV: GCLK_GENDIV_Type,
}
#[test]
fn bindgen_test_layout_Gclk() {
    assert_eq!(
        ::core::mem::size_of::<Gclk>(),
        12usize,
        concat!("Size of: ", stringify!(Gclk))
    );
    assert_eq!(
        ::core::mem::align_of::<Gclk>(),
        4usize,
        concat!("Alignment of ", stringify!(Gclk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Gclk>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Gclk>())).STATUS as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Gclk>())).CLKCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(CLKCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Gclk>())).GENCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(GENCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Gclk>())).GENDIV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(GENDIV)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HMATRIXB_PRAS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_HMATRIXB_PRAS_Type() {
    assert_eq!(
        ::core::mem::size_of::<HMATRIXB_PRAS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(HMATRIXB_PRAS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<HMATRIXB_PRAS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(HMATRIXB_PRAS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HMATRIXB_PRAS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMATRIXB_PRAS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HMATRIXB_PRBS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_HMATRIXB_PRBS_Type() {
    assert_eq!(
        ::core::mem::size_of::<HMATRIXB_PRBS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(HMATRIXB_PRBS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<HMATRIXB_PRBS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(HMATRIXB_PRBS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HMATRIXB_PRBS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMATRIXB_PRBS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HMATRIXB_SFR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: HMATRIXB_SFR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HMATRIXB_SFR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_HMATRIXB_SFR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<HMATRIXB_SFR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(HMATRIXB_SFR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<HMATRIXB_SFR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(HMATRIXB_SFR_Type__bindgen_ty_1))
    );
}
impl HMATRIXB_SFR_Type__bindgen_ty_1 {
    #[inline]
    pub fn SFR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SFR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SFR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SFR: u32 = unsafe { ::core::mem::transmute(SFR) };
            SFR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_HMATRIXB_SFR_Type() {
    assert_eq!(
        ::core::mem::size_of::<HMATRIXB_SFR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(HMATRIXB_SFR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<HMATRIXB_SFR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(HMATRIXB_SFR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HMATRIXB_SFR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMATRIXB_SFR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HMATRIXB_SFR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMATRIXB_SFR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HmatrixbPrs {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) Priority A for Slave"]
    pub PRAS: HMATRIXB_PRAS_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) Priority B for Slave"]
    pub PRBS: HMATRIXB_PRBS_Type,
}
#[test]
fn bindgen_test_layout_HmatrixbPrs() {
    assert_eq!(
        ::core::mem::size_of::<HmatrixbPrs>(),
        8usize,
        concat!("Size of: ", stringify!(HmatrixbPrs))
    );
    assert_eq!(
        ::core::mem::align_of::<HmatrixbPrs>(),
        4usize,
        concat!("Alignment of ", stringify!(HmatrixbPrs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmatrixbPrs>())).PRAS as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HmatrixbPrs),
            "::",
            stringify!(PRAS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HmatrixbPrs>())).PRBS as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HmatrixbPrs),
            "::",
            stringify!(PRBS)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Hmatrixb {
    pub Reserved1: [RoReg8; 128usize],
    #[doc = "< \\brief Offset: 0x080 HmatrixbPrs groups"]
    pub Prs: [HmatrixbPrs; 16usize],
    pub Reserved2: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x110 (R/W 32) Special Function"]
    pub SFR: [HMATRIXB_SFR_Type; 16usize],
}
#[test]
fn bindgen_test_layout_Hmatrixb() {
    assert_eq!(
        ::core::mem::size_of::<Hmatrixb>(),
        336usize,
        concat!("Size of: ", stringify!(Hmatrixb))
    );
    assert_eq!(
        ::core::mem::align_of::<Hmatrixb>(),
        4usize,
        concat!("Alignment of ", stringify!(Hmatrixb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hmatrixb>())).Reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Hmatrixb),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hmatrixb>())).Prs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Hmatrixb),
            "::",
            stringify!(Prs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hmatrixb>())).Reserved2 as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Hmatrixb),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hmatrixb>())).SFR as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Hmatrixb),
            "::",
            stringify!(SFR)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_CTRLA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct I2S_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(I2S_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(I2S_CTRLA_Type__bindgen_ty_1))
    );
}
impl I2S_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CKEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CKEN1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKEN1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SEREN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SEREN1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        CKEN0: u8,
        CKEN1: u8,
        SEREN0: u8,
        SEREN1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CKEN0: u8 = unsafe { ::core::mem::transmute(CKEN0) };
            CKEN0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CKEN1: u8 = unsafe { ::core::mem::transmute(CKEN1) };
            CKEN1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SEREN0: u8 = unsafe { ::core::mem::transmute(SEREN0) };
            SEREN0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SEREN1: u8 = unsafe { ::core::mem::transmute(SEREN1) };
            SEREN1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct I2S_CTRLA_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_CTRLA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_CTRLA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(I2S_CTRLA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_CTRLA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(I2S_CTRLA_Type__bindgen_ty_2))
    );
}
impl I2S_CTRLA_Type__bindgen_ty_2 {
    #[inline]
    pub fn CKEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CKEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SEREN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKEN: u8, SEREN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CKEN: u8 = unsafe { ::core::mem::transmute(CKEN) };
            CKEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let SEREN: u8 = unsafe { ::core::mem::transmute(SEREN) };
            SEREN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(I2S_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(I2S_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_CTRLA_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_CTRLA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_CLKCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_CLKCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_CLKCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_CLKCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_CLKCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_CLKCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_CLKCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_CLKCTRL_Type__bindgen_ty_1))
    );
}
impl I2S_CLKCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SLOTSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NBSLOTS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_NBSLOTS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FSWIDTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FSWIDTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BITDELAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BITDELAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FSSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FSSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FSINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FSINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SCKSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCKSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCKSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCKSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCKEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCKEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCKDIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MCKDIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MCKOUTDIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MCKOUTDIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn FSOUTINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FSOUTINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SCKOUTINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCKOUTINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCKOUTINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCKOUTINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SLOTSIZE: u32,
        NBSLOTS: u32,
        FSWIDTH: u32,
        BITDELAY: u32,
        FSSEL: u32,
        FSINV: u32,
        SCKSEL: u32,
        MCKSEL: u32,
        MCKEN: u32,
        MCKDIV: u32,
        MCKOUTDIV: u32,
        FSOUTINV: u32,
        SCKOUTINV: u32,
        MCKOUTINV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SLOTSIZE: u32 = unsafe { ::core::mem::transmute(SLOTSIZE) };
            SLOTSIZE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let NBSLOTS: u32 = unsafe { ::core::mem::transmute(NBSLOTS) };
            NBSLOTS as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let FSWIDTH: u32 = unsafe { ::core::mem::transmute(FSWIDTH) };
            FSWIDTH as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BITDELAY: u32 = unsafe { ::core::mem::transmute(BITDELAY) };
            BITDELAY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let FSSEL: u32 = unsafe { ::core::mem::transmute(FSSEL) };
            FSSEL as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FSINV: u32 = unsafe { ::core::mem::transmute(FSINV) };
            FSINV as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SCKSEL: u32 = unsafe { ::core::mem::transmute(SCKSEL) };
            SCKSEL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MCKSEL: u32 = unsafe { ::core::mem::transmute(MCKSEL) };
            MCKSEL as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MCKEN: u32 = unsafe { ::core::mem::transmute(MCKEN) };
            MCKEN as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let MCKDIV: u32 = unsafe { ::core::mem::transmute(MCKDIV) };
            MCKDIV as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let MCKOUTDIV: u32 = unsafe { ::core::mem::transmute(MCKOUTDIV) };
            MCKOUTDIV as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let FSOUTINV: u32 = unsafe { ::core::mem::transmute(FSOUTINV) };
            FSOUTINV as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let SCKOUTINV: u32 = unsafe { ::core::mem::transmute(SCKOUTINV) };
            SCKOUTINV as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let MCKOUTINV: u32 = unsafe { ::core::mem::transmute(MCKOUTINV) };
            MCKOUTINV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_CLKCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_CLKCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_CLKCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_CLKCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_CLKCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_CLKCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_CLKCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_CLKCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_CLKCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENCLR_Type__bindgen_ty_1))
    );
}
impl I2S_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn RXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY0: u16,
        RXRDY1: u16,
        RXOR0: u16,
        RXOR1: u16,
        TXRDY0: u16,
        TXRDY1: u16,
        TXUR0: u16,
        TXUR1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RXRDY0: u16 = unsafe { ::core::mem::transmute(RXRDY0) };
            RXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RXRDY1: u16 = unsafe { ::core::mem::transmute(RXRDY1) };
            RXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXOR0: u16 = unsafe { ::core::mem::transmute(RXOR0) };
            RXOR0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXOR1: u16 = unsafe { ::core::mem::transmute(RXOR1) };
            RXOR1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TXRDY0: u16 = unsafe { ::core::mem::transmute(TXRDY0) };
            TXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TXRDY1: u16 = unsafe { ::core::mem::transmute(TXRDY1) };
            TXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TXUR0: u16 = unsafe { ::core::mem::transmute(TXUR0) };
            TXUR0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TXUR1: u16 = unsafe { ::core::mem::transmute(TXUR1) };
            TXUR1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENCLR_Type__bindgen_ty_2))
    );
}
impl I2S_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn RXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY: u16,
        RXOR: u16,
        TXRDY: u16,
        TXUR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let RXRDY: u16 = unsafe { ::core::mem::transmute(RXRDY) };
            RXRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RXOR: u16 = unsafe { ::core::mem::transmute(RXOR) };
            RXOR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let TXRDY: u16 = unsafe { ::core::mem::transmute(TXRDY) };
            TXRDY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TXUR: u16 = unsafe { ::core::mem::transmute(TXUR) };
            TXUR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENSET_Type__bindgen_ty_1))
    );
}
impl I2S_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn RXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY0: u16,
        RXRDY1: u16,
        RXOR0: u16,
        RXOR1: u16,
        TXRDY0: u16,
        TXRDY1: u16,
        TXUR0: u16,
        TXUR1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RXRDY0: u16 = unsafe { ::core::mem::transmute(RXRDY0) };
            RXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RXRDY1: u16 = unsafe { ::core::mem::transmute(RXRDY1) };
            RXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXOR0: u16 = unsafe { ::core::mem::transmute(RXOR0) };
            RXOR0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXOR1: u16 = unsafe { ::core::mem::transmute(RXOR1) };
            RXOR1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TXRDY0: u16 = unsafe { ::core::mem::transmute(TXRDY0) };
            TXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TXRDY1: u16 = unsafe { ::core::mem::transmute(TXRDY1) };
            TXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TXUR0: u16 = unsafe { ::core::mem::transmute(TXUR0) };
            TXUR0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TXUR1: u16 = unsafe { ::core::mem::transmute(TXUR1) };
            TXUR1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENSET_Type__bindgen_ty_2))
    );
}
impl I2S_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn RXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY: u16,
        RXOR: u16,
        TXRDY: u16,
        TXUR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let RXRDY: u16 = unsafe { ::core::mem::transmute(RXRDY) };
            RXRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RXOR: u16 = unsafe { ::core::mem::transmute(RXOR) };
            RXOR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let TXRDY: u16 = unsafe { ::core::mem::transmute(TXRDY) };
            TXRDY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TXUR: u16 = unsafe { ::core::mem::transmute(TXUR) };
            TXUR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTFLAG_Type__bindgen_ty_1))
    );
}
impl I2S_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn RXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY0: u16,
        RXRDY1: u16,
        RXOR0: u16,
        RXOR1: u16,
        TXRDY0: u16,
        TXRDY1: u16,
        TXUR0: u16,
        TXUR1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RXRDY0: u16 = unsafe { ::core::mem::transmute(RXRDY0) };
            RXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RXRDY1: u16 = unsafe { ::core::mem::transmute(RXRDY1) };
            RXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXOR0: u16 = unsafe { ::core::mem::transmute(RXOR0) };
            RXOR0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXOR1: u16 = unsafe { ::core::mem::transmute(RXOR1) };
            RXOR1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TXRDY0: u16 = unsafe { ::core::mem::transmute(TXRDY0) };
            TXRDY0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TXRDY1: u16 = unsafe { ::core::mem::transmute(TXRDY1) };
            TXRDY1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TXUR0: u16 = unsafe { ::core::mem::transmute(TXUR0) };
            TXUR0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TXUR1: u16 = unsafe { ::core::mem::transmute(TXUR1) };
            TXUR1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTFLAG_Type__bindgen_ty_2))
    );
}
impl I2S_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn RXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXOR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RXOR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXRDY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXRDY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXUR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_TXUR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RXRDY: u16,
        RXOR: u16,
        TXRDY: u16,
        TXUR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let RXRDY: u16 = unsafe { ::core::mem::transmute(RXRDY) };
            RXRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RXOR: u16 = unsafe { ::core::mem::transmute(RXOR) };
            RXOR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let TXRDY: u16 = unsafe { ::core::mem::transmute(TXRDY) };
            TXRDY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TXUR: u16 = unsafe { ::core::mem::transmute(TXUR) };
            TXUR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SYNCBUSY_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SYNCBUSY_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl I2S_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CKEN0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CKEN0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CKEN1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CKEN1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEREN0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEREN1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DATA0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DATA0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DATA1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DATA1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        CKEN0: u16,
        CKEN1: u16,
        SEREN0: u16,
        SEREN1: u16,
        DATA0: u16,
        DATA1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CKEN0: u16 = unsafe { ::core::mem::transmute(CKEN0) };
            CKEN0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CKEN1: u16 = unsafe { ::core::mem::transmute(CKEN1) };
            CKEN1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SEREN0: u16 = unsafe { ::core::mem::transmute(SEREN0) };
            SEREN0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SEREN1: u16 = unsafe { ::core::mem::transmute(SEREN1) };
            SEREN1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DATA0: u16 = unsafe { ::core::mem::transmute(DATA0) };
            DATA0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DATA1: u16 = unsafe { ::core::mem::transmute(DATA1) };
            DATA1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SYNCBUSY_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SYNCBUSY_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_SYNCBUSY_Type__bindgen_ty_2))
    );
}
impl I2S_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn CKEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CKEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SEREN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_SEREN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DATA(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CKEN: u16,
        SEREN: u16,
        DATA: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CKEN: u16 = unsafe { ::core::mem::transmute(CKEN) };
            CKEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let SEREN: u16 = unsafe { ::core::mem::transmute(SEREN) };
            SEREN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let DATA: u16 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SYNCBUSY_Type>(),
        2usize,
        concat!("Size of: ", stringify!(I2S_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SYNCBUSY_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(I2S_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SYNCBUSY_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_SERCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_SERCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: I2S_SERCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_SERCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_SERCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SERCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_SERCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SERCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_SERCTRL_Type__bindgen_ty_1))
    );
}
impl I2S_SERCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SERMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SERMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXDEFAULT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TXDEFAULT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TXSAME(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TXSAME(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTADJ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTADJ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DATASIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DATASIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WORDADJ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WORDADJ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXTEND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EXTEND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BITREV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BITREV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLOTDIS7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MONO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MONO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXLOOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXLOOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SERMODE: u32,
        TXDEFAULT: u32,
        TXSAME: u32,
        CLKSEL: u32,
        SLOTADJ: u32,
        DATASIZE: u32,
        WORDADJ: u32,
        EXTEND: u32,
        BITREV: u32,
        SLOTDIS0: u32,
        SLOTDIS1: u32,
        SLOTDIS2: u32,
        SLOTDIS3: u32,
        SLOTDIS4: u32,
        SLOTDIS5: u32,
        SLOTDIS6: u32,
        SLOTDIS7: u32,
        MONO: u32,
        DMA: u32,
        RXLOOP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SERMODE: u32 = unsafe { ::core::mem::transmute(SERMODE) };
            SERMODE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TXDEFAULT: u32 = unsafe { ::core::mem::transmute(TXDEFAULT) };
            TXDEFAULT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TXSAME: u32 = unsafe { ::core::mem::transmute(TXSAME) };
            TXSAME as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CLKSEL: u32 = unsafe { ::core::mem::transmute(CLKSEL) };
            CLKSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SLOTADJ: u32 = unsafe { ::core::mem::transmute(SLOTADJ) };
            SLOTADJ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let DATASIZE: u32 = unsafe { ::core::mem::transmute(DATASIZE) };
            DATASIZE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WORDADJ: u32 = unsafe { ::core::mem::transmute(WORDADJ) };
            WORDADJ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let EXTEND: u32 = unsafe { ::core::mem::transmute(EXTEND) };
            EXTEND as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let BITREV: u32 = unsafe { ::core::mem::transmute(BITREV) };
            BITREV as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let SLOTDIS0: u32 = unsafe { ::core::mem::transmute(SLOTDIS0) };
            SLOTDIS0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let SLOTDIS1: u32 = unsafe { ::core::mem::transmute(SLOTDIS1) };
            SLOTDIS1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SLOTDIS2: u32 = unsafe { ::core::mem::transmute(SLOTDIS2) };
            SLOTDIS2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let SLOTDIS3: u32 = unsafe { ::core::mem::transmute(SLOTDIS3) };
            SLOTDIS3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let SLOTDIS4: u32 = unsafe { ::core::mem::transmute(SLOTDIS4) };
            SLOTDIS4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let SLOTDIS5: u32 = unsafe { ::core::mem::transmute(SLOTDIS5) };
            SLOTDIS5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let SLOTDIS6: u32 = unsafe { ::core::mem::transmute(SLOTDIS6) };
            SLOTDIS6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SLOTDIS7: u32 = unsafe { ::core::mem::transmute(SLOTDIS7) };
            SLOTDIS7 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let MONO: u32 = unsafe { ::core::mem::transmute(MONO) };
            MONO as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let DMA: u32 = unsafe { ::core::mem::transmute(DMA) };
            DMA as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let RXLOOP: u32 = unsafe { ::core::mem::transmute(RXLOOP) };
            RXLOOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_SERCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_I2S_SERCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SERCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_SERCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SERCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_SERCTRL_Type__bindgen_ty_2))
    );
}
impl I2S_SERCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn SLOTDIS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SLOTDIS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SLOTDIS: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let SLOTDIS: u32 = unsafe { ::core::mem::transmute(SLOTDIS) };
            SLOTDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_SERCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_SERCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_SERCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_SERCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_SERCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SERCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SERCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SERCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SERCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_SERCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_SERCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union I2S_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: I2S_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct I2S_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_I2S_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<I2S_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_DATA_Type__bindgen_ty_1))
    );
}
impl I2S_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_I2S_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<I2S_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(I2S_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<I2S_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(I2S_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2S_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2S_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct I2s {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: I2S_CTRLA_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Clock Unit n Control"]
    pub CLKCTRL: [I2S_CLKCTRL_Type; 2usize],
    #[doc = "< \\brief Offset: 0x0C (R/W 16) Interrupt Enable Clear"]
    pub INTENCLR: I2S_INTENCLR_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 16) Interrupt Enable Set"]
    pub INTENSET: I2S_INTENSET_Type,
    pub Reserved3: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x14 (R/W 16) Interrupt Flag Status and Clear"]
    pub INTFLAG: I2S_INTFLAG_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x18 (R/  16) Synchronization Status"]
    pub SYNCBUSY: I2S_SYNCBUSY_Type,
    pub Reserved5: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Serializer n Control"]
    pub SERCTRL: [I2S_SERCTRL_Type; 2usize],
    pub Reserved6: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x30 (R/W 32) Data n"]
    pub DATA: [I2S_DATA_Type; 2usize],
}
#[test]
fn bindgen_test_layout_I2s() {
    assert_eq!(
        ::core::mem::size_of::<I2s>(),
        56usize,
        concat!("Size of: ", stringify!(I2s))
    );
    assert_eq!(
        ::core::mem::align_of::<I2s>(),
        4usize,
        concat!("Alignment of ", stringify!(I2s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).CLKCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(CLKCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).INTENCLR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).INTENSET as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved3 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).INTFLAG as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved4 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).SYNCBUSY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved5 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).SERCTRL as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(SERCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).Reserved6 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(I2s),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2s>())).DATA as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(I2s), "::", stringify!(DATA))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_POSITION_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_POSITION_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_POSITION_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_MTB_POSITION_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_POSITION_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_POSITION_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_POSITION_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_POSITION_Type__bindgen_ty_1))
    );
}
impl MTB_POSITION_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POINTER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_POINTER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WRAP: u32, POINTER: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WRAP: u32 = unsafe { ::core::mem::transmute(WRAP) };
            WRAP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let POINTER: u32 = unsafe { ::core::mem::transmute(POINTER) };
            POINTER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_POSITION_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_POSITION_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_POSITION_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_POSITION_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_POSITION_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_POSITION_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_POSITION_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_POSITION_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_POSITION_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_MASTER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_MASTER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_MASTER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_MTB_MASTER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_MASTER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_MASTER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_MASTER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_MASTER_Type__bindgen_ty_1))
    );
}
impl MTB_MASTER_Type__bindgen_ty_1 {
    #[inline]
    pub fn MASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTARTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSTARTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTOPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSTOPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SFRWPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SFRWPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RAMPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALTREQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HALTREQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MASK: u32,
        TSTARTEN: u32,
        TSTOPEN: u32,
        SFRWPRIV: u32,
        RAMPRIV: u32,
        HALTREQ: u32,
        EN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MASK: u32 = unsafe { ::core::mem::transmute(MASK) };
            MASK as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TSTARTEN: u32 = unsafe { ::core::mem::transmute(TSTARTEN) };
            TSTARTEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TSTOPEN: u32 = unsafe { ::core::mem::transmute(TSTOPEN) };
            TSTOPEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SFRWPRIV: u32 = unsafe { ::core::mem::transmute(SFRWPRIV) };
            SFRWPRIV as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RAMPRIV: u32 = unsafe { ::core::mem::transmute(RAMPRIV) };
            RAMPRIV as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HALTREQ: u32 = unsafe { ::core::mem::transmute(HALTREQ) };
            HALTREQ as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let EN: u32 = unsafe { ::core::mem::transmute(EN) };
            EN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_MASTER_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_MASTER_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_MASTER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_MASTER_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_MASTER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_MASTER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_MASTER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_MASTER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_MASTER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_FLOW_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_FLOW_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_FLOW_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_MTB_FLOW_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_FLOW_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_FLOW_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_FLOW_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_FLOW_Type__bindgen_ty_1))
    );
}
impl MTB_FLOW_Type__bindgen_ty_1 {
    #[inline]
    pub fn AUTOSTOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTOSTOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AUTOHALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTOHALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WATERMARK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_WATERMARK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AUTOSTOP: u32,
        AUTOHALT: u32,
        WATERMARK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AUTOSTOP: u32 = unsafe { ::core::mem::transmute(AUTOSTOP) };
            AUTOSTOP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AUTOHALT: u32 = unsafe { ::core::mem::transmute(AUTOHALT) };
            AUTOHALT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let WATERMARK: u32 = unsafe { ::core::mem::transmute(WATERMARK) };
            WATERMARK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_FLOW_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_FLOW_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_FLOW_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_FLOW_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_FLOW_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_FLOW_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_FLOW_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_FLOW_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_FLOW_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_BASE_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_BASE_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_BASE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_BASE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_BASE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_BASE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_BASE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_BASE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_ITCTRL_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_ITCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_ITCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_ITCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_ITCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_ITCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_ITCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_ITCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CLAIMSET_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CLAIMSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CLAIMSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CLAIMSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CLAIMSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CLAIMSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CLAIMSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CLAIMSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CLAIMCLR_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CLAIMCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CLAIMCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CLAIMCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CLAIMCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CLAIMCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CLAIMCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CLAIMCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_LOCKACCESS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_LOCKACCESS_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_LOCKACCESS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_LOCKACCESS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_LOCKACCESS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_LOCKACCESS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_LOCKACCESS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_LOCKACCESS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_LOCKSTATUS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_LOCKSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_LOCKSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_LOCKSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_LOCKSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_LOCKSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_LOCKSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_LOCKSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_AUTHSTATUS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_AUTHSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_AUTHSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_AUTHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_AUTHSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_AUTHSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_AUTHSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_AUTHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVARCH_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVARCH_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVARCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVARCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVARCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVARCH_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_DEVARCH_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVARCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVID_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVID_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVID_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVID_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVID_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_DEVID_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVTYPE_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVTYPE_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVTYPE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVTYPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVTYPE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVTYPE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_DEVTYPE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVTYPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID4_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID4_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID4_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID4_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID5_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID5_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID5_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID5_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID5_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID6_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID6_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID6_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID6_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID6_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID6_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID6_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID6_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID7_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID7_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID7_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID7_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID7_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID7_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID7_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID7_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID0_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID0_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID0_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID0_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID1_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID1_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID1_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID2_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID2_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID2_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID2_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID3_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID3_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_PID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID3_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_PID3_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID0_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID0_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID0_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CID0_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID1_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID1_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CID1_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID2_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID2_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID2_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CID2_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID3_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID3_Type() {
    assert_eq!(
        ::core::mem::size_of::<MTB_CID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID3_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MTB_CID3_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Mtb {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) MTB Position"]
    pub POSITION: MTB_POSITION_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) MTB Master"]
    pub MASTER: MTB_MASTER_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W 32) MTB Flow"]
    pub FLOW: MTB_FLOW_Type,
    #[doc = "< \\brief Offset: 0x00C (R/  32) MTB Base"]
    pub BASE: MTB_BASE_Type,
    pub Reserved1: [RoReg8; 3824usize],
    #[doc = "< \\brief Offset: 0xF00 (R/W 32) MTB Integration Mode Control"]
    pub ITCTRL: MTB_ITCTRL_Type,
    pub Reserved2: [RoReg8; 156usize],
    #[doc = "< \\brief Offset: 0xFA0 (R/W 32) MTB Claim Set"]
    pub CLAIMSET: MTB_CLAIMSET_Type,
    #[doc = "< \\brief Offset: 0xFA4 (R/W 32) MTB Claim Clear"]
    pub CLAIMCLR: MTB_CLAIMCLR_Type,
    pub Reserved3: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0xFB0 (R/W 32) MTB Lock Access"]
    pub LOCKACCESS: MTB_LOCKACCESS_Type,
    #[doc = "< \\brief Offset: 0xFB4 (R/  32) MTB Lock Status"]
    pub LOCKSTATUS: MTB_LOCKSTATUS_Type,
    #[doc = "< \\brief Offset: 0xFB8 (R/  32) MTB Authentication Status"]
    pub AUTHSTATUS: MTB_AUTHSTATUS_Type,
    #[doc = "< \\brief Offset: 0xFBC (R/  32) MTB Device Architecture"]
    pub DEVARCH: MTB_DEVARCH_Type,
    pub Reserved4: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0xFC8 (R/  32) MTB Device Configuration"]
    pub DEVID: MTB_DEVID_Type,
    #[doc = "< \\brief Offset: 0xFCC (R/  32) MTB Device Type"]
    pub DEVTYPE: MTB_DEVTYPE_Type,
    #[doc = "< \\brief Offset: 0xFD0 (R/  32) CoreSight"]
    pub PID4: MTB_PID4_Type,
    #[doc = "< \\brief Offset: 0xFD4 (R/  32) CoreSight"]
    pub PID5: MTB_PID5_Type,
    #[doc = "< \\brief Offset: 0xFD8 (R/  32) CoreSight"]
    pub PID6: MTB_PID6_Type,
    #[doc = "< \\brief Offset: 0xFDC (R/  32) CoreSight"]
    pub PID7: MTB_PID7_Type,
    #[doc = "< \\brief Offset: 0xFE0 (R/  32) CoreSight"]
    pub PID0: MTB_PID0_Type,
    #[doc = "< \\brief Offset: 0xFE4 (R/  32) CoreSight"]
    pub PID1: MTB_PID1_Type,
    #[doc = "< \\brief Offset: 0xFE8 (R/  32) CoreSight"]
    pub PID2: MTB_PID2_Type,
    #[doc = "< \\brief Offset: 0xFEC (R/  32) CoreSight"]
    pub PID3: MTB_PID3_Type,
    #[doc = "< \\brief Offset: 0xFF0 (R/  32) CoreSight"]
    pub CID0: MTB_CID0_Type,
    #[doc = "< \\brief Offset: 0xFF4 (R/  32) CoreSight"]
    pub CID1: MTB_CID1_Type,
    #[doc = "< \\brief Offset: 0xFF8 (R/  32) CoreSight"]
    pub CID2: MTB_CID2_Type,
    #[doc = "< \\brief Offset: 0xFFC (R/  32) CoreSight"]
    pub CID3: MTB_CID3_Type,
}
#[test]
fn bindgen_test_layout_Mtb() {
    assert_eq!(
        ::core::mem::size_of::<Mtb>(),
        4096usize,
        concat!("Size of: ", stringify!(Mtb))
    );
    assert_eq!(
        ::core::mem::align_of::<Mtb>(),
        4usize,
        concat!("Alignment of ", stringify!(Mtb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).POSITION as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(POSITION)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).MASTER as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(MASTER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).FLOW as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(FLOW))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).BASE as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(BASE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).Reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).ITCTRL as *const _ as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(ITCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).Reserved2 as *const _ as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CLAIMSET as *const _ as usize },
        4000usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(CLAIMSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CLAIMCLR as *const _ as usize },
        4004usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(CLAIMCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).Reserved3 as *const _ as usize },
        4008usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).LOCKACCESS as *const _ as usize },
        4016usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(LOCKACCESS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).LOCKSTATUS as *const _ as usize },
        4020usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(LOCKSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).AUTHSTATUS as *const _ as usize },
        4024usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(AUTHSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).DEVARCH as *const _ as usize },
        4028usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVARCH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).Reserved4 as *const _ as usize },
        4032usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).DEVID as *const _ as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).DEVTYPE as *const _ as usize },
        4044usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVTYPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID4 as *const _ as usize },
        4048usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID5 as *const _ as usize },
        4052usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID6 as *const _ as usize },
        4056usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID7 as *const _ as usize },
        4060usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID0 as *const _ as usize },
        4064usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID1 as *const _ as usize },
        4068usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID2 as *const _ as usize },
        4072usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).PID3 as *const _ as usize },
        4076usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CID0 as *const _ as usize },
        4080usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CID1 as *const _ as usize },
        4084usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CID2 as *const _ as usize },
        4088usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Mtb>())).CID3 as *const _ as usize },
        4092usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID3))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn CMDEX(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_CMDEX(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMD: u16, CMDEX: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let CMD: u16 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CMDEX: u16 = unsafe { ::core::mem::transmute(CMDEX) };
            CMDEX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn RWS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RWS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn MANW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MANW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLEEPPRM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SLEEPPRM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn READMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_READMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CACHEDIS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CACHEDIS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RWS: u32,
        MANW: u32,
        SLEEPPRM: u32,
        READMODE: u32,
        CACHEDIS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let RWS: u32 = unsafe { ::core::mem::transmute(RWS) };
            RWS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MANW: u32 = unsafe { ::core::mem::transmute(MANW) };
            MANW as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let SLEEPPRM: u32 = unsafe { ::core::mem::transmute(SLEEPPRM) };
            SLEEPPRM as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let READMODE: u32 = unsafe { ::core::mem::transmute(READMODE) };
            READMODE as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CACHEDIS: u32 = unsafe { ::core::mem::transmute(CACHEDIS) };
            CACHEDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_PARAM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_PARAM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_PARAM_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_PARAM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_PARAM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_PARAM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_PARAM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_PARAM_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_PARAM_Type__bindgen_ty_1 {
    #[inline]
    pub fn NVMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_NVMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PSZ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PSZ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NVMP: u32, PSZ: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let NVMP: u32 = unsafe { ::core::mem::transmute(NVMP) };
            NVMP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let PSZ: u32 = unsafe { ::core::mem::transmute(PSZ) };
            PSZ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_PARAM_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_PARAM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_PARAM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_PARAM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_PARAM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_PARAM_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_PARAM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_PARAM_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_PARAM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PRM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PRM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOAD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOAD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PROGE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PROGE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOCKE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOCKE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVME(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NVME(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PRM: u16,
        LOAD: u16,
        PROGE: u16,
        LOCKE: u16,
        NVME: u16,
        SB: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PRM: u16 = unsafe { ::core::mem::transmute(PRM) };
            PRM as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LOAD: u16 = unsafe { ::core::mem::transmute(LOAD) };
            LOAD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PROGE: u16 = unsafe { ::core::mem::transmute(PROGE) };
            PROGE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LOCKE: u16 = unsafe { ::core::mem::transmute(LOCKE) };
            LOCKE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NVME: u16 = unsafe { ::core::mem::transmute(NVME) };
            NVME as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SB: u16 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_ADDR_Type__bindgen_ty_1))
    );
}
impl NVMCTRL_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_LOCK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_LOCK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_LOCK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_LOCK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_LOCK_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_LOCK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_LOCK_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_LOCK_Type__bindgen_ty_1))
    );
}
impl NVMCTRL_LOCK_Type__bindgen_ty_1 {
    #[inline]
    pub fn LOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_LOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LOCK: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let LOCK: u16 = unsafe { ::core::mem::transmute(LOCK) };
            LOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_LOCK_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_LOCK_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_LOCK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_LOCK_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_LOCK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_LOCK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_LOCK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVMCTRL_LOCK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_LOCK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Nvmctrl {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control A"]
    pub CTRLA: NVMCTRL_CTRLA_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Control B"]
    pub CTRLB: NVMCTRL_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) NVM Parameter"]
    pub PARAM: NVMCTRL_PARAM_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: NVMCTRL_INTENCLR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: NVMCTRL_INTENSET_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: NVMCTRL_INTFLAG_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) Status"]
    pub STATUS: NVMCTRL_STATUS_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Address"]
    pub ADDR: NVMCTRL_ADDR_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 16) Lock Section"]
    pub LOCK: NVMCTRL_LOCK_Type,
}
#[test]
fn bindgen_test_layout_Nvmctrl() {
    assert_eq!(
        ::core::mem::size_of::<Nvmctrl>(),
        36usize,
        concat!("Size of: ", stringify!(Nvmctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<Nvmctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(Nvmctrl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).Reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).PARAM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(PARAM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).INTENCLR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).Reserved2 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).INTENSET as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).Reserved3 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).INTFLAG as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).Reserved4 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).STATUS as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).Reserved5 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).ADDR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nvmctrl>())).LOCK as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(LOCK)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_WPCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_WPCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_WPCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PAC_WPCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_WPCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WPCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WPCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WPCLR_Type__bindgen_ty_1))
    );
}
impl PAC_WPCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn WP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_WP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WP: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let WP: u32 = unsafe { ::core::mem::transmute(WP) };
            WP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_WPCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<PAC_WPCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WPCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WPCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WPCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PAC_WPCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WPCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PAC_WPCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WPCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_WPSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_WPSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_WPSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PAC_WPSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_WPSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WPSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WPSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WPSET_Type__bindgen_ty_1))
    );
}
impl PAC_WPSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn WP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_WP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WP: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let WP: u32 = unsafe { ::core::mem::transmute(WP) };
            WP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_WPSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<PAC_WPSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WPSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WPSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WPSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PAC_WPSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WPSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PAC_WPSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WPSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pac {
    #[doc = "< \\brief Offset: 0x0 (R/W 32) Write Protection Clear"]
    pub WPCLR: PAC_WPCLR_Type,
    #[doc = "< \\brief Offset: 0x4 (R/W 32) Write Protection Set"]
    pub WPSET: PAC_WPSET_Type,
}
#[test]
fn bindgen_test_layout_Pac() {
    assert_eq!(
        ::core::mem::size_of::<Pac>(),
        8usize,
        concat!("Size of: ", stringify!(Pac))
    );
    assert_eq!(
        ::core::mem::align_of::<Pac>(),
        4usize,
        concat!("Alignment of ", stringify!(Pac))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pac>())).WPCLR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(WPCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pac>())).WPSET as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(WPSET)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_CTRL_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_PM_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_SLEEP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_SLEEP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_SLEEP_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_SLEEP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_SLEEP_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_SLEEP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_SLEEP_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_SLEEP_Type__bindgen_ty_1))
    );
}
impl PM_SLEEP_Type__bindgen_ty_1 {
    #[inline]
    pub fn IDLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IDLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IDLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let IDLE: u8 = unsafe { ::core::mem::transmute(IDLE) };
            IDLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_SLEEP_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_SLEEP_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_SLEEP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_SLEEP_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_SLEEP_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_SLEEP_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_SLEEP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_SLEEP_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_SLEEP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_CPUSEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_CPUSEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_CPUSEL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_CPUSEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_CPUSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_CPUSEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_CPUSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_CPUSEL_Type__bindgen_ty_1))
    );
}
impl PM_CPUSEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CPUDIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CPUDIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CPUDIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CPUDIV: u8 = unsafe { ::core::mem::transmute(CPUDIV) };
            CPUDIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_CPUSEL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_CPUSEL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_CPUSEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_CPUSEL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_CPUSEL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_CPUSEL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_CPUSEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_CPUSEL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_CPUSEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBASEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBASEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBASEL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBASEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBASEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBASEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBASEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBASEL_Type__bindgen_ty_1))
    );
}
impl PM_APBASEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn APBADIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_APBADIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(APBADIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let APBADIV: u8 = unsafe { ::core::mem::transmute(APBADIV) };
            APBADIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBASEL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBASEL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBASEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBASEL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBASEL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBASEL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBASEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBASEL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBASEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBBSEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBBSEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBBSEL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBBSEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBBSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBBSEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBBSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBBSEL_Type__bindgen_ty_1))
    );
}
impl PM_APBBSEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn APBBDIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_APBBDIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(APBBDIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let APBBDIV: u8 = unsafe { ::core::mem::transmute(APBBDIV) };
            APBBDIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBBSEL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBBSEL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBBSEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBBSEL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBBSEL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBBSEL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBBSEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBBSEL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBBSEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBCSEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBCSEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBCSEL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBCSEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBCSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBCSEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBCSEL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBCSEL_Type__bindgen_ty_1))
    );
}
impl PM_APBCSEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn APBCDIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_APBCDIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(APBCDIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let APBCDIV: u8 = unsafe { ::core::mem::transmute(APBCDIV) };
            APBCDIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBCSEL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBCSEL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_APBCSEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBCSEL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_APBCSEL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBCSEL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBCSEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBCSEL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBCSEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_AHBMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_AHBMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PM_AHBMASK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_AHBMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_AHBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PM_AHBMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_AHBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_AHBMASK_Type__bindgen_ty_1))
    );
}
impl PM_AHBMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn HPB0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HPB0_: u32,
        HPB1_: u32,
        HPB2_: u32,
        DSU_: u32,
        NVMCTRL_: u32,
        DMAC_: u32,
        USB_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HPB0_: u32 = unsafe { ::core::mem::transmute(HPB0_) };
            HPB0_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HPB1_: u32 = unsafe { ::core::mem::transmute(HPB1_) };
            HPB1_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HPB2_: u32 = unsafe { ::core::mem::transmute(HPB2_) };
            HPB2_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DMAC_: u32 = unsafe { ::core::mem::transmute(DMAC_) };
            DMAC_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_AHBMASK_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_AHBMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PM_AHBMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_AHBMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_AHBMASK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_AHBMASK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_AHBMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_AHBMASK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_AHBMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBAMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBAMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBAMASK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBAMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBAMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBAMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBAMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBAMASK_Type__bindgen_ty_1))
    );
}
impl PM_APBAMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYSCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SYSCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WDT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EIC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EIC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC0_: u32,
        PM_: u32,
        SYSCTRL_: u32,
        GCLK_: u32,
        WDT_: u32,
        RTC_: u32,
        EIC_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC0_: u32 = unsafe { ::core::mem::transmute(PAC0_) };
            PAC0_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PM_: u32 = unsafe { ::core::mem::transmute(PM_) };
            PM_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYSCTRL_: u32 = unsafe { ::core::mem::transmute(SYSCTRL_) };
            SYSCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GCLK_: u32 = unsafe { ::core::mem::transmute(GCLK_) };
            GCLK_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WDT_: u32 = unsafe { ::core::mem::transmute(WDT_) };
            WDT_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RTC_: u32 = unsafe { ::core::mem::transmute(RTC_) };
            RTC_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EIC_: u32 = unsafe { ::core::mem::transmute(EIC_) };
            EIC_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBAMASK_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBAMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBAMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBAMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBAMASK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBAMASK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBAMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBAMASK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBAMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBBMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBBMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBBMASK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBBMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBBMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBBMASK_Type__bindgen_ty_1))
    );
}
impl PM_APBBMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PORT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HMATRIX_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HMATRIX_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC1_: u32,
        DSU_: u32,
        NVMCTRL_: u32,
        PORT_: u32,
        DMAC_: u32,
        USB_: u32,
        HMATRIX_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC1_: u32 = unsafe { ::core::mem::transmute(PAC1_) };
            PAC1_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PORT_: u32 = unsafe { ::core::mem::transmute(PORT_) };
            PORT_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DMAC_: u32 = unsafe { ::core::mem::transmute(DMAC_) };
            DMAC_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HMATRIX_: u32 = unsafe { ::core::mem::transmute(HMATRIX_) };
            HMATRIX_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBBMASK_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBBMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBBMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBBMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBBMASK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBBMASK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBBMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBBMASK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBBMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_APBCMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_APBCMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PM_APBCMASK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_APBCMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBCMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBCMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBCMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBCMASK_Type__bindgen_ty_1))
    );
}
impl PM_APBCMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVSYS_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVSYS_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM4_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM4_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM5_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM5_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC4_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC4_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC5_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC5_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC6_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC6_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC7_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC7_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ADC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn I2S_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_I2S_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC2_: u32,
        EVSYS_: u32,
        SERCOM0_: u32,
        SERCOM1_: u32,
        SERCOM2_: u32,
        SERCOM3_: u32,
        SERCOM4_: u32,
        SERCOM5_: u32,
        TCC0_: u32,
        TCC1_: u32,
        TCC2_: u32,
        TC3_: u32,
        TC4_: u32,
        TC5_: u32,
        TC6_: u32,
        TC7_: u32,
        ADC_: u32,
        AC_: u32,
        DAC_: u32,
        PTC_: u32,
        I2S_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC2_: u32 = unsafe { ::core::mem::transmute(PAC2_) };
            PAC2_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EVSYS_: u32 = unsafe { ::core::mem::transmute(EVSYS_) };
            EVSYS_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SERCOM0_: u32 = unsafe { ::core::mem::transmute(SERCOM0_) };
            SERCOM0_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SERCOM1_: u32 = unsafe { ::core::mem::transmute(SERCOM1_) };
            SERCOM1_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SERCOM2_: u32 = unsafe { ::core::mem::transmute(SERCOM2_) };
            SERCOM2_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SERCOM3_: u32 = unsafe { ::core::mem::transmute(SERCOM3_) };
            SERCOM3_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SERCOM4_: u32 = unsafe { ::core::mem::transmute(SERCOM4_) };
            SERCOM4_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SERCOM5_: u32 = unsafe { ::core::mem::transmute(SERCOM5_) };
            SERCOM5_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TCC0_: u32 = unsafe { ::core::mem::transmute(TCC0_) };
            TCC0_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TCC1_: u32 = unsafe { ::core::mem::transmute(TCC1_) };
            TCC1_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let TCC2_: u32 = unsafe { ::core::mem::transmute(TCC2_) };
            TCC2_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TC3_: u32 = unsafe { ::core::mem::transmute(TC3_) };
            TC3_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TC4_: u32 = unsafe { ::core::mem::transmute(TC4_) };
            TC4_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TC5_: u32 = unsafe { ::core::mem::transmute(TC5_) };
            TC5_ as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TC6_: u32 = unsafe { ::core::mem::transmute(TC6_) };
            TC6_ as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TC7_: u32 = unsafe { ::core::mem::transmute(TC7_) };
            TC7_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let ADC_: u32 = unsafe { ::core::mem::transmute(ADC_) };
            ADC_ as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let AC_: u32 = unsafe { ::core::mem::transmute(AC_) };
            AC_ as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DAC_: u32 = unsafe { ::core::mem::transmute(DAC_) };
            DAC_ as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let PTC_: u32 = unsafe { ::core::mem::transmute(PTC_) };
            PTC_ as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let I2S_: u32 = unsafe { ::core::mem::transmute(I2S_) };
            I2S_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_APBCMASK_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_APBCMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PM_APBCMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_APBCMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PM_APBCMASK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBCMASK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBCMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_APBCMASK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_APBCMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENCLR_Type__bindgen_ty_1))
    );
}
impl PM_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENSET_Type__bindgen_ty_1))
    );
}
impl PM_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTFLAG_Type__bindgen_ty_1))
    );
}
impl PM_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_RCAUSE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_RCAUSE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_RCAUSE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PM_RCAUSE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_RCAUSE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_RCAUSE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_RCAUSE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_RCAUSE_Type__bindgen_ty_1))
    );
}
impl PM_RCAUSE_Type__bindgen_ty_1 {
    #[inline]
    pub fn POR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_POR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BOD12(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BOD33(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EXT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WDT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        POR: u8,
        BOD12: u8,
        BOD33: u8,
        EXT: u8,
        WDT: u8,
        SYST: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let POR: u8 = unsafe { ::core::mem::transmute(POR) };
            POR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BOD12: u8 = unsafe { ::core::mem::transmute(BOD12) };
            BOD12 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BOD33: u8 = unsafe { ::core::mem::transmute(BOD33) };
            BOD33 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXT: u8 = unsafe { ::core::mem::transmute(EXT) };
            EXT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WDT: u8 = unsafe { ::core::mem::transmute(WDT) };
            WDT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYST: u8 = unsafe { ::core::mem::transmute(SYST) };
            SYST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_RCAUSE_Type() {
    assert_eq!(
        ::core::mem::size_of::<PM_RCAUSE_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_RCAUSE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_RCAUSE_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_RCAUSE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_RCAUSE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_RCAUSE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PM_RCAUSE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_RCAUSE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pm {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control"]
    pub CTRL: PM_CTRL_Type,
    #[doc = "< \\brief Offset: 0x01 (R/W  8) Sleep Mode"]
    pub SLEEP: PM_SLEEP_Type,
    pub Reserved1: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) CPU Clock Select"]
    pub CPUSEL: PM_CPUSEL_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) APBA Clock Select"]
    pub APBASEL: PM_APBASEL_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) APBB Clock Select"]
    pub APBBSEL: PM_APBBSEL_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) APBC Clock Select"]
    pub APBCSEL: PM_APBCSEL_Type,
    pub Reserved2: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x14 (R/W 32) AHB Mask"]
    pub AHBMASK: PM_AHBMASK_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) APBA Mask"]
    pub APBAMASK: PM_APBAMASK_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) APBB Mask"]
    pub APBBMASK: PM_APBBMASK_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 32) APBC Mask"]
    pub APBCMASK: PM_APBCMASK_Type,
    pub Reserved3: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x34 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: PM_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x35 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: PM_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x36 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: PM_INTFLAG_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x38 (R/   8) Reset Cause"]
    pub RCAUSE: PM_RCAUSE_Type,
}
#[test]
fn bindgen_test_layout_Pm() {
    assert_eq!(
        ::core::mem::size_of::<Pm>(),
        60usize,
        concat!("Size of: ", stringify!(Pm))
    );
    assert_eq!(
        ::core::mem::align_of::<Pm>(),
        4usize,
        concat!("Alignment of ", stringify!(Pm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).CTRL as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pm), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).SLEEP as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(Pm), "::", stringify!(SLEEP))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).Reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).CPUSEL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(CPUSEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBASEL as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBASEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBBSEL as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBBSEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBCSEL as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBCSEL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).Reserved2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).AHBMASK as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(AHBMASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBAMASK as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBAMASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBBMASK as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBBMASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).APBCMASK as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(APBCMASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).Reserved3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).INTENCLR as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).INTENSET as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).INTFLAG as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).Reserved4 as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Pm>())).RCAUSE as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(RCAUSE)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_DIR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_DIR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_DIR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIR_Type__bindgen_ty_1))
    );
}
impl PORT_DIR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DIR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DIR: u32 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_DIR_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_DIRCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_DIRCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_DIRCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRCLR_Type__bindgen_ty_1))
    );
}
impl PORT_DIRCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIRCLR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DIRCLR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DIRCLR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DIRCLR: u32 = unsafe { ::core::mem::transmute(DIRCLR) };
            DIRCLR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_DIRCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_DIRSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_DIRSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_DIRSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRSET_Type__bindgen_ty_1))
    );
}
impl PORT_DIRSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIRSET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DIRSET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DIRSET: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DIRSET: u32 = unsafe { ::core::mem::transmute(DIRSET) };
            DIRSET as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_DIRSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRTGL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_DIRTGL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_DIRTGL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_DIRTGL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRTGL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRTGL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRTGL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRTGL_Type__bindgen_ty_1))
    );
}
impl PORT_DIRTGL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIRTGL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DIRTGL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DIRTGL: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DIRTGL: u32 = unsafe { ::core::mem::transmute(DIRTGL) };
            DIRTGL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_DIRTGL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRTGL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRTGL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRTGL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRTGL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRTGL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRTGL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_DIRTGL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRTGL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_OUT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_OUT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_OUT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUT_Type__bindgen_ty_1))
    );
}
impl PORT_OUT_Type__bindgen_ty_1 {
    #[inline]
    pub fn OUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_OUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OUT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let OUT: u32 = unsafe { ::core::mem::transmute(OUT) };
            OUT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_OUT_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_OUTCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_OUTCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_OUTCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTCLR_Type__bindgen_ty_1))
    );
}
impl PORT_OUTCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OUTCLR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_OUTCLR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OUTCLR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let OUTCLR: u32 = unsafe { ::core::mem::transmute(OUTCLR) };
            OUTCLR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_OUTCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_OUTSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_OUTSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_OUTSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTSET_Type__bindgen_ty_1))
    );
}
impl PORT_OUTSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OUTSET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_OUTSET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OUTSET: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let OUTSET: u32 = unsafe { ::core::mem::transmute(OUTSET) };
            OUTSET as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_OUTSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTTGL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_OUTTGL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_OUTTGL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_OUTTGL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTTGL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTTGL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTTGL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTTGL_Type__bindgen_ty_1))
    );
}
impl PORT_OUTTGL_Type__bindgen_ty_1 {
    #[inline]
    pub fn OUTTGL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_OUTTGL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OUTTGL: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let OUTTGL: u32 = unsafe { ::core::mem::transmute(OUTTGL) };
            OUTTGL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_OUTTGL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTTGL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTTGL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTTGL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTTGL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTTGL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTTGL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_OUTTGL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTTGL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_IN_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_IN_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_IN_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_IN_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_IN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_IN_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_IN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_IN_Type__bindgen_ty_1))
    );
}
impl PORT_IN_Type__bindgen_ty_1 {
    #[inline]
    pub fn IN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_IN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IN: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let IN: u32 = unsafe { ::core::mem::transmute(IN) };
            IN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_IN_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_IN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_IN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_IN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_IN_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_IN_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_IN_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_IN_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_IN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_PORT_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_CTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_CTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_CTRL_Type__bindgen_ty_1))
    );
}
impl PORT_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLING(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPLING(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLING: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SAMPLING: u32 = unsafe { ::core::mem::transmute(SAMPLING) };
            SAMPLING as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_CTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_CTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_WRCONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_WRCONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_WRCONFIG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_PORT_WRCONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_WRCONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_WRCONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_WRCONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PORT_WRCONFIG_Type__bindgen_ty_1)
        )
    );
}
impl PORT_WRCONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PINMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_PINMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMUXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PULLEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PULLEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRVSTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DRVSTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PMUX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WRPMUX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRPMUX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WRPINCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRPINCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HWSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HWSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PINMASK: u32,
        PMUXEN: u32,
        INEN: u32,
        PULLEN: u32,
        DRVSTR: u32,
        PMUX: u32,
        WRPMUX: u32,
        WRPINCFG: u32,
        HWSEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PINMASK: u32 = unsafe { ::core::mem::transmute(PINMASK) };
            PINMASK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PMUXEN: u32 = unsafe { ::core::mem::transmute(PMUXEN) };
            PMUXEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let INEN: u32 = unsafe { ::core::mem::transmute(INEN) };
            INEN as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PULLEN: u32 = unsafe { ::core::mem::transmute(PULLEN) };
            PULLEN as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DRVSTR: u32 = unsafe { ::core::mem::transmute(DRVSTR) };
            DRVSTR as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let PMUX: u32 = unsafe { ::core::mem::transmute(PMUX) };
            PMUX as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let WRPMUX: u32 = unsafe { ::core::mem::transmute(WRPMUX) };
            WRPMUX as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let WRPINCFG: u32 = unsafe { ::core::mem::transmute(WRPINCFG) };
            WRPINCFG as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HWSEL: u32 = unsafe { ::core::mem::transmute(HWSEL) };
            HWSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_WRCONFIG_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_WRCONFIG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_WRCONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_WRCONFIG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_WRCONFIG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_WRCONFIG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_WRCONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_WRCONFIG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_WRCONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_PMUX_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_PMUX_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PORT_PMUX_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PORT_PMUX_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PMUX_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PMUX_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PMUX_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PMUX_Type__bindgen_ty_1))
    );
}
impl PORT_PMUX_Type__bindgen_ty_1 {
    #[inline]
    pub fn PMUXE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUXO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PMUXE: u8, PMUXO: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PMUXE: u8 = unsafe { ::core::mem::transmute(PMUXE) };
            PMUXE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let PMUXO: u8 = unsafe { ::core::mem::transmute(PMUXO) };
            PMUXO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_PMUX_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PMUX_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PMUX_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PMUX_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PMUX_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_PMUX_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PMUX_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_PMUX_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PMUX_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_PINCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_PINCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PORT_PINCFG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PORT_PINCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PINCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PINCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PINCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PINCFG_Type__bindgen_ty_1))
    );
}
impl PORT_PINCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PMUXEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PULLEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PULLEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRVSTR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRVSTR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PMUXEN: u8,
        INEN: u8,
        PULLEN: u8,
        DRVSTR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PMUXEN: u8 = unsafe { ::core::mem::transmute(PMUXEN) };
            PMUXEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let INEN: u8 = unsafe { ::core::mem::transmute(INEN) };
            INEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PULLEN: u8 = unsafe { ::core::mem::transmute(PULLEN) };
            PULLEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DRVSTR: u8 = unsafe { ::core::mem::transmute(DRVSTR) };
            DRVSTR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_PINCFG_Type() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PINCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PINCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PINCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PINCFG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_PINCFG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PINCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PORT_PINCFG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PINCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PortGroup {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Data Direction"]
    pub DIR: PORT_DIR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Data Direction Clear"]
    pub DIRCLR: PORT_DIRCLR_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Data Direction Set"]
    pub DIRSET: PORT_DIRSET_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Data Direction Toggle"]
    pub DIRTGL: PORT_DIRTGL_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Data Output Value"]
    pub OUT: PORT_OUT_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Data Output Value Clear"]
    pub OUTCLR: PORT_OUTCLR_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Data Output Value Set"]
    pub OUTSET: PORT_OUTSET_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Data Output Value Toggle"]
    pub OUTTGL: PORT_OUTTGL_Type,
    #[doc = "< \\brief Offset: 0x20 (R/  32) Data Input Value"]
    pub IN: PORT_IN_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Control"]
    pub CTRL: PORT_CTRL_Type,
    #[doc = "< \\brief Offset: 0x28 ( /W 32) Write Configuration"]
    pub WRCONFIG: PORT_WRCONFIG_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) Peripheral Multiplexing n"]
    pub PMUX: [PORT_PMUX_Type; 16usize],
    #[doc = "< \\brief Offset: 0x40 (R/W  8) Pin Configuration n"]
    pub PINCFG: [PORT_PINCFG_Type; 32usize],
    pub Reserved2: [RoReg8; 32usize],
}
#[test]
fn bindgen_test_layout_PortGroup() {
    assert_eq!(
        ::core::mem::size_of::<PortGroup>(),
        128usize,
        concat!("Size of: ", stringify!(PortGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<PortGroup>(),
        4usize,
        concat!("Alignment of ", stringify!(PortGroup))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).DIR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).DIRCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).DIRSET as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).DIRTGL as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRTGL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).OUT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).OUTCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).OUTSET as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).OUTTGL as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTTGL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).IN as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(IN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).CTRL as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).WRCONFIG as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(WRCONFIG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).Reserved1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).PMUX as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(PMUX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).PINCFG as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(PINCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PortGroup>())).Reserved2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Port {
    #[doc = "< \\brief Offset: 0x00 PortGroup groups [GROUPS]"]
    pub Group: [PortGroup; 2usize],
}
#[test]
fn bindgen_test_layout_Port() {
    assert_eq!(
        ::core::mem::size_of::<Port>(),
        256usize,
        concat!("Size of: ", stringify!(Port))
    );
    assert_eq!(
        ::core::mem::align_of::<Port>(),
        4usize,
        concat!("Alignment of ", stringify!(Port))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Port>())).Group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Port),
            "::",
            stringify!(Group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_CTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MATCHCLR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MATCHCLR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        MATCHCLR: u16,
        PRESCALER: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MATCHCLR: u16 = unsafe { ::core::mem::transmute(MATCHCLR) };
            MATCHCLR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_CTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        PRESCALER: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_CTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKREP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKREP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MATCHCLR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MATCHCLR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        CLKREP: u16,
        MATCHCLR: u16,
        PRESCALER: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CLKREP: u16 = unsafe { ::core::mem::transmute(CLKREP) };
            CLKREP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MATCHCLR: u16 = unsafe { ::core::mem::transmute(MATCHCLR) };
            MATCHCLR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_READREQ_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_READREQ_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_READREQ_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_READREQ_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_READREQ_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_READREQ_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_READREQ_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_READREQ_Type__bindgen_ty_1))
    );
}
impl RTC_READREQ_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn RCONT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RCONT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RREQ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RREQ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ADDR: u16,
        RCONT: u16,
        RREQ: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ADDR: u16 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let RCONT: u16 = unsafe { ::core::mem::transmute(RCONT) };
            RCONT as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RREQ: u16 = unsafe { ::core::mem::transmute(RREQ) };
            RREQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_READREQ_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_READREQ_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_READREQ_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_READREQ_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_READREQ_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_READREQ_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_READREQ_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_READREQ_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_READREQ_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMPEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u16,
        PEREO1: u16,
        PEREO2: u16,
        PEREO3: u16,
        PEREO4: u16,
        PEREO5: u16,
        PEREO6: u16,
        PEREO7: u16,
        CMPEO0: u16,
        OVFEO: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u16 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u16 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u16 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u16 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u16 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u16 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u16 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u16 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO0: u16 = unsafe { ::core::mem::transmute(CMPEO0) };
            CMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u16 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMPEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u16, CMPEO: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u16 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO: u16 = unsafe { ::core::mem::transmute(CMPEO) };
            CMPEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMPEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMPEO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u16,
        PEREO1: u16,
        PEREO2: u16,
        PEREO3: u16,
        PEREO4: u16,
        PEREO5: u16,
        PEREO6: u16,
        PEREO7: u16,
        CMPEO0: u16,
        CMPEO1: u16,
        OVFEO: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u16 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u16 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u16 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u16 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u16 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u16 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u16 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u16 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO0: u16 = unsafe { ::core::mem::transmute(CMPEO0) };
            CMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CMPEO1: u16 = unsafe { ::core::mem::transmute(CMPEO1) };
            CMPEO1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u16 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CMPEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u16, CMPEO: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u16 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CMPEO: u16 = unsafe { ::core::mem::transmute(CMPEO) };
            CMPEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARMEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARMEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u16,
        PEREO1: u16,
        PEREO2: u16,
        PEREO3: u16,
        PEREO4: u16,
        PEREO5: u16,
        PEREO6: u16,
        PEREO7: u16,
        ALARMEO0: u16,
        OVFEO: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u16 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u16 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u16 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u16 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u16 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u16 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u16 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u16 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARMEO0: u16 = unsafe { ::core::mem::transmute(ALARMEO0) };
            ALARMEO0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u16 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARMEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARMEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u16, ALARMEO: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u16 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARMEO: u16 = unsafe { ::core::mem::transmute(ALARMEO) };
            ALARMEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        CMP1: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CMP1: u8 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ALARM0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ALARM0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM0: u8 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn ALARM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ALARM: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM: u8 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        CMP1: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CMP1: u8 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn ALARM0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ALARM0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM0: u8 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn ALARM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ALARM: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM: u8 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CMP0: u8,
        CMP1: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CMP0: u8 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CMP1: u8 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn CMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CMP: u8 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn ALARM0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ALARM0: u8,
        SYNCRDY: u8,
        OVF: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM0: u8 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn ALARM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ALARM: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ALARM: u8 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_STATUS_Type__bindgen_ty_1))
    );
}
impl RTC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl RTC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_FREQCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_FREQCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_FREQCORR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_FREQCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_FREQCORR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_FREQCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_FREQCORR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_FREQCORR_Type__bindgen_ty_1))
    );
}
impl RTC_FREQCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALUE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_VALUE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn SIGN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SIGN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VALUE: u8, SIGN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let VALUE: u8 = unsafe { ::core::mem::transmute(VALUE) };
            VALUE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SIGN: u8 = unsafe { ::core::mem::transmute(SIGN) };
            SIGN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_FREQCORR_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_FREQCORR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_FREQCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_FREQCORR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_FREQCORR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_FREQCORR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_FREQCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_FREQCORR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_FREQCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COUNT: u16 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COUNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COUNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_CLOCK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_CLOCK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_CLOCK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CLOCK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CLOCK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CLOCK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CLOCK_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_CLOCK_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_CLOCK_Type__bindgen_ty_1 {
    #[inline]
    pub fn SECOND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SECOND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MINUTE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MINUTE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn HOUR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_HOUR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MONTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MONTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn YEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_YEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SECOND: u32,
        MINUTE: u32,
        HOUR: u32,
        DAY: u32,
        MONTH: u32,
        YEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SECOND: u32 = unsafe { ::core::mem::transmute(SECOND) };
            SECOND as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let MINUTE: u32 = unsafe { ::core::mem::transmute(MINUTE) };
            MINUTE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let HOUR: u32 = unsafe { ::core::mem::transmute(HOUR) };
            HOUR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DAY: u32 = unsafe { ::core::mem::transmute(DAY) };
            DAY as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let MONTH: u32 = unsafe { ::core::mem::transmute(MONTH) };
            MONTH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let YEAR: u32 = unsafe { ::core::mem::transmute(YEAR) };
            YEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CLOCK_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CLOCK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CLOCK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CLOCK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_CLOCK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_CLOCK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CLOCK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_CLOCK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CLOCK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_PER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_PER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_PER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_PER_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_PER_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_PER_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_PER_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_PER_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_PER_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_PER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_PER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_PER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_COMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_COMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_COMP_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COMP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COMP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_COMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_COMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COMP: u32 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COMP_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COMP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COMP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_COMP_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_COMP_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE0_COMP_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_COMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_COMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_COMP_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COMP_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COMP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COMP_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_COMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_COMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COMP: u16 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COMP_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COMP_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COMP_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_COMP_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_COMP_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE1_COMP_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_ALARM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_ALARM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_ALARM_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_ALARM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_ALARM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_ALARM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_ALARM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_ALARM_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_ALARM_Type__bindgen_ty_1 {
    #[inline]
    pub fn SECOND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SECOND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MINUTE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MINUTE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn HOUR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_HOUR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MONTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MONTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn YEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_YEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SECOND: u32,
        MINUTE: u32,
        HOUR: u32,
        DAY: u32,
        MONTH: u32,
        YEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SECOND: u32 = unsafe { ::core::mem::transmute(SECOND) };
            SECOND as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let MINUTE: u32 = unsafe { ::core::mem::transmute(MINUTE) };
            MINUTE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let HOUR: u32 = unsafe { ::core::mem::transmute(HOUR) };
            HOUR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DAY: u32 = unsafe { ::core::mem::transmute(DAY) };
            DAY as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let MONTH: u32 = unsafe { ::core::mem::transmute(MONTH) };
            MONTH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let YEAR: u32 = unsafe { ::core::mem::transmute(YEAR) };
            YEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_ALARM_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_ALARM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_ALARM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_ALARM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_ALARM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_ALARM_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_ALARM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_ALARM_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_ALARM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_MASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_MASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_MASK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_MASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_MASK_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_MASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_MASK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_MASK_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_MASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn SEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SEL: u8 = unsafe { ::core::mem::transmute(SEL) };
            SEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_MASK_Type() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_MASK_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_MASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_MASK_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_MASK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_MASK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_MASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RTC_MODE2_MASK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_MASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode2Alarm {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) MODE2_ALARM Alarm n Value"]
    pub ALARM: RTC_MODE2_ALARM_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) MODE2_ALARM Alarm n Mask"]
    pub MASK: RTC_MODE2_MASK_Type,
    pub Reserved1: [RoReg8; 3usize],
}
#[test]
fn bindgen_test_layout_RtcMode2Alarm() {
    assert_eq!(
        ::core::mem::size_of::<RtcMode2Alarm>(),
        8usize,
        concat!("Size of: ", stringify!(RtcMode2Alarm))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode2Alarm>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode2Alarm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2Alarm>())).ALARM as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(ALARM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2Alarm>())).MASK as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(MASK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2Alarm>())).Reserved1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode0 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE0 Control"]
    pub CTRL: RTC_MODE0_CTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: RTC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 16) MODE0 Event Control"]
    pub EVCTRL: RTC_MODE0_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) MODE0 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE0_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x07 (R/W  8) MODE0 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE0_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) MODE0 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE0_INTFLAG_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Status"]
    pub STATUS: RTC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) MODE0 Counter Value"]
    pub COUNT: RTC_MODE0_COUNT_Type,
    pub Reserved3: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 32) MODE0 Compare n Value"]
    pub COMP: [RTC_MODE0_COMP_Type; 1usize],
}
#[test]
fn bindgen_test_layout_RtcMode0() {
    assert_eq!(
        ::core::mem::size_of::<RtcMode0>(),
        28usize,
        concat!("Size of: ", stringify!(RtcMode0))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode0>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode0))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).EVCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).INTENCLR as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).INTENSET as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).INTFLAG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).Reserved1 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).STATUS as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).DBGCTRL as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).FREQCORR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).Reserved2 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).COUNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).Reserved3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode0>())).COMP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(COMP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode1 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE1 Control"]
    pub CTRL: RTC_MODE1_CTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: RTC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 16) MODE1 Event Control"]
    pub EVCTRL: RTC_MODE1_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) MODE1 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE1_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x07 (R/W  8) MODE1 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE1_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) MODE1 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE1_INTFLAG_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Status"]
    pub STATUS: RTC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 16) MODE1 Counter Value"]
    pub COUNT: RTC_MODE1_COUNT_Type,
    pub Reserved3: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x14 (R/W 16) MODE1 Counter Period"]
    pub PER: RTC_MODE1_PER_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) MODE1 Compare n Value"]
    pub COMP: [RTC_MODE1_COMP_Type; 2usize],
}
#[test]
fn bindgen_test_layout_RtcMode1() {
    assert_eq!(
        ::core::mem::size_of::<RtcMode1>(),
        28usize,
        concat!("Size of: ", stringify!(RtcMode1))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode1>(),
        2usize,
        concat!("Alignment of ", stringify!(RtcMode1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).EVCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).INTENCLR as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).INTENSET as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).INTFLAG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).Reserved1 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).STATUS as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).DBGCTRL as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).FREQCORR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).Reserved2 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).COUNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).Reserved3 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).PER as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(PER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).Reserved4 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode1>())).COMP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(COMP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode2 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE2 Control"]
    pub CTRL: RTC_MODE2_CTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: RTC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 16) MODE2 Event Control"]
    pub EVCTRL: RTC_MODE2_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) MODE2 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE2_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x07 (R/W  8) MODE2 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE2_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) MODE2 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE2_INTFLAG_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Status"]
    pub STATUS: RTC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) MODE2 Clock Value"]
    pub CLOCK: RTC_MODE2_CLOCK_Type,
    pub Reserved3: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x18 RtcMode2Alarm groups [ALARM_NUM]"]
    pub Mode2Alarm: [RtcMode2Alarm; 1usize],
}
#[test]
fn bindgen_test_layout_RtcMode2() {
    assert_eq!(
        ::core::mem::size_of::<RtcMode2>(),
        32usize,
        concat!("Size of: ", stringify!(RtcMode2))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode2>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).EVCTRL as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).INTENCLR as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).INTENSET as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).INTFLAG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).Reserved1 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).STATUS as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).DBGCTRL as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).FREQCORR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).Reserved2 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).CLOCK as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(CLOCK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).Reserved3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RtcMode2>())).Mode2Alarm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Mode2Alarm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rtc {
    #[doc = "< \\brief Offset: 0x00 32-bit Counter with Single 32-bit Compare"]
    pub MODE0: RtcMode0,
    #[doc = "< \\brief Offset: 0x00 16-bit Counter with Two 16-bit Compares"]
    pub MODE1: RtcMode1,
    #[doc = "< \\brief Offset: 0x00 Clock/Calendar with Alarm"]
    pub MODE2: RtcMode2,
    _bindgen_union_align: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_Rtc() {
    assert_eq!(
        ::core::mem::size_of::<Rtc>(),
        32usize,
        concat!("Size of: ", stringify!(Rtc))
    );
    assert_eq!(
        ::core::mem::align_of::<Rtc>(),
        4usize,
        concat!("Alignment of ", stringify!(Rtc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rtc>())).MODE0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rtc>())).MODE1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Rtc>())).MODE2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PINOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PINOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SDAHOLD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SDAHOLD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SCLSM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCLSM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INACTOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_INACTOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LOWTOUTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        PINOUT: u32,
        SDAHOLD: u32,
        MEXTTOEN: u32,
        SEXTTOEN: u32,
        SPEED: u32,
        SCLSM: u32,
        INACTOUT: u32,
        LOWTOUTEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PINOUT: u32 = unsafe { ::core::mem::transmute(PINOUT) };
            PINOUT as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let SDAHOLD: u32 = unsafe { ::core::mem::transmute(SDAHOLD) };
            SDAHOLD as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let MEXTTOEN: u32 = unsafe { ::core::mem::transmute(MEXTTOEN) };
            MEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SEXTTOEN: u32 = unsafe { ::core::mem::transmute(SEXTTOEN) };
            SEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SCLSM: u32 = unsafe { ::core::mem::transmute(SCLSM) };
            SCLSM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let INACTOUT: u32 = unsafe { ::core::mem::transmute(INACTOUT) };
            INACTOUT as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let LOWTOUTEN: u32 = unsafe { ::core::mem::transmute(LOWTOUTEN) };
            LOWTOUTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PINOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PINOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SDAHOLD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SDAHOLD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SCLSM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCLSM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LOWTOUTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        PINOUT: u32,
        SDAHOLD: u32,
        SEXTTOEN: u32,
        SPEED: u32,
        SCLSM: u32,
        LOWTOUTEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PINOUT: u32 = unsafe { ::core::mem::transmute(PINOUT) };
            PINOUT as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let SDAHOLD: u32 = unsafe { ::core::mem::transmute(SDAHOLD) };
            SDAHOLD as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SEXTTOEN: u32 = unsafe { ::core::mem::transmute(SEXTTOEN) };
            SEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SCLSM: u32 = unsafe { ::core::mem::transmute(SCLSM) };
            SCLSM as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let LOWTOUTEN: u32 = unsafe { ::core::mem::transmute(LOWTOUTEN) };
            LOWTOUTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IBON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IBON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DOPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DOPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DIPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DIPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FORM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FORM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CPHA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPHA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPOL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPOL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DORD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DORD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        IBON: u32,
        DOPO: u32,
        DIPO: u32,
        FORM: u32,
        CPHA: u32,
        CPOL: u32,
        DORD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IBON: u32 = unsafe { ::core::mem::transmute(IBON) };
            IBON as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let DOPO: u32 = unsafe { ::core::mem::transmute(DOPO) };
            DOPO as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let DIPO: u32 = unsafe { ::core::mem::transmute(DIPO) };
            DIPO as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FORM: u32 = unsafe { ::core::mem::transmute(FORM) };
            FORM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let CPHA: u32 = unsafe { ::core::mem::transmute(CPHA) };
            CPHA as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let CPOL: u32 = unsafe { ::core::mem::transmute(CPOL) };
            CPOL as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DORD: u32 = unsafe { ::core::mem::transmute(DORD) };
            DORD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IBON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IBON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SAMPR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn TXPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TXPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RXPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SAMPA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FORM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FORM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPOL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPOL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DORD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DORD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        IBON: u32,
        SAMPR: u32,
        TXPO: u32,
        RXPO: u32,
        SAMPA: u32,
        FORM: u32,
        CMODE: u32,
        CPOL: u32,
        DORD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IBON: u32 = unsafe { ::core::mem::transmute(IBON) };
            IBON as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let SAMPR: u32 = unsafe { ::core::mem::transmute(SAMPR) };
            SAMPR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let TXPO: u32 = unsafe { ::core::mem::transmute(TXPO) };
            TXPO as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let RXPO: u32 = unsafe { ::core::mem::transmute(RXPO) };
            RXPO as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let SAMPA: u32 = unsafe { ::core::mem::transmute(SAMPA) };
            SAMPA as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FORM: u32 = unsafe { ::core::mem::transmute(FORM) };
            FORM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let CMODE: u32 = unsafe { ::core::mem::transmute(CMODE) };
            CMODE as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let CPOL: u32 = unsafe { ::core::mem::transmute(CPOL) };
            CPOL as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DORD: u32 = unsafe { ::core::mem::transmute(DORD) };
            DORD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ACKACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACKACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SMEN: u32,
        QCEN: u32,
        CMD: u32,
        ACKACT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SMEN: u32 = unsafe { ::core::mem::transmute(SMEN) };
            SMEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QCEN: u32 = unsafe { ::core::mem::transmute(QCEN) };
            QCEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ACKACT: u32 = unsafe { ::core::mem::transmute(ACKACT) };
            ACKACT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AACKEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AACKEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ACKACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACKACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SMEN: u32,
        GCMD: u32,
        AACKEN: u32,
        AMODE: u32,
        CMD: u32,
        ACKACT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SMEN: u32 = unsafe { ::core::mem::transmute(SMEN) };
            SMEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GCMD: u32 = unsafe { ::core::mem::transmute(GCMD) };
            GCMD as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AACKEN: u32 = unsafe { ::core::mem::transmute(AACKEN) };
            AACKEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let AMODE: u32 = unsafe { ::core::mem::transmute(AMODE) };
            AMODE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ACKACT: u32 = unsafe { ::core::mem::transmute(ACKACT) };
            ACKACT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CHSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PLOADEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PLOADEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSDE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SSDE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSSEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MSSEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHSIZE: u32,
        PLOADEN: u32,
        SSDE: u32,
        MSSEN: u32,
        AMODE: u32,
        RXEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CHSIZE: u32 = unsafe { ::core::mem::transmute(CHSIZE) };
            CHSIZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PLOADEN: u32 = unsafe { ::core::mem::transmute(PLOADEN) };
            PLOADEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SSDE: u32 = unsafe { ::core::mem::transmute(SSDE) };
            SSDE as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let MSSEN: u32 = unsafe { ::core::mem::transmute(MSSEN) };
            MSSEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let AMODE: u32 = unsafe { ::core::mem::transmute(AMODE) };
            AMODE as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let RXEN: u32 = unsafe { ::core::mem::transmute(RXEN) };
            RXEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CHSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn SBMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SBMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLDEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COLDEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SFDE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SFDE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHSIZE: u32,
        SBMODE: u32,
        COLDEN: u32,
        SFDE: u32,
        ENC: u32,
        PMODE: u32,
        TXEN: u32,
        RXEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CHSIZE: u32 = unsafe { ::core::mem::transmute(CHSIZE) };
            CHSIZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SBMODE: u32 = unsafe { ::core::mem::transmute(SBMODE) };
            SBMODE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let COLDEN: u32 = unsafe { ::core::mem::transmute(COLDEN) };
            COLDEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SFDE: u32 = unsafe { ::core::mem::transmute(SFDE) };
            SFDE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ENC: u32 = unsafe { ::core::mem::transmute(ENC) };
            ENC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PMODE: u32 = unsafe { ::core::mem::transmute(PMODE) };
            PMODE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TXEN: u32 = unsafe { ::core::mem::transmute(TXEN) };
            TXEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let RXEN: u32 = unsafe { ::core::mem::transmute(RXEN) };
            RXEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_BAUD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_BAUD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_BAUD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_BAUD_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BAUDLOW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BAUDLOW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn HSBAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_HSBAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn HSBAUDLOW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_HSBAUDLOW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BAUD: u32,
        BAUDLOW: u32,
        HSBAUD: u32,
        HSBAUDLOW: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BAUD: u32 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BAUDLOW: u32 = unsafe { ::core::mem::transmute(BAUDLOW) };
            BAUDLOW as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let HSBAUD: u32 = unsafe { ::core::mem::transmute(HSBAUD) };
            HSBAUD as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let HSBAUDLOW: u32 = unsafe { ::core::mem::transmute(HSBAUDLOW) };
            HSBAUDLOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_BAUD_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_BAUD_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_BAUD_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_BAUD_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_BAUD_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_BAUD_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_BAUD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_BAUD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_BAUD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_BAUD_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BAUD: u8 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_BAUD_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_BAUD_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_BAUD_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_BAUD_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_BAUD_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_BAUD_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_BAUD_Type__bindgen_ty_1,
    #[doc = "< Structure used for FRAC"]
    pub FRAC: SERCOM_USART_BAUD_Type__bindgen_ty_2,
    #[doc = "< Structure used for FRACFP"]
    pub FRACFP: SERCOM_USART_BAUD_Type__bindgen_ty_3,
    #[doc = "< Structure used for USARTFP"]
    pub USARTFP: SERCOM_USART_BAUD_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_2)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_2 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn FP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16, FP: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let FP: u16 = unsafe { ::core::mem::transmute(FP) };
            FP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_3>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_3)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_3 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn FP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16, FP: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let FP: u16 = unsafe { ::core::mem::transmute(FP) };
            FP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_4>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_4)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_4 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_BAUD_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_BAUD_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_BAUD_Type>())).FRAC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(FRAC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_BAUD_Type>())).FRACFP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(FRACFP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_BAUD_Type>())).USARTFP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(USARTFP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_BAUD_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_RXPL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_RXPL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_RXPL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_RXPL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_RXPL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_RXPL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_RXPL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_RXPL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_RXPL_Type__bindgen_ty_1 {
    #[inline]
    pub fn RXPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_RXPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RXPL: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let RXPL: u8 = unsafe { ::core::mem::transmute(RXPL) };
            RXPL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_RXPL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_RXPL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_RXPL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_RXPL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_RXPL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_RXPL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_RXPL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_RXPL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_RXPL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ARBLOST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ARBLOST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXNACK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXNACK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSSTATE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BUSSTATE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOWTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKHOLD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKHOLD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LENERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LENERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSERR: u16,
        ARBLOST: u16,
        RXNACK: u16,
        BUSSTATE: u16,
        LOWTOUT: u16,
        CLKHOLD: u16,
        MEXTTOUT: u16,
        SEXTTOUT: u16,
        LENERR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSERR: u16 = unsafe { ::core::mem::transmute(BUSERR) };
            BUSERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ARBLOST: u16 = unsafe { ::core::mem::transmute(ARBLOST) };
            ARBLOST as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXNACK: u16 = unsafe { ::core::mem::transmute(RXNACK) };
            RXNACK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let BUSSTATE: u16 = unsafe { ::core::mem::transmute(BUSSTATE) };
            BUSSTATE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let LOWTOUT: u16 = unsafe { ::core::mem::transmute(LOWTOUT) };
            LOWTOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CLKHOLD: u16 = unsafe { ::core::mem::transmute(CLKHOLD) };
            CLKHOLD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let MEXTTOUT: u16 = unsafe { ::core::mem::transmute(MEXTTOUT) };
            MEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SEXTTOUT: u16 = unsafe { ::core::mem::transmute(SEXTTOUT) };
            SEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LENERR: u16 = unsafe { ::core::mem::transmute(LENERR) };
            LENERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COLL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXNACK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXNACK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOWTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKHOLD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKHOLD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSERR: u16,
        COLL: u16,
        RXNACK: u16,
        DIR: u16,
        SR: u16,
        LOWTOUT: u16,
        CLKHOLD: u16,
        SEXTTOUT: u16,
        HS: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSERR: u16 = unsafe { ::core::mem::transmute(BUSERR) };
            BUSERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COLL: u16 = unsafe { ::core::mem::transmute(COLL) };
            COLL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXNACK: u16 = unsafe { ::core::mem::transmute(RXNACK) };
            RXNACK as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DIR: u16 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SR: u16 = unsafe { ::core::mem::transmute(SR) };
            SR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let LOWTOUT: u16 = unsafe { ::core::mem::transmute(LOWTOUT) };
            LOWTOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CLKHOLD: u16 = unsafe { ::core::mem::transmute(CLKHOLD) };
            CLKHOLD as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SEXTTOUT: u16 = unsafe { ::core::mem::transmute(SEXTTOUT) };
            SEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let HS: u16 = unsafe { ::core::mem::transmute(HS) };
            HS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUFOVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUFOVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUFOVF: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUFOVF: u16 = unsafe { ::core::mem::transmute(BUFOVF) };
            BUFOVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUFOVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUFOVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CTS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ISF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ISF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COLL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PERR: u16,
        FERR: u16,
        BUFOVF: u16,
        CTS: u16,
        ISF: u16,
        COLL: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PERR: u16 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FERR: u16 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUFOVF: u16 = unsafe { ::core::mem::transmute(BUFOVF) };
            BUFOVF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CTS: u16 = unsafe { ::core::mem::transmute(CTS) };
            CTS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ISF: u16 = unsafe { ::core::mem::transmute(ISF) };
            ISF as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let COLL: u16 = unsafe { ::core::mem::transmute(COLL) };
            COLL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYSOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SYSOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        SYSOP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYSOP: u32 = unsafe { ::core::mem::transmute(SYSOP) };
            SYSOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u32, ENABLE: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn LENEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LENEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TENBITEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TENBITEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ADDR: u32,
        LENEN: u32,
        HS: u32,
        TENBITEN: u32,
        LEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LENEN: u32 = unsafe { ::core::mem::transmute(LENEN) };
            LENEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HS: u32 = unsafe { ::core::mem::transmute(HS) };
            HS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TENBITEN: u32 = unsafe { ::core::mem::transmute(TENBITEN) };
            TENBITEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let LEN: u32 = unsafe { ::core::mem::transmute(LEN) };
            LEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn GENCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn TENBITEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TENBITEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDRMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ADDRMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GENCEN: u32,
        ADDR: u32,
        TENBITEN: u32,
        ADDRMASK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let GENCEN: u32 = unsafe { ::core::mem::transmute(GENCEN) };
            GENCEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 10u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TENBITEN: u32 = unsafe { ::core::mem::transmute(TENBITEN) };
            TENBITEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 10u8, {
            let ADDRMASK: u32 = unsafe { ::core::mem::transmute(ADDRMASK) };
            ADDRMASK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDRMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ADDRMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32, ADDRMASK: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let ADDRMASK: u32 = unsafe { ::core::mem::transmute(ADDRMASK) };
            ADDRMASK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DATA: u8 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DATA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DATA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DATA: u8 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_DATA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_DATA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CS_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_DATA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_DATA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let DATA: u16 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DATA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DATA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DATA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_DATA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_DATA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_DATA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_I2CM_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_SPI_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SERCOM_USART_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomI2cm {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) I2CM Control A"]
    pub CTRLA: SERCOM_I2CM_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) I2CM Control B"]
    pub CTRLB: SERCOM_I2CM_CTRLB_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x0C (R/W 32) I2CM Baud Rate"]
    pub BAUD: SERCOM_I2CM_BAUD_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) I2CM Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_I2CM_INTENCLR_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) I2CM Interrupt Enable Set"]
    pub INTENSET: SERCOM_I2CM_INTENSET_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) I2CM Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_I2CM_INTFLAG_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) I2CM Status"]
    pub STATUS: SERCOM_I2CM_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) I2CM Syncbusy"]
    pub SYNCBUSY: SERCOM_I2CM_SYNCBUSY_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) I2CM Address"]
    pub ADDR: SERCOM_I2CM_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W  8) I2CM Data"]
    pub DATA: SERCOM_I2CM_DATA_Type,
    pub Reserved7: [RoReg8; 7usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) I2CM Debug Control"]
    pub DBGCTRL: SERCOM_I2CM_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomI2cm() {
    assert_eq!(
        ::core::mem::size_of::<SercomI2cm>(),
        52usize,
        concat!("Size of: ", stringify!(SercomI2cm))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomI2cm>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomI2cm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).BAUD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved3 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).INTENSET as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved4 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved5 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).STATUS as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).SYNCBUSY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).ADDR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).DATA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).Reserved7 as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cm>())).DBGCTRL as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomI2cs {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) I2CS Control A"]
    pub CTRLA: SERCOM_I2CS_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) I2CS Control B"]
    pub CTRLB: SERCOM_I2CS_CTRLB_Type,
    pub Reserved1: [RoReg8; 12usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) I2CS Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_I2CS_INTENCLR_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) I2CS Interrupt Enable Set"]
    pub INTENSET: SERCOM_I2CS_INTENSET_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) I2CS Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_I2CS_INTFLAG_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) I2CS Status"]
    pub STATUS: SERCOM_I2CS_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) I2CS Syncbusy"]
    pub SYNCBUSY: SERCOM_I2CS_SYNCBUSY_Type,
    pub Reserved5: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) I2CS Address"]
    pub ADDR: SERCOM_I2CS_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W  8) I2CS Data"]
    pub DATA: SERCOM_I2CS_DATA_Type,
}
#[test]
fn bindgen_test_layout_SercomI2cs() {
    assert_eq!(
        ::core::mem::size_of::<SercomI2cs>(),
        44usize,
        concat!("Size of: ", stringify!(SercomI2cs))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomI2cs>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomI2cs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).Reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).Reserved2 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).INTENSET as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).Reserved3 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).Reserved4 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).STATUS as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).SYNCBUSY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).Reserved5 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).ADDR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomI2cs>())).DATA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(DATA)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomSpi {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) SPI Control A"]
    pub CTRLA: SERCOM_SPI_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) SPI Control B"]
    pub CTRLB: SERCOM_SPI_CTRLB_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) SPI Baud Rate"]
    pub BAUD: SERCOM_SPI_BAUD_Type,
    pub Reserved2: [RoReg8; 7usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) SPI Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_SPI_INTENCLR_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) SPI Interrupt Enable Set"]
    pub INTENSET: SERCOM_SPI_INTENSET_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) SPI Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_SPI_INTFLAG_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) SPI Status"]
    pub STATUS: SERCOM_SPI_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) SPI Syncbusy"]
    pub SYNCBUSY: SERCOM_SPI_SYNCBUSY_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) SPI Address"]
    pub ADDR: SERCOM_SPI_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 32) SPI Data"]
    pub DATA: SERCOM_SPI_DATA_Type,
    pub Reserved7: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) SPI Debug Control"]
    pub DBGCTRL: SERCOM_SPI_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomSpi() {
    assert_eq!(
        ::core::mem::size_of::<SercomSpi>(),
        52usize,
        concat!("Size of: ", stringify!(SercomSpi))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomSpi>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomSpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).BAUD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved2 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved3 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).INTENSET as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved4 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved5 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).STATUS as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).SYNCBUSY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).ADDR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).DATA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).Reserved7 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomSpi>())).DBGCTRL as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomUsart {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) USART Control A"]
    pub CTRLA: SERCOM_USART_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) USART Control B"]
    pub CTRLB: SERCOM_USART_CTRLB_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x0C (R/W 16) USART Baud Rate"]
    pub BAUD: SERCOM_USART_BAUD_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) USART Receive Pulse Length"]
    pub RXPL: SERCOM_USART_RXPL_Type,
    pub Reserved2: [RoReg8; 5usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) USART Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_USART_INTENCLR_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) USART Interrupt Enable Set"]
    pub INTENSET: SERCOM_USART_INTENSET_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) USART Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_USART_INTFLAG_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) USART Status"]
    pub STATUS: SERCOM_USART_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) USART Syncbusy"]
    pub SYNCBUSY: SERCOM_USART_SYNCBUSY_Type,
    pub Reserved6: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x28 (R/W 16) USART Data"]
    pub DATA: SERCOM_USART_DATA_Type,
    pub Reserved7: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) USART Debug Control"]
    pub DBGCTRL: SERCOM_USART_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomUsart() {
    assert_eq!(
        ::core::mem::size_of::<SercomUsart>(),
        52usize,
        concat!("Size of: ", stringify!(SercomUsart))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomUsart>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomUsart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).CTRLB as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).BAUD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).RXPL as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(RXPL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved3 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).INTENSET as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved4 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).INTFLAG as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved5 as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).STATUS as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).SYNCBUSY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).DATA as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).Reserved7 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SercomUsart>())).DBGCTRL as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Sercom {
    #[doc = "< \\brief Offset: 0x00 I2C Master Mode"]
    pub I2CM: SercomI2cm,
    #[doc = "< \\brief Offset: 0x00 I2C Slave Mode"]
    pub I2CS: SercomI2cs,
    #[doc = "< \\brief Offset: 0x00 SPI Mode"]
    pub SPI: SercomSpi,
    #[doc = "< \\brief Offset: 0x00 USART Mode"]
    pub USART: SercomUsart,
    _bindgen_union_align: [u32; 13usize],
}
#[test]
fn bindgen_test_layout_Sercom() {
    assert_eq!(
        ::core::mem::size_of::<Sercom>(),
        52usize,
        concat!("Size of: ", stringify!(Sercom))
    );
    assert_eq!(
        ::core::mem::align_of::<Sercom>(),
        4usize,
        concat!("Alignment of ", stringify!(Sercom))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sercom>())).I2CM as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(I2CM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sercom>())).I2CS as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(I2CS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sercom>())).SPI as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(SPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sercom>())).USART as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(USART)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC8MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC8MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSC32KRDY: u32,
        OSC32KRDY: u32,
        OSC8MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OSC32KRDY: u32 = unsafe { ::core::mem::transmute(OSC32KRDY) };
            OSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OSC8MRDY: u32 = unsafe { ::core::mem::transmute(OSC8MRDY) };
            OSC8MRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC8MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC8MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSC32KRDY: u32,
        OSC32KRDY: u32,
        OSC8MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OSC32KRDY: u32 = unsafe { ::core::mem::transmute(OSC32KRDY) };
            OSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OSC8MRDY: u32 = unsafe { ::core::mem::transmute(OSC8MRDY) };
            OSC8MRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC8MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC8MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSC32KRDY: u32,
        OSC32KRDY: u32,
        OSC8MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OSC32KRDY: u32 = unsafe { ::core::mem::transmute(OSC32KRDY) };
            OSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OSC8MRDY: u32 = unsafe { ::core::mem::transmute(OSC8MRDY) };
            OSC8MRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_PCLKSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_PCLKSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_PCLKSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_PCLKSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_PCLKSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_PCLKSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_PCLKSR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_PCLKSR_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_PCLKSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC8MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC8MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSC32KRDY: u32,
        OSC32KRDY: u32,
        OSC8MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OSC32KRDY: u32 = unsafe { ::core::mem::transmute(OSC32KRDY) };
            OSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OSC8MRDY: u32 = unsafe { ::core::mem::transmute(OSC8MRDY) };
            OSC8MRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_PCLKSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_PCLKSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_PCLKSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_PCLKSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_PCLKSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_PCLKSR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_PCLKSR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_PCLKSR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_PCLKSR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_XOSC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_XOSC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_XOSC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_XOSC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_XOSC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_XOSC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_XOSC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_XOSC_Type__bindgen_ty_1))
    );
}
impl SYSCTRL_XOSC_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XTALEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_XTALEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GAIN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_GAIN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AMPGC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AMPGC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_STARTUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        XTALEN: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        GAIN: u16,
        AMPGC: u16,
        STARTUP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let XTALEN: u16 = unsafe { ::core::mem::transmute(XTALEN) };
            XTALEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let GAIN: u16 = unsafe { ::core::mem::transmute(GAIN) };
            GAIN as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AMPGC: u16 = unsafe { ::core::mem::transmute(AMPGC) };
            AMPGC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let STARTUP: u16 = unsafe { ::core::mem::transmute(STARTUP) };
            STARTUP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_XOSC_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_XOSC_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_XOSC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_XOSC_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_XOSC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_XOSC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_XOSC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_XOSC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_XOSC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_XOSC32K_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_XOSC32K_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_XOSC32K_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_XOSC32K_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_XOSC32K_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_XOSC32K_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_XOSC32K_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_XOSC32K_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_XOSC32K_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XTALEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_XTALEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN32K(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EN32K(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN1K(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EN1K(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AAMPEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AAMPEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_STARTUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        XTALEN: u16,
        EN32K: u16,
        EN1K: u16,
        AAMPEN: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        STARTUP: u16,
        WRTLOCK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let XTALEN: u16 = unsafe { ::core::mem::transmute(XTALEN) };
            XTALEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EN32K: u16 = unsafe { ::core::mem::transmute(EN32K) };
            EN32K as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EN1K: u16 = unsafe { ::core::mem::transmute(EN1K) };
            EN1K as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AAMPEN: u16 = unsafe { ::core::mem::transmute(AAMPEN) };
            AAMPEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let STARTUP: u16 = unsafe { ::core::mem::transmute(STARTUP) };
            STARTUP as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WRTLOCK: u16 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_XOSC32K_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_XOSC32K_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_XOSC32K_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_XOSC32K_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_XOSC32K_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_XOSC32K_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_XOSC32K_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_XOSC32K_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_XOSC32K_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_OSC32K_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_OSC32K_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_OSC32K_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSC32K_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSC32K_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_OSC32K_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSC32K_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_OSC32K_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_OSC32K_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN32K(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN32K(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN1K(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN1K(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTUP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_STARTUP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CALIB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_CALIB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        EN32K: u32,
        EN1K: u32,
        RUNSTDBY: u32,
        ONDEMAND: u32,
        STARTUP: u32,
        WRTLOCK: u32,
        CALIB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EN32K: u32 = unsafe { ::core::mem::transmute(EN32K) };
            EN32K as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EN1K: u32 = unsafe { ::core::mem::transmute(EN1K) };
            EN1K as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u32 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let STARTUP: u32 = unsafe { ::core::mem::transmute(STARTUP) };
            STARTUP as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WRTLOCK: u32 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let CALIB: u32 = unsafe { ::core::mem::transmute(CALIB) };
            CALIB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSC32K_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSC32K_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_OSC32K_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSC32K_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_OSC32K_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSC32K_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSC32K_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSC32K_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSC32K_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_OSCULP32K_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_OSCULP32K_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_OSCULP32K_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSCULP32K_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSCULP32K_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SYSCTRL_OSCULP32K_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSCULP32K_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_OSCULP32K_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_OSCULP32K_Type__bindgen_ty_1 {
    #[inline]
    pub fn CALIB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_CALIB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CALIB: u8, WRTLOCK: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let CALIB: u8 = unsafe { ::core::mem::transmute(CALIB) };
            CALIB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let WRTLOCK: u8 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSCULP32K_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSCULP32K_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SYSCTRL_OSCULP32K_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSCULP32K_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SYSCTRL_OSCULP32K_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSCULP32K_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSCULP32K_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSCULP32K_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSCULP32K_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_OSC8M_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_OSC8M_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_OSC8M_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSC8M_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSC8M_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_OSC8M_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSC8M_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_OSC8M_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_OSC8M_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRESC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CALIB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_CALIB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn FRANGE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FRANGE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        RUNSTDBY: u32,
        ONDEMAND: u32,
        PRESC: u32,
        CALIB: u32,
        FRANGE: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u32 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let PRESC: u32 = unsafe { ::core::mem::transmute(PRESC) };
            PRESC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let CALIB: u32 = unsafe { ::core::mem::transmute(CALIB) };
            CALIB as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let FRANGE: u32 = unsafe { ::core::mem::transmute(FRANGE) };
            FRANGE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_OSC8M_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_OSC8M_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_OSC8M_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_OSC8M_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_OSC8M_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSC8M_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSC8M_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_OSC8M_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_OSC8M_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DFLLCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DFLLCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DFLLCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DFLLCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DFLLCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_STABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LLAW(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LLAW(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USBCRM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_USBCRM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCDIS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CCDIS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QLDIS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_QLDIS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BPLCKC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BPLCKC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAITLOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAITLOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        MODE: u16,
        STABLE: u16,
        LLAW: u16,
        USBCRM: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        CCDIS: u16,
        QLDIS: u16,
        BPLCKC: u16,
        WAITLOCK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STABLE: u16 = unsafe { ::core::mem::transmute(STABLE) };
            STABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let LLAW: u16 = unsafe { ::core::mem::transmute(LLAW) };
            LLAW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let USBCRM: u16 = unsafe { ::core::mem::transmute(USBCRM) };
            USBCRM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CCDIS: u16 = unsafe { ::core::mem::transmute(CCDIS) };
            CCDIS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QLDIS: u16 = unsafe { ::core::mem::transmute(QLDIS) };
            QLDIS as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BPLCKC: u16 = unsafe { ::core::mem::transmute(BPLCKC) };
            BPLCKC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WAITLOCK: u16 = unsafe { ::core::mem::transmute(WAITLOCK) };
            WAITLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DFLLCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DFLLVAL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DFLLVAL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DFLLVAL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLVAL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLVAL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLVAL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLVAL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DFLLVAL_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DFLLVAL_Type__bindgen_ty_1 {
    #[inline]
    pub fn FINE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_FINE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn COARSE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_COARSE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn DIFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DIFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FINE: u32,
        COARSE: u32,
        DIFF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let FINE: u32 = unsafe { ::core::mem::transmute(FINE) };
            FINE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let COARSE: u32 = unsafe { ::core::mem::transmute(COARSE) };
            COARSE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let DIFF: u32 = unsafe { ::core::mem::transmute(DIFF) };
            DIFF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLVAL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLVAL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLVAL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLVAL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DFLLVAL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLVAL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLVAL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLVAL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLVAL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DFLLMUL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DFLLMUL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DFLLMUL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLMUL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLMUL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLMUL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLMUL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DFLLMUL_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DFLLMUL_Type__bindgen_ty_1 {
    #[inline]
    pub fn MUL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_MUL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn FSTEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_FSTEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn CSTEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_CSTEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MUL: u32,
        FSTEP: u32,
        CSTEP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let MUL: u32 = unsafe { ::core::mem::transmute(MUL) };
            MUL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let FSTEP: u32 = unsafe { ::core::mem::transmute(FSTEP) };
            FSTEP as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let CSTEP: u32 = unsafe { ::core::mem::transmute(CSTEP) };
            CSTEP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLMUL_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLMUL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLMUL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLMUL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DFLLMUL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLMUL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLMUL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLMUL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLMUL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DFLLSYNC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DFLLSYNC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DFLLSYNC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLSYNC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLSYNC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLSYNC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLSYNC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DFLLSYNC_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DFLLSYNC_Type__bindgen_ty_1 {
    #[inline]
    pub fn READREQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READREQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READREQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let READREQ: u8 = unsafe { ::core::mem::transmute(READREQ) };
            READREQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DFLLSYNC_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DFLLSYNC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SYSCTRL_DFLLSYNC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DFLLSYNC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DFLLSYNC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLSYNC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLSYNC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DFLLSYNC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DFLLSYNC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_BOD33_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_BOD33_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_BOD33_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_BOD33_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_BOD33_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_BOD33_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_BOD33_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_BOD33_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_BOD33_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HYST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HYST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ACTION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn LEVEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_LEVEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        HYST: u32,
        ACTION: u32,
        RUNSTDBY: u32,
        MODE: u32,
        CEN: u32,
        PSEL: u32,
        LEVEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HYST: u32 = unsafe { ::core::mem::transmute(HYST) };
            HYST as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let ACTION: u32 = unsafe { ::core::mem::transmute(ACTION) };
            ACTION as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CEN: u32 = unsafe { ::core::mem::transmute(CEN) };
            CEN as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PSEL: u32 = unsafe { ::core::mem::transmute(PSEL) };
            PSEL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let LEVEL: u32 = unsafe { ::core::mem::transmute(LEVEL) };
            LEVEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_BOD33_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_BOD33_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_BOD33_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_BOD33_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_BOD33_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_BOD33_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_BOD33_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_BOD33_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_BOD33_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_VREG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_VREG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_VREG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_VREG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_VREG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_VREG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_VREG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_VREG_Type__bindgen_ty_1))
    );
}
impl SYSCTRL_VREG_Type__bindgen_ty_1 {
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FORCELDO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FORCELDO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RUNSTDBY: u16, FORCELDO: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FORCELDO: u16 = unsafe { ::core::mem::transmute(FORCELDO) };
            FORCELDO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_VREG_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_VREG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SYSCTRL_VREG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_VREG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SYSCTRL_VREG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_VREG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_VREG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_VREG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_VREG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_VREF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_VREF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_VREF_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_VREF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_VREF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_VREF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_VREF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_VREF_Type__bindgen_ty_1))
    );
}
impl SYSCTRL_VREF_Type__bindgen_ty_1 {
    #[inline]
    pub fn TSEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BGOUTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BGOUTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CALIB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_CALIB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TSEN: u32,
        BGOUTEN: u32,
        CALIB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TSEN: u32 = unsafe { ::core::mem::transmute(TSEN) };
            TSEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BGOUTEN: u32 = unsafe { ::core::mem::transmute(BGOUTEN) };
            BGOUTEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 11u8, {
            let CALIB: u32 = unsafe { ::core::mem::transmute(CALIB) };
            CALIB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_VREF_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_VREF_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_VREF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_VREF_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_VREF_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_VREF_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_VREF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_VREF_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_VREF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DPLLCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DPLLCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        RUNSTDBY: u8,
        ONDEMAND: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u8 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLCTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLCTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SYSCTRL_DPLLCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLCTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DPLLCTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLCTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLCTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DPLLRATIO_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DPLLRATIO_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DPLLRATIO_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLRATIO_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLRATIO_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SYSCTRL_DPLLRATIO_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLRATIO_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DPLLRATIO_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DPLLRATIO_Type__bindgen_ty_1 {
    #[inline]
    pub fn LDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_LDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn LDRFRAC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LDRFRAC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LDR: u32, LDRFRAC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let LDR: u32 = unsafe { ::core::mem::transmute(LDR) };
            LDR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LDRFRAC: u32 = unsafe { ::core::mem::transmute(LDRFRAC) };
            LDRFRAC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLRATIO_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLRATIO_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DPLLRATIO_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLRATIO_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DPLLRATIO_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLRATIO_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLRATIO_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLRATIO_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLRATIO_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DPLLCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DPLLCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn FILTER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FILTER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn REFCLK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_REFCLK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LTIME(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_LTIME(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn LBYPASS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LBYPASS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_DIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FILTER: u32,
        LPEN: u32,
        WUF: u32,
        REFCLK: u32,
        LTIME: u32,
        LBYPASS: u32,
        DIV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let FILTER: u32 = unsafe { ::core::mem::transmute(FILTER) };
            FILTER as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LPEN: u32 = unsafe { ::core::mem::transmute(LPEN) };
            LPEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WUF: u32 = unsafe { ::core::mem::transmute(WUF) };
            WUF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let REFCLK: u32 = unsafe { ::core::mem::transmute(REFCLK) };
            REFCLK as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let LTIME: u32 = unsafe { ::core::mem::transmute(LTIME) };
            LTIME as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LBYPASS: u32 = unsafe { ::core::mem::transmute(LBYPASS) };
            LBYPASS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 11u8, {
            let DIV: u32 = unsafe { ::core::mem::transmute(DIV) };
            DIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLCTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SYSCTRL_DPLLCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DPLLCTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLCTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLCTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SYSCTRL_DPLLSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl SYSCTRL_DPLLSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn LOCK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LOCK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CLKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LOCK: u8,
        CLKRDY: u8,
        ENABLE: u8,
        DIV: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LOCK: u8 = unsafe { ::core::mem::transmute(LOCK) };
            LOCK as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CLKRDY: u8 = unsafe { ::core::mem::transmute(CLKRDY) };
            CLKRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DIV: u8 = unsafe { ::core::mem::transmute(DIV) };
            DIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SYSCTRL_DPLLSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<SYSCTRL_DPLLSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SYSCTRL_DPLLSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SYSCTRL_DPLLSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SYSCTRL_DPLLSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SYSCTRL_DPLLSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSCTRL_DPLLSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Sysctrl {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: SYSCTRL_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: SYSCTRL_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: SYSCTRL_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0C (R/  32) Power and Clocks Status"]
    pub PCLKSR: SYSCTRL_PCLKSR_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 16) External Multipurpose Crystal Oscillator (XOSC) Control"]
    pub XOSC: SYSCTRL_XOSC_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x14 (R/W 16) 32kHz External Crystal Oscillator (XOSC32K) Control"]
    pub XOSC32K: SYSCTRL_XOSC32K_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 32) 32kHz Internal Oscillator (OSC32K) Control"]
    pub OSC32K: SYSCTRL_OSC32K_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W  8) 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
    pub OSCULP32K: SYSCTRL_OSCULP32K_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) 8MHz Internal Oscillator (OSC8M) Control"]
    pub OSC8M: SYSCTRL_OSC8M_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 16) DFLL48M Control"]
    pub DFLLCTRL: SYSCTRL_DFLLCTRL_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x28 (R/W 32) DFLL48M Value"]
    pub DFLLVAL: SYSCTRL_DFLLVAL_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 32) DFLL48M Multiplier"]
    pub DFLLMUL: SYSCTRL_DFLLMUL_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W  8) DFLL48M Synchronization"]
    pub DFLLSYNC: SYSCTRL_DFLLSYNC_Type,
    pub Reserved5: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x34 (R/W 32) 3.3V Brown-Out Detector (BOD33) Control"]
    pub BOD33: SYSCTRL_BOD33_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x3C (R/W 16) Voltage Regulator System (VREG) Control"]
    pub VREG: SYSCTRL_VREG_Type,
    pub Reserved7: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x40 (R/W 32) Voltage References System (VREF) Control"]
    pub VREF: SYSCTRL_VREF_Type,
    #[doc = "< \\brief Offset: 0x44 (R/W  8) DPLL Control A"]
    pub DPLLCTRLA: SYSCTRL_DPLLCTRLA_Type,
    pub Reserved8: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x48 (R/W 32) DPLL Ratio Control"]
    pub DPLLRATIO: SYSCTRL_DPLLRATIO_Type,
    #[doc = "< \\brief Offset: 0x4C (R/W 32) DPLL Control B"]
    pub DPLLCTRLB: SYSCTRL_DPLLCTRLB_Type,
    #[doc = "< \\brief Offset: 0x50 (R/   8) DPLL Status"]
    pub DPLLSTATUS: SYSCTRL_DPLLSTATUS_Type,
}
#[test]
fn bindgen_test_layout_Sysctrl() {
    assert_eq!(
        ::core::mem::size_of::<Sysctrl>(),
        84usize,
        concat!("Size of: ", stringify!(Sysctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<Sysctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(Sysctrl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).INTENCLR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).INTENSET as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).INTFLAG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).PCLKSR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(PCLKSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).XOSC as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(XOSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).XOSC32K as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(XOSC32K)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved2 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).OSC32K as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(OSC32K)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).OSCULP32K as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(OSCULP32K)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved3 as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).OSC8M as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(OSC8M)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DFLLCTRL as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DFLLCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved4 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DFLLVAL as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DFLLVAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DFLLMUL as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DFLLMUL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DFLLSYNC as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DFLLSYNC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved5 as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).BOD33 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(BOD33)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved6 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).VREG as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(VREG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved7 as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).VREF as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(VREF)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DPLLCTRLA as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DPLLCTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).Reserved8 as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(Reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DPLLRATIO as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DPLLRATIO)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DPLLCTRLB as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DPLLCTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Sysctrl>())).DPLLSTATUS as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Sysctrl),
            "::",
            stringify!(DPLLSTATUS)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_CTRLA_Type__bindgen_ty_1))
    );
}
impl TC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WAVEGEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_WAVEGEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCSYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCSYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        WAVEGEN: u16,
        PRESCALER: u16,
        RUNSTDBY: u16,
        PRESCSYNC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let WAVEGEN: u16 = unsafe { ::core::mem::transmute(WAVEGEN) };
            WAVEGEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let PRESCSYNC: u16 = unsafe { ::core::mem::transmute(PRESCSYNC) };
            PRESCSYNC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_READREQ_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_READREQ_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_READREQ_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_READREQ_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_READREQ_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_READREQ_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_READREQ_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_READREQ_Type__bindgen_ty_1))
    );
}
impl TC_READREQ_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn RCONT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RCONT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RREQ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RREQ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ADDR: u16,
        RCONT: u16,
        RREQ: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ADDR: u16 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let RCONT: u16 = unsafe { ::core::mem::transmute(RCONT) };
            RCONT as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RREQ: u16 = unsafe { ::core::mem::transmute(RREQ) };
            RREQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_READREQ_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_READREQ_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_READREQ_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_READREQ_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_READREQ_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_READREQ_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_READREQ_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_READREQ_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_READREQ_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLBCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLBCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLBCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_CTRLBCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBCLR_Type__bindgen_ty_1))
    );
}
impl TC_CTRLBCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        ONESHOT: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLBCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLBCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLBCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLBSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLBSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLBSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_CTRLBSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBSET_Type__bindgen_ty_1))
    );
}
impl TC_CTRLBSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        ONESHOT: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLBSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLBSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLBSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLC_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_CTRLC_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_CTRLC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLC_Type__bindgen_ty_1))
    );
}
impl TC_CTRLC_Type__bindgen_ty_1 {
    #[inline]
    pub fn INVEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CPTEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CPTEN1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        INVEN0: u8,
        INVEN1: u8,
        CPTEN0: u8,
        CPTEN1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let INVEN0: u8 = unsafe { ::core::mem::transmute(INVEN0) };
            INVEN0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let INVEN1: u8 = unsafe { ::core::mem::transmute(INVEN1) };
            INVEN1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CPTEN0: u8 = unsafe { ::core::mem::transmute(CPTEN0) };
            CPTEN0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CPTEN1: u8 = unsafe { ::core::mem::transmute(CPTEN1) };
            CPTEN1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLC_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_CTRLC_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLC_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLC_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLC_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLC_Type__bindgen_ty_2))
    );
}
impl TC_CTRLC_Type__bindgen_ty_2 {
    #[inline]
    pub fn INVEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CPTEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(INVEN: u8, CPTEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let INVEN: u8 = unsafe { ::core::mem::transmute(INVEN) };
            INVEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let CPTEN: u8 = unsafe { ::core::mem::transmute(CPTEN) };
            CPTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLC_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLC_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLC_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_CTRLC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl TC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl TC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_EVACT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCINV(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCEI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT: u16,
        TCINV: u16,
        TCEI: u16,
        OVFEO: u16,
        MCEO0: u16,
        MCEO1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT: u16 = unsafe { ::core::mem::transmute(EVACT) };
            EVACT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TCINV: u16 = unsafe { ::core::mem::transmute(TCINV) };
            TCINV as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TCEI: u16 = unsafe { ::core::mem::transmute(TCEI) };
            TCEI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OVFEO: u16 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let MCEO0: u16 = unsafe { ::core::mem::transmute(MCEO0) };
            MCEO0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let MCEO1: u16 = unsafe { ::core::mem::transmute(MCEO1) };
            MCEO1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl TC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn MCEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MCEO: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let MCEO: u16 = unsafe { ::core::mem::transmute(MCEO) };
            MCEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl TC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        SYNCRDY: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl TC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type__bindgen_ty_1))
    );
}
impl TC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        SYNCRDY: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type__bindgen_ty_2))
    );
}
impl TC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl TC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        SYNCRDY: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SYNCRDY: u8 = unsafe { ::core::mem::transmute(SYNCRDY) };
            SYNCRDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl TC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_STATUS_Type__bindgen_ty_1))
    );
}
impl TC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn STOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLAVE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SLAVE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STOP: u8,
        SLAVE: u8,
        SYNCBUSY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STOP: u8 = unsafe { ::core::mem::transmute(STOP) };
            STOP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SLAVE: u8 = unsafe { ::core::mem::transmute(SLAVE) };
            SLAVE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT16_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT16_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT16_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_TC_COUNT16_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT16_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT16_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COUNT: u16 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT16_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_COUNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_COUNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_COUNT16_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT16_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT16_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT32_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT32_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT32_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TC_COUNT32_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT32_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT32_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT32_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_COUNT32_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT32_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT32_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_COUNT_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_COUNT_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let COUNT: u8 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_COUNT_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_COUNT_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_PER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_PER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_PER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PER_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_PER_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u8 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PER_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PER_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PER_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_PER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_PER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_PER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT16_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT16_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT16_CC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CC_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT16_CC_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT16_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let CC: u16 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CC_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CC_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CC_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_COUNT16_CC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT16_CC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT16_CC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT32_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT32_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT32_CC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT32_CC_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT32_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CC_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_COUNT32_CC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT32_CC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT32_CC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_CC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_CC_Type__bindgen_ty_1))
    );
}
impl TC_COUNT8_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CC: u8 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CC_Type() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_CC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_CC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TC_COUNT8_CC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount8 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: TC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Control C"]
    pub CTRLC: TC_CTRLC_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0F (R/   8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W  8) COUNT8 Counter Value"]
    pub COUNT: TC_COUNT8_COUNT_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) COUNT8 Period Value"]
    pub PER: TC_COUNT8_PER_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) COUNT8 Compare/Capture"]
    pub CC: [TC_COUNT8_CC_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount8() {
    assert_eq!(
        ::core::mem::size_of::<TcCount8>(),
        26usize,
        concat!("Size of: ", stringify!(TcCount8))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount8>(),
        2usize,
        concat!("Alignment of ", stringify!(TcCount8))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).CTRLBCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).CTRLBSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).CTRLC as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).Reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).DBGCTRL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).Reserved2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).EVCTRL as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).INTENCLR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).INTENSET as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).INTFLAG as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).STATUS as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).COUNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).Reserved3 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).PER as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(PER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).Reserved4 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount8>())).CC as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CC)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount16 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: TC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Control C"]
    pub CTRLC: TC_CTRLC_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0F (R/   8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 16) COUNT16 Counter Value"]
    pub COUNT: TC_COUNT16_COUNT_Type,
    pub Reserved3: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) COUNT16 Compare/Capture"]
    pub CC: [TC_COUNT16_CC_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount16() {
    assert_eq!(
        ::core::mem::size_of::<TcCount16>(),
        28usize,
        concat!("Size of: ", stringify!(TcCount16))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount16>(),
        2usize,
        concat!("Alignment of ", stringify!(TcCount16))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).CTRLBCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).CTRLBSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).CTRLC as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).Reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).DBGCTRL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).Reserved2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).EVCTRL as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).INTENCLR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).INTENSET as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).INTFLAG as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).STATUS as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).COUNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).Reserved3 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount16>())).CC as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CC)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount32 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Read Request"]
    pub READREQ: TC_READREQ_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Control C"]
    pub CTRLC: TC_CTRLC_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0A (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0F (R/   8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) COUNT32 Counter Value"]
    pub COUNT: TC_COUNT32_COUNT_Type,
    pub Reserved3: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 32) COUNT32 Compare/Capture"]
    pub CC: [TC_COUNT32_CC_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount32() {
    assert_eq!(
        ::core::mem::size_of::<TcCount32>(),
        32usize,
        concat!("Size of: ", stringify!(TcCount32))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount32>(),
        4usize,
        concat!("Alignment of ", stringify!(TcCount32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).READREQ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(READREQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).CTRLBCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).CTRLBSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).CTRLC as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).Reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).DBGCTRL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).Reserved2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).EVCTRL as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).INTENCLR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).INTENSET as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).INTFLAG as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).STATUS as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).COUNT as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).Reserved3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TcCount32>())).CC as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CC)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Tc {
    #[doc = "< \\brief Offset: 0x00 8-bit Counter Mode"]
    pub COUNT8: TcCount8,
    #[doc = "< \\brief Offset: 0x00 16-bit Counter Mode"]
    pub COUNT16: TcCount16,
    #[doc = "< \\brief Offset: 0x00 32-bit Counter Mode"]
    pub COUNT32: TcCount32,
    _bindgen_union_align: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_Tc() {
    assert_eq!(
        ::core::mem::size_of::<Tc>(),
        32usize,
        concat!("Size of: ", stringify!(Tc))
    );
    assert_eq!(
        ::core::mem::align_of::<Tc>(),
        4usize,
        concat!("Alignment of ", stringify!(Tc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tc>())).COUNT8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tc>())).COUNT16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tc>())).COUNT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_CTRLA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESOLUTION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESOLUTION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ALOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        RESOLUTION: u32,
        PRESCALER: u32,
        RUNSTDBY: u32,
        PRESCSYNC: u32,
        ALOCK: u32,
        CPTEN0: u32,
        CPTEN1: u32,
        CPTEN2: u32,
        CPTEN3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let RESOLUTION: u32 = unsafe { ::core::mem::transmute(RESOLUTION) };
            RESOLUTION as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let PRESCALER: u32 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let PRESCSYNC: u32 = unsafe { ::core::mem::transmute(PRESCSYNC) };
            PRESCSYNC as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ALOCK: u32 = unsafe { ::core::mem::transmute(ALOCK) };
            ALOCK as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CPTEN0: u32 = unsafe { ::core::mem::transmute(CPTEN0) };
            CPTEN0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CPTEN1: u32 = unsafe { ::core::mem::transmute(CPTEN1) };
            CPTEN1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CPTEN2: u32 = unsafe { ::core::mem::transmute(CPTEN2) };
            CPTEN2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let CPTEN3: u32 = unsafe { ::core::mem::transmute(CPTEN3) };
            CPTEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLA_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type__bindgen_ty_2))
    );
}
impl TCC_CTRLA_Type__bindgen_ty_2 {
    #[inline]
    pub fn CPTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CPTEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let CPTEN: u32 = unsafe { ::core::mem::transmute(CPTEN) };
            CPTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLA_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLBCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLBCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLBCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLBCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBCLR_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLBCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDXCMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IDXCMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        IDXCMD: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let IDXCMD: u8 = unsafe { ::core::mem::transmute(IDXCMD) };
            IDXCMD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLBCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLBCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLBCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLBSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLBSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLBSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLBSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBSET_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLBSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDXCMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IDXCMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        IDXCMD: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let IDXCMD: u8 = unsafe { ::core::mem::transmute(IDXCMD) };
            IDXCMD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLBSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLBSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CTRLBSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl TCC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATUS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STATUS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PATT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PATT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAVE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAVE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PATTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PATTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAVEB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAVEB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCB1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
        STATUS: u32,
        COUNT: u32,
        PATT: u32,
        WAVE: u32,
        PER: u32,
        CC0: u32,
        CC1: u32,
        CC2: u32,
        CC3: u32,
        PATTB: u32,
        WAVEB: u32,
        PERB: u32,
        CCB0: u32,
        CCB1: u32,
        CCB2: u32,
        CCB3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STATUS: u32 = unsafe { ::core::mem::transmute(STATUS) };
            STATUS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PATT: u32 = unsafe { ::core::mem::transmute(PATT) };
            PATT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WAVE: u32 = unsafe { ::core::mem::transmute(WAVE) };
            WAVE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CC0: u32 = unsafe { ::core::mem::transmute(CC0) };
            CC0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CC1: u32 = unsafe { ::core::mem::transmute(CC1) };
            CC1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CC2: u32 = unsafe { ::core::mem::transmute(CC2) };
            CC2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CC3: u32 = unsafe { ::core::mem::transmute(CC3) };
            CC3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PATTB: u32 = unsafe { ::core::mem::transmute(PATTB) };
            PATTB as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let WAVEB: u32 = unsafe { ::core::mem::transmute(WAVEB) };
            WAVEB as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PERB: u32 = unsafe { ::core::mem::transmute(PERB) };
            PERB as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let CCB0: u32 = unsafe { ::core::mem::transmute(CCB0) };
            CCB0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CCB1: u32 = unsafe { ::core::mem::transmute(CCB1) };
            CCB1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let CCB2: u32 = unsafe { ::core::mem::transmute(CCB2) };
            CCB2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let CCB3: u32 = unsafe { ::core::mem::transmute(CCB3) };
            CCB3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_2))
    );
}
impl TCC_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32, CCB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let CCB: u32 = unsafe { ::core::mem::transmute(CCB) };
            CCB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_SYNCBUSY_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_FCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_FCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_FCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_FCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLA_Type__bindgen_ty_1))
    );
}
impl TCC_FCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn KEEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KEEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QUAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QUAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BLANK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RESTART(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RESTART(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_HALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CHSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CHSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTURE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTURE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SRC: u32,
        KEEP: u32,
        QUAL: u32,
        BLANK: u32,
        RESTART: u32,
        HALT: u32,
        CHSEL: u32,
        CAPTURE: u32,
        BLANKVAL: u32,
        FILTERVAL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let KEEP: u32 = unsafe { ::core::mem::transmute(KEEP) };
            KEEP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let QUAL: u32 = unsafe { ::core::mem::transmute(QUAL) };
            QUAL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let BLANK: u32 = unsafe { ::core::mem::transmute(BLANK) };
            BLANK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RESTART: u32 = unsafe { ::core::mem::transmute(RESTART) };
            RESTART as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let HALT: u32 = unsafe { ::core::mem::transmute(HALT) };
            HALT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let CHSEL: u32 = unsafe { ::core::mem::transmute(CHSEL) };
            CHSEL as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let CAPTURE: u32 = unsafe { ::core::mem::transmute(CAPTURE) };
            CAPTURE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BLANKVAL: u32 = unsafe { ::core::mem::transmute(BLANKVAL) };
            BLANKVAL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL: u32 = unsafe { ::core::mem::transmute(FILTERVAL) };
            FILTERVAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_FCTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_FCTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_FCTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_FCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_FCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_FCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_FCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLB_Type__bindgen_ty_1))
    );
}
impl TCC_FCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn KEEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KEEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QUAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QUAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BLANK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RESTART(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RESTART(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_HALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CHSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CHSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTURE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTURE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SRC: u32,
        KEEP: u32,
        QUAL: u32,
        BLANK: u32,
        RESTART: u32,
        HALT: u32,
        CHSEL: u32,
        CAPTURE: u32,
        BLANKVAL: u32,
        FILTERVAL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let KEEP: u32 = unsafe { ::core::mem::transmute(KEEP) };
            KEEP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let QUAL: u32 = unsafe { ::core::mem::transmute(QUAL) };
            QUAL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let BLANK: u32 = unsafe { ::core::mem::transmute(BLANK) };
            BLANK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RESTART: u32 = unsafe { ::core::mem::transmute(RESTART) };
            RESTART as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let HALT: u32 = unsafe { ::core::mem::transmute(HALT) };
            HALT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let CHSEL: u32 = unsafe { ::core::mem::transmute(CHSEL) };
            CHSEL as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let CAPTURE: u32 = unsafe { ::core::mem::transmute(CAPTURE) };
            CAPTURE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BLANKVAL: u32 = unsafe { ::core::mem::transmute(BLANKVAL) };
            BLANKVAL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL: u32 = unsafe { ::core::mem::transmute(FILTERVAL) };
            FILTERVAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_FCTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_FCTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_FCTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_WEXCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_WEXCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_WEXCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WEXCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_WEXCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn OTMX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_OTMX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTLS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DTLS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DTHS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DTHS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OTMX: u32,
        DTIEN0: u32,
        DTIEN1: u32,
        DTIEN2: u32,
        DTIEN3: u32,
        DTLS: u32,
        DTHS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let OTMX: u32 = unsafe { ::core::mem::transmute(OTMX) };
            OTMX as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DTIEN0: u32 = unsafe { ::core::mem::transmute(DTIEN0) };
            DTIEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DTIEN1: u32 = unsafe { ::core::mem::transmute(DTIEN1) };
            DTIEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DTIEN2: u32 = unsafe { ::core::mem::transmute(DTIEN2) };
            DTIEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DTIEN3: u32 = unsafe { ::core::mem::transmute(DTIEN3) };
            DTIEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let DTLS: u32 = unsafe { ::core::mem::transmute(DTLS) };
            DTLS as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let DTHS: u32 = unsafe { ::core::mem::transmute(DTHS) };
            DTHS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WEXCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_WEXCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn DTIEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DTIEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let DTIEN: u32 = unsafe { ::core::mem::transmute(DTIEN) };
            DTIEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WEXCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WEXCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WEXCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_DRVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_DRVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_DRVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DRVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_DRVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn NRE0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NRE0: u32,
        NRE1: u32,
        NRE2: u32,
        NRE3: u32,
        NRE4: u32,
        NRE5: u32,
        NRE6: u32,
        NRE7: u32,
        NRV0: u32,
        NRV1: u32,
        NRV2: u32,
        NRV3: u32,
        NRV4: u32,
        NRV5: u32,
        NRV6: u32,
        NRV7: u32,
        INVEN0: u32,
        INVEN1: u32,
        INVEN2: u32,
        INVEN3: u32,
        INVEN4: u32,
        INVEN5: u32,
        INVEN6: u32,
        INVEN7: u32,
        FILTERVAL0: u32,
        FILTERVAL1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NRE0: u32 = unsafe { ::core::mem::transmute(NRE0) };
            NRE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NRE1: u32 = unsafe { ::core::mem::transmute(NRE1) };
            NRE1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NRE2: u32 = unsafe { ::core::mem::transmute(NRE2) };
            NRE2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NRE3: u32 = unsafe { ::core::mem::transmute(NRE3) };
            NRE3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NRE4: u32 = unsafe { ::core::mem::transmute(NRE4) };
            NRE4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NRE5: u32 = unsafe { ::core::mem::transmute(NRE5) };
            NRE5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NRE6: u32 = unsafe { ::core::mem::transmute(NRE6) };
            NRE6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NRE7: u32 = unsafe { ::core::mem::transmute(NRE7) };
            NRE7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NRV0: u32 = unsafe { ::core::mem::transmute(NRV0) };
            NRV0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let NRV1: u32 = unsafe { ::core::mem::transmute(NRV1) };
            NRV1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NRV2: u32 = unsafe { ::core::mem::transmute(NRV2) };
            NRV2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let NRV3: u32 = unsafe { ::core::mem::transmute(NRV3) };
            NRV3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let NRV4: u32 = unsafe { ::core::mem::transmute(NRV4) };
            NRV4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let NRV5: u32 = unsafe { ::core::mem::transmute(NRV5) };
            NRV5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let NRV6: u32 = unsafe { ::core::mem::transmute(NRV6) };
            NRV6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NRV7: u32 = unsafe { ::core::mem::transmute(NRV7) };
            NRV7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let INVEN0: u32 = unsafe { ::core::mem::transmute(INVEN0) };
            INVEN0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let INVEN1: u32 = unsafe { ::core::mem::transmute(INVEN1) };
            INVEN1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let INVEN2: u32 = unsafe { ::core::mem::transmute(INVEN2) };
            INVEN2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let INVEN3: u32 = unsafe { ::core::mem::transmute(INVEN3) };
            INVEN3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let INVEN4: u32 = unsafe { ::core::mem::transmute(INVEN4) };
            INVEN4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let INVEN5: u32 = unsafe { ::core::mem::transmute(INVEN5) };
            INVEN5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let INVEN6: u32 = unsafe { ::core::mem::transmute(INVEN6) };
            INVEN6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let INVEN7: u32 = unsafe { ::core::mem::transmute(INVEN7) };
            INVEN7 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL0: u32 = unsafe { ::core::mem::transmute(FILTERVAL0) };
            FILTERVAL0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let FILTERVAL1: u32 = unsafe { ::core::mem::transmute(FILTERVAL1) };
            FILTERVAL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DRVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_DRVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn NRE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_NRE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_NRV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NRE: u32,
        NRV: u32,
        INVEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let NRE: u32 = unsafe { ::core::mem::transmute(NRE) };
            NRE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let NRV: u32 = unsafe { ::core::mem::transmute(NRV) };
            NRV as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let INVEN: u32 = unsafe { ::core::mem::transmute(INVEN) };
            INVEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_DRVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_DRVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_DRVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FDDBD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FDDBD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8, FDDBD: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FDDBD: u8 = unsafe { ::core::mem::transmute(FDDBD) };
            FDDBD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_DBGCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_DBGCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_DBGCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CNTSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CNTSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRGEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRGEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNTEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNTEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT0: u32,
        EVACT1: u32,
        CNTSEL: u32,
        OVFEO: u32,
        TRGEO: u32,
        CNTEO: u32,
        TCINV0: u32,
        TCINV1: u32,
        TCEI0: u32,
        TCEI1: u32,
        MCEI0: u32,
        MCEI1: u32,
        MCEI2: u32,
        MCEI3: u32,
        MCEO0: u32,
        MCEO1: u32,
        MCEO2: u32,
        MCEO3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT0: u32 = unsafe { ::core::mem::transmute(EVACT0) };
            EVACT0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let EVACT1: u32 = unsafe { ::core::mem::transmute(EVACT1) };
            EVACT1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CNTSEL: u32 = unsafe { ::core::mem::transmute(CNTSEL) };
            CNTSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OVFEO: u32 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TRGEO: u32 = unsafe { ::core::mem::transmute(TRGEO) };
            TRGEO as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CNTEO: u32 = unsafe { ::core::mem::transmute(CNTEO) };
            CNTEO as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TCINV0: u32 = unsafe { ::core::mem::transmute(TCINV0) };
            TCINV0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TCINV1: u32 = unsafe { ::core::mem::transmute(TCINV1) };
            TCINV1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TCEI0: u32 = unsafe { ::core::mem::transmute(TCEI0) };
            TCEI0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TCEI1: u32 = unsafe { ::core::mem::transmute(TCEI1) };
            TCEI1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MCEI0: u32 = unsafe { ::core::mem::transmute(MCEI0) };
            MCEI0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MCEI1: u32 = unsafe { ::core::mem::transmute(MCEI1) };
            MCEI1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MCEI2: u32 = unsafe { ::core::mem::transmute(MCEI2) };
            MCEI2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MCEI3: u32 = unsafe { ::core::mem::transmute(MCEI3) };
            MCEI3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let MCEO0: u32 = unsafe { ::core::mem::transmute(MCEO0) };
            MCEO0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let MCEO1: u32 = unsafe { ::core::mem::transmute(MCEO1) };
            MCEO1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let MCEO2: u32 = unsafe { ::core::mem::transmute(MCEO2) };
            MCEO2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let MCEO3: u32 = unsafe { ::core::mem::transmute(MCEO3) };
            MCEO3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn TCINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TCINV: u32,
        TCEI: u32,
        MCEI: u32,
        MCEO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TCINV: u32 = unsafe { ::core::mem::transmute(TCINV) };
            TCINV as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let TCEI: u32 = unsafe { ::core::mem::transmute(TCEI) };
            TCEI as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MCEI: u32 = unsafe { ::core::mem::transmute(MCEI) };
            MCEI as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let MCEO: u32 = unsafe { ::core::mem::transmute(MCEO) };
            MCEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_EVCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_EVCTRL_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_EVCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl TCC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl TCC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type__bindgen_ty_1))
    );
}
impl TCC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type__bindgen_ty_2))
    );
}
impl TCC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl TCC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl TCC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_STATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type__bindgen_ty_1))
    );
}
impl TCC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn STOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IDX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLAVE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLAVE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PATTBV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PATTBV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAVEBV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAVEBV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERBV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTAIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTAIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTBIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTBIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0IN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0IN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1IN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1IN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBV2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBV2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBV3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBV3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STOP: u32,
        IDX: u32,
        DFS: u32,
        SLAVE: u32,
        PATTBV: u32,
        WAVEBV: u32,
        PERBV: u32,
        FAULTAIN: u32,
        FAULTBIN: u32,
        FAULT0IN: u32,
        FAULT1IN: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        CCBV0: u32,
        CCBV1: u32,
        CCBV2: u32,
        CCBV3: u32,
        CMP0: u32,
        CMP1: u32,
        CMP2: u32,
        CMP3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STOP: u32 = unsafe { ::core::mem::transmute(STOP) };
            STOP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IDX: u32 = unsafe { ::core::mem::transmute(IDX) };
            IDX as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SLAVE: u32 = unsafe { ::core::mem::transmute(SLAVE) };
            SLAVE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PATTBV: u32 = unsafe { ::core::mem::transmute(PATTBV) };
            PATTBV as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WAVEBV: u32 = unsafe { ::core::mem::transmute(WAVEBV) };
            WAVEBV as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PERBV: u32 = unsafe { ::core::mem::transmute(PERBV) };
            PERBV as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let FAULTAIN: u32 = unsafe { ::core::mem::transmute(FAULTAIN) };
            FAULTAIN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let FAULTBIN: u32 = unsafe { ::core::mem::transmute(FAULTBIN) };
            FAULTBIN as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let FAULT0IN: u32 = unsafe { ::core::mem::transmute(FAULT0IN) };
            FAULT0IN as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FAULT1IN: u32 = unsafe { ::core::mem::transmute(FAULT1IN) };
            FAULT1IN as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CCBV0: u32 = unsafe { ::core::mem::transmute(CCBV0) };
            CCBV0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CCBV1: u32 = unsafe { ::core::mem::transmute(CCBV1) };
            CCBV1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CCBV2: u32 = unsafe { ::core::mem::transmute(CCBV2) };
            CCBV2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let CCBV3: u32 = unsafe { ::core::mem::transmute(CCBV3) };
            CCBV3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CMP0: u32 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CMP1: u32 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CMP2: u32 = unsafe { ::core::mem::transmute(CMP2) };
            CMP2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let CMP3: u32 = unsafe { ::core::mem::transmute(CMP3) };
            CMP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_STATUS_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type__bindgen_ty_2))
    );
}
impl TCC_STATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn CCBV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCBV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBV: u32, CMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CCBV: u32 = unsafe { ::core::mem::transmute(CCBV) };
            CCBV as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let CMP: u32 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_STATUS_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_COUNT_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_COUNT_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_COUNT_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_COUNT_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_COUNT_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_1))
    );
}
impl TCC_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_2))
    );
}
impl TCC_COUNT_Type__bindgen_ty_2 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_3))
    );
}
impl TCC_COUNT_Type__bindgen_ty_3 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_4))
    );
}
impl TCC_COUNT_Type__bindgen_ty_4 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_COUNT_Type>())).DITH4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_COUNT_Type>())).DITH5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_COUNT_Type>())).DITH6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_COUNT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_COUNT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PATT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PATT_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_PATT_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATT_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type__bindgen_ty_1))
    );
}
impl TCC_PATT_Type__bindgen_ty_1 {
    #[inline]
    pub fn PGE0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PGE0: u16,
        PGE1: u16,
        PGE2: u16,
        PGE3: u16,
        PGE4: u16,
        PGE5: u16,
        PGE6: u16,
        PGE7: u16,
        PGV0: u16,
        PGV1: u16,
        PGV2: u16,
        PGV3: u16,
        PGV4: u16,
        PGV5: u16,
        PGV6: u16,
        PGV7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PGE0: u16 = unsafe { ::core::mem::transmute(PGE0) };
            PGE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PGE1: u16 = unsafe { ::core::mem::transmute(PGE1) };
            PGE1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PGE2: u16 = unsafe { ::core::mem::transmute(PGE2) };
            PGE2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PGE3: u16 = unsafe { ::core::mem::transmute(PGE3) };
            PGE3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PGE4: u16 = unsafe { ::core::mem::transmute(PGE4) };
            PGE4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PGE5: u16 = unsafe { ::core::mem::transmute(PGE5) };
            PGE5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PGE6: u16 = unsafe { ::core::mem::transmute(PGE6) };
            PGE6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PGE7: u16 = unsafe { ::core::mem::transmute(PGE7) };
            PGE7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PGV0: u16 = unsafe { ::core::mem::transmute(PGV0) };
            PGV0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PGV1: u16 = unsafe { ::core::mem::transmute(PGV1) };
            PGV1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PGV2: u16 = unsafe { ::core::mem::transmute(PGV2) };
            PGV2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PGV3: u16 = unsafe { ::core::mem::transmute(PGV3) };
            PGV3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PGV4: u16 = unsafe { ::core::mem::transmute(PGV4) };
            PGV4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PGV5: u16 = unsafe { ::core::mem::transmute(PGV5) };
            PGV5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PGV6: u16 = unsafe { ::core::mem::transmute(PGV6) };
            PGV6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PGV7: u16 = unsafe { ::core::mem::transmute(PGV7) };
            PGV7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATT_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type__bindgen_ty_2))
    );
}
impl TCC_PATT_Type__bindgen_ty_2 {
    #[inline]
    pub fn PGE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGV(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PGE: u16, PGV: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PGE: u16 = unsafe { ::core::mem::transmute(PGE) };
            PGE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PGV: u16 = unsafe { ::core::mem::transmute(PGV) };
            PGV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATT_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATT_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATT_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_WAVE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_WAVE_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_WAVE_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type__bindgen_ty_1))
    );
}
impl TCC_WAVE_Type__bindgen_ty_1 {
    #[inline]
    pub fn WAVEGEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_WAVEGEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RAMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CIPEREN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CIPEREN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WAVEGEN: u32,
        RAMP: u32,
        CIPEREN: u32,
        CICCEN0: u32,
        CICCEN1: u32,
        CICCEN2: u32,
        CICCEN3: u32,
        POL0: u32,
        POL1: u32,
        POL2: u32,
        POL3: u32,
        SWAP0: u32,
        SWAP1: u32,
        SWAP2: u32,
        SWAP3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let WAVEGEN: u32 = unsafe { ::core::mem::transmute(WAVEGEN) };
            WAVEGEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RAMP: u32 = unsafe { ::core::mem::transmute(RAMP) };
            RAMP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CIPEREN: u32 = unsafe { ::core::mem::transmute(CIPEREN) };
            CIPEREN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CICCEN0: u32 = unsafe { ::core::mem::transmute(CICCEN0) };
            CICCEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CICCEN1: u32 = unsafe { ::core::mem::transmute(CICCEN1) };
            CICCEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CICCEN2: u32 = unsafe { ::core::mem::transmute(CICCEN2) };
            CICCEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CICCEN3: u32 = unsafe { ::core::mem::transmute(CICCEN3) };
            CICCEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let POL0: u32 = unsafe { ::core::mem::transmute(POL0) };
            POL0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let POL1: u32 = unsafe { ::core::mem::transmute(POL1) };
            POL1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let POL2: u32 = unsafe { ::core::mem::transmute(POL2) };
            POL2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let POL3: u32 = unsafe { ::core::mem::transmute(POL3) };
            POL3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let SWAP0: u32 = unsafe { ::core::mem::transmute(SWAP0) };
            SWAP0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let SWAP1: u32 = unsafe { ::core::mem::transmute(SWAP1) };
            SWAP1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let SWAP2: u32 = unsafe { ::core::mem::transmute(SWAP2) };
            SWAP2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SWAP3: u32 = unsafe { ::core::mem::transmute(SWAP3) };
            SWAP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVE_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type__bindgen_ty_2))
    );
}
impl TCC_WAVE_Type__bindgen_ty_2 {
    #[inline]
    pub fn CICCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn POL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_POL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CICCEN: u32,
        POL: u32,
        SWAP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let CICCEN: u32 = unsafe { ::core::mem::transmute(CICCEN) };
            CICCEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let POL: u32 = unsafe { ::core::mem::transmute(POL) };
            POL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let SWAP: u32 = unsafe { ::core::mem::transmute(SWAP) };
            SWAP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVE_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PER_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_PER_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_PER_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_PER_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PER_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_1))
    );
}
impl TCC_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_2))
    );
}
impl TCC_PER_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_3))
    );
}
impl TCC_PER_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_4))
    );
}
impl TCC_PER_Type__bindgen_ty_4 {
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PER_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PER_Type>())).DITH4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PER_Type>())).DITH5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PER_Type>())).DITH6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PER_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PER_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CC_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_CC_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_CC_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_CC_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CC_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_1))
    );
}
impl TCC_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_2))
    );
}
impl TCC_CC_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_3))
    );
}
impl TCC_CC_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERCY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCY: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERCY: u32 = unsafe { ::core::mem::transmute(DITHERCY) };
            DITHERCY as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_4))
    );
}
impl TCC_CC_Type__bindgen_ty_4 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CC_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CC_Type>())).DITH4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CC_Type>())).DITH5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CC_Type>())).DITH6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PATTB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PATTB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_PATTB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATTB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_PATTB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTB_Type__bindgen_ty_1))
    );
}
impl TCC_PATTB_Type__bindgen_ty_1 {
    #[inline]
    pub fn PGEB0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PGEB0: u16,
        PGEB1: u16,
        PGEB2: u16,
        PGEB3: u16,
        PGEB4: u16,
        PGEB5: u16,
        PGEB6: u16,
        PGEB7: u16,
        PGVB0: u16,
        PGVB1: u16,
        PGVB2: u16,
        PGVB3: u16,
        PGVB4: u16,
        PGVB5: u16,
        PGVB6: u16,
        PGVB7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PGEB0: u16 = unsafe { ::core::mem::transmute(PGEB0) };
            PGEB0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PGEB1: u16 = unsafe { ::core::mem::transmute(PGEB1) };
            PGEB1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PGEB2: u16 = unsafe { ::core::mem::transmute(PGEB2) };
            PGEB2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PGEB3: u16 = unsafe { ::core::mem::transmute(PGEB3) };
            PGEB3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PGEB4: u16 = unsafe { ::core::mem::transmute(PGEB4) };
            PGEB4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PGEB5: u16 = unsafe { ::core::mem::transmute(PGEB5) };
            PGEB5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PGEB6: u16 = unsafe { ::core::mem::transmute(PGEB6) };
            PGEB6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PGEB7: u16 = unsafe { ::core::mem::transmute(PGEB7) };
            PGEB7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PGVB0: u16 = unsafe { ::core::mem::transmute(PGVB0) };
            PGVB0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PGVB1: u16 = unsafe { ::core::mem::transmute(PGVB1) };
            PGVB1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PGVB2: u16 = unsafe { ::core::mem::transmute(PGVB2) };
            PGVB2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PGVB3: u16 = unsafe { ::core::mem::transmute(PGVB3) };
            PGVB3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PGVB4: u16 = unsafe { ::core::mem::transmute(PGVB4) };
            PGVB4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PGVB5: u16 = unsafe { ::core::mem::transmute(PGVB5) };
            PGVB5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PGVB6: u16 = unsafe { ::core::mem::transmute(PGVB6) };
            PGVB6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PGVB7: u16 = unsafe { ::core::mem::transmute(PGVB7) };
            PGVB7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATTB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_PATTB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTB_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTB_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTB_Type__bindgen_ty_2))
    );
}
impl TCC_PATTB_Type__bindgen_ty_2 {
    #[inline]
    pub fn PGEB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PGEB: u16, PGVB: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PGEB: u16 = unsafe { ::core::mem::transmute(PGEB) };
            PGEB as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PGVB: u16 = unsafe { ::core::mem::transmute(PGVB) };
            PGVB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PATTB_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATTB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATTB_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PATTB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_WAVEB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_WAVEB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_WAVEB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVEB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WAVEB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVEB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVEB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVEB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVEB_Type__bindgen_ty_1))
    );
}
impl TCC_WAVEB_Type__bindgen_ty_1 {
    #[inline]
    pub fn WAVEGENB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_WAVEGENB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMPB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RAMPB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CIPERENB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CIPERENB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCENB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCENB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCENB1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCENB1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCENB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCENB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCENB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCENB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POLB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POLB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POLB1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POLB1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POLB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POLB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POLB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POLB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAPB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAPB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAPB1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAPB1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAPB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAPB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAPB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAPB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WAVEGENB: u32,
        RAMPB: u32,
        CIPERENB: u32,
        CICCENB0: u32,
        CICCENB1: u32,
        CICCENB2: u32,
        CICCENB3: u32,
        POLB0: u32,
        POLB1: u32,
        POLB2: u32,
        POLB3: u32,
        SWAPB0: u32,
        SWAPB1: u32,
        SWAPB2: u32,
        SWAPB3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let WAVEGENB: u32 = unsafe { ::core::mem::transmute(WAVEGENB) };
            WAVEGENB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RAMPB: u32 = unsafe { ::core::mem::transmute(RAMPB) };
            RAMPB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CIPERENB: u32 = unsafe { ::core::mem::transmute(CIPERENB) };
            CIPERENB as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CICCENB0: u32 = unsafe { ::core::mem::transmute(CICCENB0) };
            CICCENB0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CICCENB1: u32 = unsafe { ::core::mem::transmute(CICCENB1) };
            CICCENB1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CICCENB2: u32 = unsafe { ::core::mem::transmute(CICCENB2) };
            CICCENB2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CICCENB3: u32 = unsafe { ::core::mem::transmute(CICCENB3) };
            CICCENB3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let POLB0: u32 = unsafe { ::core::mem::transmute(POLB0) };
            POLB0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let POLB1: u32 = unsafe { ::core::mem::transmute(POLB1) };
            POLB1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let POLB2: u32 = unsafe { ::core::mem::transmute(POLB2) };
            POLB2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let POLB3: u32 = unsafe { ::core::mem::transmute(POLB3) };
            POLB3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let SWAPB0: u32 = unsafe { ::core::mem::transmute(SWAPB0) };
            SWAPB0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let SWAPB1: u32 = unsafe { ::core::mem::transmute(SWAPB1) };
            SWAPB1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let SWAPB2: u32 = unsafe { ::core::mem::transmute(SWAPB2) };
            SWAPB2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SWAPB3: u32 = unsafe { ::core::mem::transmute(SWAPB3) };
            SWAPB3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVEB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_TCC_WAVEB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVEB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVEB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVEB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVEB_Type__bindgen_ty_2))
    );
}
impl TCC_WAVEB_Type__bindgen_ty_2 {
    #[inline]
    pub fn CICCENB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CICCENB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn POLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_POLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAPB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SWAPB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CICCENB: u32,
        POLB: u32,
        SWAPB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let CICCENB: u32 = unsafe { ::core::mem::transmute(CICCENB) };
            CICCENB as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let POLB: u32 = unsafe { ::core::mem::transmute(POLB) };
            POLB as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let SWAPB: u32 = unsafe { ::core::mem::transmute(SWAPB) };
            SWAPB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_WAVEB_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVEB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVEB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVEB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVEB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVEB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVEB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVEB_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVEB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_WAVEB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVEB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PERB_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_PERB_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_PERB_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_PERB_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PERB_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PERB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERB_Type__bindgen_ty_1))
    );
}
impl TCC_PERB_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PERB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PERB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, PERB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let PERB: u32 = unsafe { ::core::mem::transmute(PERB) };
            PERB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PERB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERB_Type__bindgen_ty_2))
    );
}
impl TCC_PERB_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PERB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_PERB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, PERB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let PERB: u32 = unsafe { ::core::mem::transmute(PERB) };
            PERB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERB_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PERB_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERB_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERB_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERB_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERB_Type__bindgen_ty_3))
    );
}
impl TCC_PERB_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PERB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_PERB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, PERB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let PERB: u32 = unsafe { ::core::mem::transmute(PERB) };
            PERB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERB_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_PERB_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERB_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERB_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERB_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERB_Type__bindgen_ty_4))
    );
}
impl TCC_PERB_Type__bindgen_ty_4 {
    #[inline]
    pub fn PERB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PERB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PERB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let PERB: u32 = unsafe { ::core::mem::transmute(PERB) };
            PERB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PERB_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PERB_Type>())).DITH4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERB_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PERB_Type>())).DITH5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERB_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PERB_Type>())).DITH6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERB_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PERB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_PERB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CCB_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_CCB_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_CCB_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_CCB_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CCB_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CCB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCB_Type__bindgen_ty_1))
    );
}
impl TCC_CCB_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_CCB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, CCB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let CCB: u32 = unsafe { ::core::mem::transmute(CCB) };
            CCB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCB_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CCB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCB_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCB_Type__bindgen_ty_2))
    );
}
impl TCC_CCB_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_CCB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, CCB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let CCB: u32 = unsafe { ::core::mem::transmute(CCB) };
            CCB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCB_Type__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CCB_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCB_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCB_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCB_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCB_Type__bindgen_ty_3))
    );
}
impl TCC_CCB_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERCYB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERCYB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn CCB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_CCB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERCYB: u32, CCB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERCYB: u32 = unsafe { ::core::mem::transmute(DITHERCYB) };
            DITHERCYB as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let CCB: u32 = unsafe { ::core::mem::transmute(CCB) };
            CCB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCB_Type__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_TCC_CCB_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCB_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCB_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCB_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCB_Type__bindgen_ty_4))
    );
}
impl TCC_CCB_Type__bindgen_ty_4 {
    #[inline]
    pub fn CCB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_CCB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCB: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let CCB: u32 = unsafe { ::core::mem::transmute(CCB) };
            CCB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CCB_Type>())).DITH4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCB_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CCB_Type>())).DITH5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCB_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CCB_Type>())).DITH6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCB_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CCB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TCC_CCB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Tcc {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: TCC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TCC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TCC_CTRLBSET_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x08 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: TCC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Recoverable Fault A Configuration"]
    pub FCTRLA: TCC_FCTRLA_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Recoverable Fault B Configuration"]
    pub FCTRLB: TCC_FCTRLB_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Waveform Extension Configuration"]
    pub WEXCTRL: TCC_WEXCTRL_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Driver Control"]
    pub DRVCTRL: TCC_DRVCTRL_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1E (R/W  8) Debug Control"]
    pub DBGCTRL: TCC_DBGCTRL_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Event Control"]
    pub EVCTRL: TCC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: TCC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: TCC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: TCC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W 32) Status"]
    pub STATUS: TCC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W 32) Count"]
    pub COUNT: TCC_COUNT_Type,
    #[doc = "< \\brief Offset: 0x38 (R/W 16) Pattern"]
    pub PATT: TCC_PATT_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x3C (R/W 32) Waveform Control"]
    pub WAVE: TCC_WAVE_Type,
    #[doc = "< \\brief Offset: 0x40 (R/W 32) Period"]
    pub PER: TCC_PER_Type,
    #[doc = "< \\brief Offset: 0x44 (R/W 32) Compare and Capture"]
    pub CC: [TCC_CC_Type; 4usize],
    pub Reserved5: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x64 (R/W 16) Pattern Buffer"]
    pub PATTB: TCC_PATTB_Type,
    pub Reserved6: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x68 (R/W 32) Waveform Control Buffer"]
    pub WAVEB: TCC_WAVEB_Type,
    #[doc = "< \\brief Offset: 0x6C (R/W 32) Period Buffer"]
    pub PERB: TCC_PERB_Type,
    #[doc = "< \\brief Offset: 0x70 (R/W 32) Compare and Capture Buffer"]
    pub CCB: [TCC_CCB_Type; 4usize],
}
#[test]
fn bindgen_test_layout_Tcc() {
    assert_eq!(
        ::core::mem::size_of::<Tcc>(),
        128usize,
        concat!("Size of: ", stringify!(Tcc))
    );
    assert_eq!(
        ::core::mem::align_of::<Tcc>(),
        4usize,
        concat!("Alignment of ", stringify!(Tcc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).CTRLBCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).CTRLBSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).SYNCBUSY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).FCTRLA as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(FCTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).FCTRLB as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(FCTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).WEXCTRL as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(WEXCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).DRVCTRL as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(DRVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).DBGCTRL as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved3 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).EVCTRL as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).INTENCLR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).INTENSET as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).INTFLAG as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).STATUS as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).COUNT as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).PATT as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(PATT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved4 as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).WAVE as *const _ as usize },
        60usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(WAVE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).PER as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(PER))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).CC as *const _ as usize },
        68usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(CC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved5 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).PATTB as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(PATTB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).Reserved6 as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).WAVEB as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(WAVEB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).PERB as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(PERB))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Tcc>())).CCB as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(CCB))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_CTRLA_Type__bindgen_ty_1))
    );
}
impl USB_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
        MODE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MODE: u8 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_CTRLA_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_CTRLA_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_CTRLA_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_CTRLA_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_SYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_SYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl USB_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_SYNCBUSY_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_SYNCBUSY_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_SYNCBUSY_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_SYNCBUSY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_SYNCBUSY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_QOSCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_QOSCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_QOSCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_QOSCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_QOSCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_QOSCTRL_Type__bindgen_ty_1))
    );
}
impl USB_QOSCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CQOS: u8, DQOS: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CQOS: u8 = unsafe { ::core::mem::transmute(CQOS) };
            CQOS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let DQOS: u8 = unsafe { ::core::mem::transmute(DQOS) };
            DQOS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_QOSCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_QOSCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_QOSCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_QOSCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_QOSCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_QOSCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_QOSCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_QOSCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_QOSCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn DETACH(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DETACH(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPDCONF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_SPDCONF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NREPLY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NREPLY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTPCKT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTPCKT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OPMODE2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OPMODE2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GNAK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GNAK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMHDSK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_LPMHDSK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DETACH: u16,
        UPRSM: u16,
        SPDCONF: u16,
        NREPLY: u16,
        TSTJ: u16,
        TSTK: u16,
        TSTPCKT: u16,
        OPMODE2: u16,
        GNAK: u16,
        LPMHDSK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DETACH: u16 = unsafe { ::core::mem::transmute(DETACH) };
            DETACH as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPDCONF: u16 = unsafe { ::core::mem::transmute(SPDCONF) };
            SPDCONF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NREPLY: u16 = unsafe { ::core::mem::transmute(NREPLY) };
            NREPLY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TSTJ: u16 = unsafe { ::core::mem::transmute(TSTJ) };
            TSTJ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TSTK: u16 = unsafe { ::core::mem::transmute(TSTK) };
            TSTK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TSTPCKT: u16 = unsafe { ::core::mem::transmute(TSTPCKT) };
            TSTPCKT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OPMODE2: u16 = unsafe { ::core::mem::transmute(OPMODE2) };
            OPMODE2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GNAK: u16 = unsafe { ::core::mem::transmute(GNAK) };
            GNAK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let LPMHDSK: u16 = unsafe { ::core::mem::transmute(LPMHDSK) };
            LPMHDSK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESUME(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RESUME(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPDCONF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_SPDCONF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOFE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOFE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSRESET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSRESET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VBUSOK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VBUSOK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn L1RESUME(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_L1RESUME(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESUME: u16,
        SPDCONF: u16,
        TSTJ: u16,
        TSTK: u16,
        SOFE: u16,
        BUSRESET: u16,
        VBUSOK: u16,
        L1RESUME: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RESUME: u16 = unsafe { ::core::mem::transmute(RESUME) };
            RESUME as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPDCONF: u16 = unsafe { ::core::mem::transmute(SPDCONF) };
            SPDCONF as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TSTJ: u16 = unsafe { ::core::mem::transmute(TSTJ) };
            TSTJ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TSTK: u16 = unsafe { ::core::mem::transmute(TSTK) };
            TSTK as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SOFE: u16 = unsafe { ::core::mem::transmute(SOFE) };
            SOFE as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BUSRESET: u16 = unsafe { ::core::mem::transmute(BUSRESET) };
            BUSRESET as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VBUSOK: u16 = unsafe { ::core::mem::transmute(VBUSOK) };
            VBUSOK as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let L1RESUME: u16 = unsafe { ::core::mem::transmute(L1RESUME) };
            L1RESUME as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_CTRLB_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_CTRLB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_CTRLB_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_CTRLB_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_DADD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_DADD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_DADD_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_DADD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_DADD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_DADD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_DADD_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_DADD_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_DADD_Type__bindgen_ty_1 {
    #[inline]
    pub fn DADD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_DADD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADDEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DADD: u8, ADDEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let DADD: u8 = unsafe { ::core::mem::transmute(DADD) };
            DADD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ADDEN: u8 = unsafe { ::core::mem::transmute(ADDEN) };
            ADDEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_DADD_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_DADD_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_DADD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_DADD_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_DADD_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_DADD_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_DADD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_DADD_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_DADD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_HSOFC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_HSOFC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_HSOFC_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_HSOFC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_HSOFC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_HSOFC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_HSOFC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_HSOFC_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_HSOFC_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLENC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_FLENC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn FLENCE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FLENCE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FLENC: u8, FLENCE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FLENC: u8 = unsafe { ::core::mem::transmute(FLENC) };
            FLENC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let FLENCE: u8 = unsafe { ::core::mem::transmute(FLENCE) };
            FLENCE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_HSOFC_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_HSOFC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_HSOFC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_HSOFC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_HSOFC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_HSOFC_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_HSOFC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_HSOFC_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_HSOFC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SPEED(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LINESTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_LINESTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SPEED: u8, LINESTATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPEED: u8 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let LINESTATE: u8 = unsafe { ::core::mem::transmute(LINESTATE) };
            LINESTATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SPEED(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LINESTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_LINESTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SPEED: u8, LINESTATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPEED: u8 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let LINESTATE: u8 = unsafe { ::core::mem::transmute(LINESTATE) };
            LINESTATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_FSMSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_FSMSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_FSMSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_FSMSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_FSMSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_FSMSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_FSMSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_FSMSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_FSMSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn FSMSTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_FSMSTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FSMSTATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let FSMSTATE: u8 = unsafe { ::core::mem::transmute(FSMSTATE) };
            FSMSTATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_FSMSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_FSMSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_FSMSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_FSMSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_FSMSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_FSMSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_FSMSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_FSMSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_FSMSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_FNUM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_FNUM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_FNUM_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_FNUM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_FNUM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_FNUM_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_FNUM_Type__bindgen_ty_1 {
    #[inline]
    pub fn MFNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MFNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_FNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn FNCERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FNCERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MFNUM: u16,
        FNUM: u16,
        FNCERR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let MFNUM: u16 = unsafe { ::core::mem::transmute(MFNUM) };
            MFNUM as u64
        });
        __bindgen_bitfield_unit.set(3usize, 11u8, {
            let FNUM: u16 = unsafe { ::core::mem::transmute(FNUM) };
            FNUM as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FNCERR: u16 = unsafe { ::core::mem::transmute(FNCERR) };
            FNCERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_FNUM_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_FNUM_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_FNUM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_FNUM_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_FNUM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_FNUM_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_FNUM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_FNUM_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_FNUM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_FNUM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_FNUM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_FNUM_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_HOST_FNUM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_FNUM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_FNUM_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_FNUM_Type__bindgen_ty_1 {
    #[inline]
    pub fn MFNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MFNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_FNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MFNUM: u16, FNUM: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let MFNUM: u16 = unsafe { ::core::mem::transmute(MFNUM) };
            MFNUM as u64
        });
        __bindgen_bitfield_unit.set(3usize, 11u8, {
            let FNUM: u16 = unsafe { ::core::mem::transmute(FNUM) };
            FNUM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_FNUM_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_FNUM_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_FNUM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_FNUM_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_FNUM_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_FNUM_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_FNUM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_FNUM_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_FNUM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_FLENHIGH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_FLENHIGH_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_FLENHIGH_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_FLENHIGH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_FLENHIGH_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_FLENHIGH_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_FLENHIGH_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_FLENHIGH_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_FLENHIGH_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLENHIGH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_FLENHIGH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FLENHIGH: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let FLENHIGH: u8 = unsafe { ::core::mem::transmute(FLENHIGH) };
            FLENHIGH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_FLENHIGH_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_FLENHIGH_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_FLENHIGH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_FLENHIGH_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_FLENHIGH_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_FLENHIGH_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_FLENHIGH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_FLENHIGH_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_FLENHIGH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn HSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DNRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DNRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCONN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DCONN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DDISC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DDISC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HSOF: u16,
        RST: u16,
        WAKEUP: u16,
        DNRSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        DCONN: u16,
        DDISC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HSOF: u16 = unsafe { ::core::mem::transmute(HSOF) };
            HSOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RST: u16 = unsafe { ::core::mem::transmute(RST) };
            RST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DNRSM: u16 = unsafe { ::core::mem::transmute(DNRSM) };
            DNRSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DCONN: u16 = unsafe { ::core::mem::transmute(DCONN) };
            DCONN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DDISC: u16 = unsafe { ::core::mem::transmute(DDISC) };
            DDISC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn HSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DNRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DNRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCONN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DCONN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DDISC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DDISC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HSOF: u16,
        RST: u16,
        WAKEUP: u16,
        DNRSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        DCONN: u16,
        DDISC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HSOF: u16 = unsafe { ::core::mem::transmute(HSOF) };
            HSOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RST: u16 = unsafe { ::core::mem::transmute(RST) };
            RST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DNRSM: u16 = unsafe { ::core::mem::transmute(DNRSM) };
            DNRSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DCONN: u16 = unsafe { ::core::mem::transmute(DCONN) };
            DCONN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DDISC: u16 = unsafe { ::core::mem::transmute(DDISC) };
            DDISC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn HSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DNRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DNRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCONN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DCONN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DDISC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DDISC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HSOF: u16,
        RST: u16,
        WAKEUP: u16,
        DNRSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        DCONN: u16,
        DDISC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HSOF: u16 = unsafe { ::core::mem::transmute(HSOF) };
            HSOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RST: u16 = unsafe { ::core::mem::transmute(RST) };
            RST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DNRSM: u16 = unsafe { ::core::mem::transmute(DNRSM) };
            DNRSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DCONN: u16 = unsafe { ::core::mem::transmute(DCONN) };
            DCONN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DDISC: u16 = unsafe { ::core::mem::transmute(DDISC) };
            DDISC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTSMRY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPINT0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPINT0: u16,
        EPINT1: u16,
        EPINT2: u16,
        EPINT3: u16,
        EPINT4: u16,
        EPINT5: u16,
        EPINT6: u16,
        EPINT7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EPINT0: u16 = unsafe { ::core::mem::transmute(EPINT0) };
            EPINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EPINT1: u16 = unsafe { ::core::mem::transmute(EPINT1) };
            EPINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EPINT2: u16 = unsafe { ::core::mem::transmute(EPINT2) };
            EPINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EPINT3: u16 = unsafe { ::core::mem::transmute(EPINT3) };
            EPINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EPINT4: u16 = unsafe { ::core::mem::transmute(EPINT4) };
            EPINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EPINT5: u16 = unsafe { ::core::mem::transmute(EPINT5) };
            EPINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EPINT6: u16 = unsafe { ::core::mem::transmute(EPINT6) };
            EPINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EPINT7: u16 = unsafe { ::core::mem::transmute(EPINT7) };
            EPINT7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2 {
    #[inline]
    pub fn EPINT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EPINT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let EPINT: u16 = unsafe { ::core::mem::transmute(EPINT) };
            EPINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTSMRY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTSMRY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTSMRY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTSMRY_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTSMRY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PINTSMRY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PINTSMRY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_HOST_PINTSMRY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTSMRY_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTSMRY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTSMRY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTSMRY_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PINTSMRY_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPINT0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPINT0: u16,
        EPINT1: u16,
        EPINT2: u16,
        EPINT3: u16,
        EPINT4: u16,
        EPINT5: u16,
        EPINT6: u16,
        EPINT7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EPINT0: u16 = unsafe { ::core::mem::transmute(EPINT0) };
            EPINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EPINT1: u16 = unsafe { ::core::mem::transmute(EPINT1) };
            EPINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EPINT2: u16 = unsafe { ::core::mem::transmute(EPINT2) };
            EPINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EPINT3: u16 = unsafe { ::core::mem::transmute(EPINT3) };
            EPINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EPINT4: u16 = unsafe { ::core::mem::transmute(EPINT4) };
            EPINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EPINT5: u16 = unsafe { ::core::mem::transmute(EPINT5) };
            EPINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EPINT6: u16 = unsafe { ::core::mem::transmute(EPINT6) };
            EPINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EPINT7: u16 = unsafe { ::core::mem::transmute(EPINT7) };
            EPINT7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTSMRY_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTSMRY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTSMRY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTSMRY_Type__bindgen_ty_2)
        )
    );
}
impl USB_HOST_PINTSMRY_Type__bindgen_ty_2 {
    #[inline]
    pub fn EPINT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EPINT: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let EPINT: u16 = unsafe { ::core::mem::transmute(EPINT) };
            EPINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTSMRY_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTSMRY_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_PINTSMRY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTSMRY_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_PINTSMRY_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTSMRY_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTSMRY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTSMRY_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTSMRY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTSMRY_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTSMRY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DESCADD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DESCADD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DESCADD_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_USB_DESCADD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DESCADD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DESCADD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DESCADD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DESCADD_Type__bindgen_ty_1))
    );
}
impl USB_DESCADD_Type__bindgen_ty_1 {
    #[inline]
    pub fn DESCADD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DESCADD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DESCADD: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DESCADD: u32 = unsafe { ::core::mem::transmute(DESCADD) };
            DESCADD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DESCADD_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DESCADD_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DESCADD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DESCADD_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DESCADD_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DESCADD_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DESCADD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DESCADD_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DESCADD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_PADCAL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_PADCAL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_PADCAL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_PADCAL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_PADCAL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_PADCAL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_PADCAL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_PADCAL_Type__bindgen_ty_1))
    );
}
impl USB_PADCAL_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRANSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_TRANSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TRANSN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_TRANSN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_TRIM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRANSP: u16,
        TRANSN: u16,
        TRIM: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let TRANSP: u16 = unsafe { ::core::mem::transmute(TRANSP) };
            TRANSP as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let TRANSN: u16 = unsafe { ::core::mem::transmute(TRANSN) };
            TRANSN as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let TRIM: u16 = unsafe { ::core::mem::transmute(TRIM) };
            TRIM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_PADCAL_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_PADCAL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_PADCAL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_PADCAL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_PADCAL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_PADCAL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_PADCAL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_PADCAL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_PADCAL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPCFG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPCFG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPTYPE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_EPTYPE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EPTYPE1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_EPTYPE1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NYETDIS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NYETDIS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPTYPE0: u8,
        EPTYPE1: u8,
        NYETDIS: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EPTYPE0: u8 = unsafe { ::core::mem::transmute(EPTYPE0) };
            EPTYPE0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let EPTYPE1: u8 = unsafe { ::core::mem::transmute(EPTYPE1) };
            EPTYPE1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NYETDIS: u8 = unsafe { ::core::mem::transmute(NYETDIS) };
            NYETDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPCFG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPCFG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPCFG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPCFG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PCFG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PCFG_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PTOKEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_PTOKEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTYPE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_PTYPE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PTOKEN: u8,
        BK: u8,
        PTYPE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PTOKEN: u8 = unsafe { ::core::mem::transmute(PTOKEN) };
            PTOKEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BK: u8 = unsafe { ::core::mem::transmute(BK) };
            BK as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let PTYPE: u8 = unsafe { ::core::mem::transmute(PTYPE) };
            PTYPE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PCFG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PCFG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PCFG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PCFG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_BINTERVAL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_BINTERVAL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_BINTERVAL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_BINTERVAL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_BINTERVAL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_BINTERVAL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_BINTERVAL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_BINTERVAL_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_BINTERVAL_Type__bindgen_ty_1 {
    #[inline]
    pub fn BITINTERVAL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_BITINTERVAL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BITINTERVAL: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BITINTERVAL: u8 = unsafe { ::core::mem::transmute(BITINTERVAL) };
            BITINTERVAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_BINTERVAL_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_BINTERVAL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_BINTERVAL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_BINTERVAL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_BINTERVAL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_BINTERVAL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_BINTERVAL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_BINTERVAL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_BINTERVAL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUSCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUSCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUSCLR_Type))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSCLR_Type>())).bit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSCLR_Type>())).vec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSCLR_Type>())).reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PSTATUSCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PSTATUSCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PSTATUSCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUSCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PSTATUSCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PSTATUSCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PSTATUSCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PFREEZE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PFREEZE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGL: u8,
        CURBK: u8,
        PFREEZE: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGL: u8 = unsafe { ::core::mem::transmute(DTGL) };
            DTGL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PFREEZE: u8 = unsafe { ::core::mem::transmute(PFREEZE) };
            PFREEZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUSCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUSCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PSTATUSCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUSCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PSTATUSCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUSCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUSCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUSCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUSCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUSSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUSSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUSSET_Type))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSSET_Type>())).bit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSSET_Type>())).vec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<USB_DEVICE_EPSTATUSSET_Type>())).reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PSTATUSSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PSTATUSSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PSTATUSSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUSSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PSTATUSSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PSTATUSSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PSTATUSSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PFREEZE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PFREEZE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGL: u8,
        CURBK: u8,
        PFREEZE: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGL: u8 = unsafe { ::core::mem::transmute(DTGL) };
            DTGL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PFREEZE: u8 = unsafe { ::core::mem::transmute(PFREEZE) };
            PFREEZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUSSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUSSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PSTATUSSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUSSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PSTATUSSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUSSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUSSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUSSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUSSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPSTATUS_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PFREEZE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PFREEZE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGL: u8,
        CURBK: u8,
        PFREEZE: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGL: u8 = unsafe { ::core::mem::transmute(DTGL) };
            DTGL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PFREEZE: u8 = unsafe { ::core::mem::transmute(PFREEZE) };
            PFREEZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PSTATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PSTATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PSTATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT: u8,
        TRFAIL: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PINTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PINTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_HOST_PINTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PINTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL: u8,
        PERR: u8,
        TXSTP: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PERR: u8 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TXSTP: u8 = unsafe { ::core::mem::transmute(TXSTP) };
            TXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl USB_HOST_PINTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PINTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PINTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTFLAG_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT: u8,
        TRFAIL: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PINTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PINTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_HOST_PINTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PINTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL: u8,
        PERR: u8,
        TXSTP: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PERR: u8 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TXSTP: u8 = unsafe { ::core::mem::transmute(TXSTP) };
            TXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl USB_HOST_PINTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PINTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PINTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENCLR_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT: u8,
        TRFAIL: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EPINTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PINTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PINTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_HOST_PINTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PINTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL: u8,
        PERR: u8,
        TXSTP: u8,
        STALL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PERR: u8 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TXSTP: u8 = unsafe { ::core::mem::transmute(TXSTP) };
            TXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PINTENSET_Type__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_PINTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PINTENSET_Type__bindgen_ty_2)
        )
    );
}
impl USB_HOST_PINTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PINTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PINTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_PINTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PINTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_PINTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENSET_Type>())).vec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PINTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PINTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_USB_HOST_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_HOST_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_ADDR_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_HOST_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_HOST_ADDR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_ADDR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_ADDR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_PCKSIZE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_PCKSIZE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_PCKSIZE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_PCKSIZE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_PCKSIZE_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_PCKSIZE_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_PCKSIZE_Type__bindgen_ty_1 {
    #[inline]
    pub fn BYTE_COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_BYTE_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn MULTI_PACKET_SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_MULTI_PACKET_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AUTO_ZLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTO_ZLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BYTE_COUNT: u32,
        MULTI_PACKET_SIZE: u32,
        SIZE: u32,
        AUTO_ZLP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let BYTE_COUNT: u32 = unsafe { ::core::mem::transmute(BYTE_COUNT) };
            BYTE_COUNT as u64
        });
        __bindgen_bitfield_unit.set(14usize, 14u8, {
            let MULTI_PACKET_SIZE: u32 = unsafe { ::core::mem::transmute(MULTI_PACKET_SIZE) };
            MULTI_PACKET_SIZE as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let SIZE: u32 = unsafe { ::core::mem::transmute(SIZE) };
            SIZE as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let AUTO_ZLP: u32 = unsafe { ::core::mem::transmute(AUTO_ZLP) };
            AUTO_ZLP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_PCKSIZE_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_PCKSIZE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_PCKSIZE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_PCKSIZE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_PCKSIZE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_PCKSIZE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_PCKSIZE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_PCKSIZE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_PCKSIZE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_PCKSIZE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_PCKSIZE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_PCKSIZE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_HOST_PCKSIZE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_HOST_PCKSIZE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_PCKSIZE_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_PCKSIZE_Type__bindgen_ty_1 {
    #[inline]
    pub fn BYTE_COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_BYTE_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn MULTI_PACKET_SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_MULTI_PACKET_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AUTO_ZLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTO_ZLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BYTE_COUNT: u32,
        MULTI_PACKET_SIZE: u32,
        SIZE: u32,
        AUTO_ZLP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let BYTE_COUNT: u32 = unsafe { ::core::mem::transmute(BYTE_COUNT) };
            BYTE_COUNT as u64
        });
        __bindgen_bitfield_unit.set(14usize, 14u8, {
            let MULTI_PACKET_SIZE: u32 = unsafe { ::core::mem::transmute(MULTI_PACKET_SIZE) };
            MULTI_PACKET_SIZE as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let SIZE: u32 = unsafe { ::core::mem::transmute(SIZE) };
            SIZE as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let AUTO_ZLP: u32 = unsafe { ::core::mem::transmute(AUTO_ZLP) };
            AUTO_ZLP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_PCKSIZE_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_PCKSIZE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_HOST_PCKSIZE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_PCKSIZE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_HOST_PCKSIZE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PCKSIZE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PCKSIZE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_PCKSIZE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_PCKSIZE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EXTREG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EXTREG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EXTREG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EXTREG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EXTREG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EXTREG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EXTREG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUBPID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SUBPID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VARIABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_VARIABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SUBPID: u16, VARIABLE: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SUBPID: u16 = unsafe { ::core::mem::transmute(SUBPID) };
            SUBPID as u64
        });
        __bindgen_bitfield_unit.set(4usize, 11u8, {
            let VARIABLE: u16 = unsafe { ::core::mem::transmute(VARIABLE) };
            VARIABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EXTREG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EXTREG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EXTREG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EXTREG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EXTREG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EXTREG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EXTREG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_EXTREG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EXTREG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_EXTREG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_EXTREG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_EXTREG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_USB_HOST_EXTREG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_EXTREG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_EXTREG_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_EXTREG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUBPID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SUBPID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VARIABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_VARIABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SUBPID: u16, VARIABLE: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SUBPID: u16 = unsafe { ::core::mem::transmute(SUBPID) };
            SUBPID as u64
        });
        __bindgen_bitfield_unit.set(4usize, 11u8, {
            let VARIABLE: u16 = unsafe { ::core::mem::transmute(VARIABLE) };
            VARIABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_EXTREG_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_EXTREG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_EXTREG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_EXTREG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_EXTREG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_EXTREG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_EXTREG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_EXTREG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_EXTREG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_STATUS_BK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_STATUS_BK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_STATUS_BK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_BK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_STATUS_BK_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_STATUS_BK_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_STATUS_BK_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERRORFLOW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERRORFLOW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCERR: u8, ERRORFLOW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRCERR: u8 = unsafe { ::core::mem::transmute(CRCERR) };
            CRCERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERRORFLOW: u8 = unsafe { ::core::mem::transmute(ERRORFLOW) };
            ERRORFLOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_BK_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_BK_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_STATUS_BK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_BK_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_STATUS_BK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_STATUS_BK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_BK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_DEVICE_STATUS_BK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_BK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_STATUS_BK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_STATUS_BK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_STATUS_BK_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_BK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_STATUS_BK_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_STATUS_BK_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_STATUS_BK_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERRORFLOW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERRORFLOW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCERR: u8, ERRORFLOW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRCERR: u8 = unsafe { ::core::mem::transmute(CRCERR) };
            CRCERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERRORFLOW: u8 = unsafe { ::core::mem::transmute(ERRORFLOW) };
            ERRORFLOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_BK_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_BK_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_HOST_STATUS_BK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_BK_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_HOST_STATUS_BK_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_BK_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_BK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_BK_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_BK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_CTRL_PIPE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_CTRL_PIPE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_CTRL_PIPE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_CTRL_PIPE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_CTRL_PIPE_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_CTRL_PIPE_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_CTRL_PIPE_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_CTRL_PIPE_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_CTRL_PIPE_Type__bindgen_ty_1 {
    #[inline]
    pub fn PDADDR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_PDADDR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn PEPNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PEPNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PERMAX(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PERMAX(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PDADDR: u16,
        PEPNUM: u16,
        PERMAX: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let PDADDR: u16 = unsafe { ::core::mem::transmute(PDADDR) };
            PDADDR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PEPNUM: u16 = unsafe { ::core::mem::transmute(PEPNUM) };
            PEPNUM as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PERMAX: u16 = unsafe { ::core::mem::transmute(PERMAX) };
            PERMAX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_CTRL_PIPE_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_CTRL_PIPE_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_CTRL_PIPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_CTRL_PIPE_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_CTRL_PIPE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_CTRL_PIPE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_CTRL_PIPE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_CTRL_PIPE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_CTRL_PIPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_HOST_STATUS_PIPE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_HOST_STATUS_PIPE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_HOST_STATUS_PIPE_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_PIPE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_PIPE_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_HOST_STATUS_PIPE_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_PIPE_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_HOST_STATUS_PIPE_Type__bindgen_ty_1)
        )
    );
}
impl USB_HOST_STATUS_PIPE_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DTGLER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DAPIDER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DAPIDER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PIDER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PIDER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TOUTER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TOUTER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRC16ER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CRC16ER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERCNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ERCNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLER: u16,
        DAPIDER: u16,
        PIDER: u16,
        TOUTER: u16,
        CRC16ER: u16,
        ERCNT: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLER: u16 = unsafe { ::core::mem::transmute(DTGLER) };
            DTGLER as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DAPIDER: u16 = unsafe { ::core::mem::transmute(DAPIDER) };
            DAPIDER as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PIDER: u16 = unsafe { ::core::mem::transmute(PIDER) };
            PIDER as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TOUTER: u16 = unsafe { ::core::mem::transmute(TOUTER) };
            TOUTER as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CRC16ER: u16 = unsafe { ::core::mem::transmute(CRC16ER) };
            CRC16ER as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ERCNT: u16 = unsafe { ::core::mem::transmute(ERCNT) };
            ERCNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_HOST_STATUS_PIPE_Type() {
    assert_eq!(
        ::core::mem::size_of::<USB_HOST_STATUS_PIPE_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_HOST_STATUS_PIPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_HOST_STATUS_PIPE_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_HOST_STATUS_PIPE_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_PIPE_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_PIPE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<USB_HOST_STATUS_PIPE_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_HOST_STATUS_PIPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceDescBank {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer"]
    pub ADDR: USB_DEVICE_ADDR_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Packet Size"]
    pub PCKSIZE: USB_DEVICE_PCKSIZE_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W 16) DEVICE_DESC_BANK Endpoint Bank, Extended"]
    pub EXTREG: USB_DEVICE_EXTREG_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) DEVICE_DESC_BANK Enpoint Bank, Status of Bank"]
    pub STATUS_BK: USB_DEVICE_STATUS_BK_Type,
    pub Reserved1: [RoReg8; 5usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceDescBank() {
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceDescBank>(),
        16usize,
        concat!("Size of: ", stringify!(UsbDeviceDescBank))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceDescBank>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDeviceDescBank))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceDescBank>())).ADDR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceDescBank>())).PCKSIZE as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(PCKSIZE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceDescBank>())).EXTREG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(EXTREG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceDescBank>())).STATUS_BK as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(STATUS_BK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceDescBank>())).Reserved1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbHostDescBank {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) HOST_DESC_BANK Host Bank, Adress of Data Buffer"]
    pub ADDR: USB_HOST_ADDR_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) HOST_DESC_BANK Host Bank, Packet Size"]
    pub PCKSIZE: USB_HOST_PCKSIZE_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W 16) HOST_DESC_BANK Host Bank, Extended"]
    pub EXTREG: USB_HOST_EXTREG_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) HOST_DESC_BANK Host Bank, Status of Bank"]
    pub STATUS_BK: USB_HOST_STATUS_BK_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x00C (R/W 16) HOST_DESC_BANK Host Bank, Host Control Pipe"]
    pub CTRL_PIPE: USB_HOST_CTRL_PIPE_Type,
    #[doc = "< \\brief Offset: 0x00E (R/W 16) HOST_DESC_BANK Host Bank, Host Status Pipe"]
    pub STATUS_PIPE: USB_HOST_STATUS_PIPE_Type,
}
#[test]
fn bindgen_test_layout_UsbHostDescBank() {
    assert_eq!(
        ::core::mem::size_of::<UsbHostDescBank>(),
        16usize,
        concat!("Size of: ", stringify!(UsbHostDescBank))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHostDescBank>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHostDescBank))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).ADDR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).PCKSIZE as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(PCKSIZE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).EXTREG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(EXTREG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).STATUS_BK as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(STATUS_BK)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).Reserved1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).CTRL_PIPE as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(CTRL_PIPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescBank>())).STATUS_PIPE as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescBank),
            "::",
            stringify!(STATUS_PIPE)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceEndpoint {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) DEVICE_ENDPOINT End Point Configuration"]
    pub EPCFG: USB_DEVICE_EPCFG_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x004 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Clear"]
    pub EPSTATUSCLR: USB_DEVICE_EPSTATUSCLR_Type,
    #[doc = "< \\brief Offset: 0x005 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Set"]
    pub EPSTATUSSET: USB_DEVICE_EPSTATUSSET_Type,
    #[doc = "< \\brief Offset: 0x006 (R/   8) DEVICE_ENDPOINT End Point Pipe Status"]
    pub EPSTATUS: USB_DEVICE_EPSTATUS_Type,
    #[doc = "< \\brief Offset: 0x007 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Flag"]
    pub EPINTFLAG: USB_DEVICE_EPINTFLAG_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Clear Flag"]
    pub EPINTENCLR: USB_DEVICE_EPINTENCLR_Type,
    #[doc = "< \\brief Offset: 0x009 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Set Flag"]
    pub EPINTENSET: USB_DEVICE_EPINTENSET_Type,
    pub Reserved2: [RoReg8; 22usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceEndpoint() {
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceEndpoint>(),
        32usize,
        concat!("Size of: ", stringify!(UsbDeviceEndpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceEndpoint>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbDeviceEndpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPCFG as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPSTATUSCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUSCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPSTATUSSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUSSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPSTATUS as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPINTFLAG as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPINTENCLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).EPINTENSET as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDeviceEndpoint>())).Reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbHostPipe {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) HOST_PIPE End Point Configuration"]
    pub PCFG: USB_HOST_PCFG_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x003 (R/W  8) HOST_PIPE Bus Access Period of Pipe"]
    pub BINTERVAL: USB_HOST_BINTERVAL_Type,
    #[doc = "< \\brief Offset: 0x004 ( /W  8) HOST_PIPE End Point Pipe Status Clear"]
    pub PSTATUSCLR: USB_HOST_PSTATUSCLR_Type,
    #[doc = "< \\brief Offset: 0x005 ( /W  8) HOST_PIPE End Point Pipe Status Set"]
    pub PSTATUSSET: USB_HOST_PSTATUSSET_Type,
    #[doc = "< \\brief Offset: 0x006 (R/   8) HOST_PIPE End Point Pipe Status"]
    pub PSTATUS: USB_HOST_PSTATUS_Type,
    #[doc = "< \\brief Offset: 0x007 (R/W  8) HOST_PIPE Pipe Interrupt Flag"]
    pub PINTFLAG: USB_HOST_PINTFLAG_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W  8) HOST_PIPE Pipe Interrupt Flag Clear"]
    pub PINTENCLR: USB_HOST_PINTENCLR_Type,
    #[doc = "< \\brief Offset: 0x009 (R/W  8) HOST_PIPE Pipe Interrupt Flag Set"]
    pub PINTENSET: USB_HOST_PINTENSET_Type,
    pub Reserved2: [RoReg8; 22usize],
}
#[test]
fn bindgen_test_layout_UsbHostPipe() {
    assert_eq!(
        ::core::mem::size_of::<UsbHostPipe>(),
        32usize,
        concat!("Size of: ", stringify!(UsbHostPipe))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHostPipe>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbHostPipe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PCFG as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).BINTERVAL as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(BINTERVAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PSTATUSCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PSTATUSCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PSTATUSSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PSTATUSSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PSTATUS as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PINTFLAG as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PINTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PINTENCLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PINTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).PINTENSET as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(PINTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostPipe>())).Reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostPipe),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDevice {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) Control A"]
    pub CTRLA: USB_CTRLA_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x002 (R/   8) Synchronization Busy"]
    pub SYNCBUSY: USB_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x003 (R/W  8) USB Quality Of Service"]
    pub QOSCTRL: USB_QOSCTRL_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x008 (R/W 16) DEVICE Control B"]
    pub CTRLB: USB_DEVICE_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) DEVICE Device Address"]
    pub DADD: USB_DEVICE_DADD_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x00C (R/   8) DEVICE Status"]
    pub STATUS: USB_DEVICE_STATUS_Type,
    #[doc = "< \\brief Offset: 0x00D (R/   8) Finite State Machine Status"]
    pub FSMSTATUS: USB_FSMSTATUS_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x010 (R/  16) DEVICE Device Frame Number"]
    pub FNUM: USB_DEVICE_FNUM_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x014 (R/W 16) DEVICE Device Interrupt Enable Clear"]
    pub INTENCLR: USB_DEVICE_INTENCLR_Type,
    pub Reserved6: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x018 (R/W 16) DEVICE Device Interrupt Enable Set"]
    pub INTENSET: USB_DEVICE_INTENSET_Type,
    pub Reserved7: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x01C (R/W 16) DEVICE Device Interrupt Flag"]
    pub INTFLAG: USB_DEVICE_INTFLAG_Type,
    pub Reserved8: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x020 (R/  16) DEVICE End Point Interrupt Summary"]
    pub EPINTSMRY: USB_DEVICE_EPINTSMRY_Type,
    pub Reserved9: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x024 (R/W 32) Descriptor Address"]
    pub DESCADD: USB_DESCADD_Type,
    #[doc = "< \\brief Offset: 0x028 (R/W 16) USB PAD Calibration"]
    pub PADCAL: USB_PADCAL_Type,
    pub Reserved10: [RoReg8; 214usize],
    #[doc = "< \\brief Offset: 0x100 UsbDeviceEndpoint groups [EPT_NUM]"]
    pub DeviceEndpoint: [UsbDeviceEndpoint; 8usize],
}
#[test]
fn bindgen_test_layout_UsbDevice() {
    assert_eq!(
        ::core::mem::size_of::<UsbDevice>(),
        512usize,
        concat!("Size of: ", stringify!(UsbDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDevice))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).SYNCBUSY as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).QOSCTRL as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(QOSCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).CTRLB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).DADD as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DADD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved3 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).STATUS as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).FSMSTATUS as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(FSMSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved4 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).FNUM as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(FNUM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved5 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved6 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).INTENSET as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved7 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).INTFLAG as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved8 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).EPINTSMRY as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(EPINTSMRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved9 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).DESCADD as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DESCADD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).PADCAL as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(PADCAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).Reserved10 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDevice>())).DeviceEndpoint as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DeviceEndpoint)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbHost {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) Control A"]
    pub CTRLA: USB_CTRLA_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x002 (R/   8) Synchronization Busy"]
    pub SYNCBUSY: USB_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x003 (R/W  8) USB Quality Of Service"]
    pub QOSCTRL: USB_QOSCTRL_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x008 (R/W 16) HOST Control B"]
    pub CTRLB: USB_HOST_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) HOST Host Start Of Frame Control"]
    pub HSOFC: USB_HOST_HSOFC_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x00C (R/W  8) HOST Status"]
    pub STATUS: USB_HOST_STATUS_Type,
    #[doc = "< \\brief Offset: 0x00D (R/   8) Finite State Machine Status"]
    pub FSMSTATUS: USB_FSMSTATUS_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x010 (R/W 16) HOST Host Frame Number"]
    pub FNUM: USB_HOST_FNUM_Type,
    #[doc = "< \\brief Offset: 0x012 (R/   8) HOST Host Frame Length"]
    pub FLENHIGH: USB_HOST_FLENHIGH_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x014 (R/W 16) HOST Host Interrupt Enable Clear"]
    pub INTENCLR: USB_HOST_INTENCLR_Type,
    pub Reserved6: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x018 (R/W 16) HOST Host Interrupt Enable Set"]
    pub INTENSET: USB_HOST_INTENSET_Type,
    pub Reserved7: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x01C (R/W 16) HOST Host Interrupt Flag"]
    pub INTFLAG: USB_HOST_INTFLAG_Type,
    pub Reserved8: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x020 (R/  16) HOST Pipe Interrupt Summary"]
    pub PINTSMRY: USB_HOST_PINTSMRY_Type,
    pub Reserved9: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x024 (R/W 32) Descriptor Address"]
    pub DESCADD: USB_DESCADD_Type,
    #[doc = "< \\brief Offset: 0x028 (R/W 16) USB PAD Calibration"]
    pub PADCAL: USB_PADCAL_Type,
    pub Reserved10: [RoReg8; 214usize],
    #[doc = "< \\brief Offset: 0x100 UsbHostPipe groups [EPT_NUM*HOST_IMPLEMENTED]"]
    pub HostPipe: [UsbHostPipe; 8usize],
}
#[test]
fn bindgen_test_layout_UsbHost() {
    assert_eq!(
        ::core::mem::size_of::<UsbHost>(),
        512usize,
        concat!("Size of: ", stringify!(UsbHost))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHost>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHost))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).CTRLA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).SYNCBUSY as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).QOSCTRL as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(QOSCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).CTRLB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).HSOFC as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(HSOFC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved3 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).STATUS as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).FSMSTATUS as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(FSMSTATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved4 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).FNUM as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(FNUM)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).FLENHIGH as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(FLENHIGH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved5 as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).INTENCLR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved6 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).INTENSET as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved7 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).INTFLAG as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved8 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).PINTSMRY as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(PINTSMRY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved9 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).DESCADD as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(DESCADD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).PADCAL as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(PADCAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).Reserved10 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(Reserved10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHost>())).HostPipe as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHost),
            "::",
            stringify!(HostPipe)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceDescriptor {
    #[doc = "< \\brief Offset: 0x000 UsbDeviceDescBank groups"]
    pub DeviceDescBank: [UsbDeviceDescBank; 2usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(UsbDeviceDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDeviceDescriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDeviceDescriptor>())).DeviceDescBank as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescriptor),
            "::",
            stringify!(DeviceDescBank)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbHostDescriptor {
    #[doc = "< \\brief Offset: 0x000 UsbHostDescBank groups [2*HOST_IMPLEMENTED]"]
    pub HostDescBank: [UsbHostDescBank; 2usize],
}
#[test]
fn bindgen_test_layout_UsbHostDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<UsbHostDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(UsbHostDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHostDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHostDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHostDescriptor>())).HostDescBank as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHostDescriptor),
            "::",
            stringify!(HostDescBank)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Usb {
    #[doc = "< \\brief Offset: 0x000 USB is Device"]
    pub DEVICE: UsbDevice,
    #[doc = "< \\brief Offset: 0x000 USB is Host"]
    pub HOST: UsbHost,
    _bindgen_union_align: [u32; 128usize],
}
#[test]
fn bindgen_test_layout_Usb() {
    assert_eq!(
        ::core::mem::size_of::<Usb>(),
        512usize,
        concat!("Size of: ", stringify!(Usb))
    );
    assert_eq!(
        ::core::mem::align_of::<Usb>(),
        4usize,
        concat!("Alignment of ", stringify!(Usb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Usb>())).DEVICE as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Usb),
            "::",
            stringify!(DEVICE)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Usb>())).HOST as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Usb), "::", stringify!(HOST))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CTRL_Type__bindgen_ty_1))
    );
}
impl WDT_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALWAYSON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALWAYSON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        WEN: u8,
        ALWAYSON: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WEN: u8 = unsafe { ::core::mem::transmute(WEN) };
            WEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ALWAYSON: u8 = unsafe { ::core::mem::transmute(ALWAYSON) };
            ALWAYSON as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CONFIG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_CONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CONFIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CONFIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CONFIG_Type__bindgen_ty_1))
    );
}
impl WDT_CONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WINDOW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_WINDOW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u8, WINDOW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PER: u8 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let WINDOW: u8 = unsafe { ::core::mem::transmute(WINDOW) };
            WINDOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CONFIG_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CONFIG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CONFIG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CONFIG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CONFIG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CONFIG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_EWCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_EWCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_EWCTRL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_EWCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_EWCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_EWCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_EWCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_EWCTRL_Type__bindgen_ty_1))
    );
}
impl WDT_EWCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EWOFFSET(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_EWOFFSET(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EWOFFSET: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let EWOFFSET: u8 = unsafe { ::core::mem::transmute(EWOFFSET) };
            EWOFFSET as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_EWCTRL_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_EWCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_EWCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_EWCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_EWCTRL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_EWCTRL_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_EWCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_EWCTRL_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_EWCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENCLR_Type__bindgen_ty_1))
    );
}
impl WDT_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTENCLR_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTENCLR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTENCLR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENSET_Type__bindgen_ty_1))
    );
}
impl WDT_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTENSET_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENSET_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTENSET_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTENSET_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTFLAG_Type__bindgen_ty_1))
    );
}
impl WDT_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTFLAG_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTFLAG_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_INTFLAG_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_STATUS_Type__bindgen_ty_1))
    );
}
impl WDT_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SYNCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYNCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SYNCBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SYNCBUSY: u8 = unsafe { ::core::mem::transmute(SYNCBUSY) };
            SYNCBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_STATUS_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_STATUS_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_STATUS_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_STATUS_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CLEAR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CLEAR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CLEAR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_WDT_CLEAR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CLEAR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CLEAR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CLEAR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CLEAR_Type__bindgen_ty_1))
    );
}
impl WDT_CLEAR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CLEAR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CLEAR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CLEAR: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CLEAR: u8 = unsafe { ::core::mem::transmute(CLEAR) };
            CLEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CLEAR_Type() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CLEAR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CLEAR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CLEAR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CLEAR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CLEAR_Type>())).bit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CLEAR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WDT_CLEAR_Type>())).reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CLEAR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Wdt {
    #[doc = "< \\brief Offset: 0x0 (R/W  8) Control"]
    pub CTRL: WDT_CTRL_Type,
    #[doc = "< \\brief Offset: 0x1 (R/W  8) Configuration"]
    pub CONFIG: WDT_CONFIG_Type,
    #[doc = "< \\brief Offset: 0x2 (R/W  8) Early Warning Interrupt Control"]
    pub EWCTRL: WDT_EWCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x4 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: WDT_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x5 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: WDT_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x6 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: WDT_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x7 (R/   8) Status"]
    pub STATUS: WDT_STATUS_Type,
    #[doc = "< \\brief Offset: 0x8 ( /W  8) Clear"]
    pub CLEAR: WDT_CLEAR_Type,
}
#[test]
fn bindgen_test_layout_Wdt() {
    assert_eq!(
        ::core::mem::size_of::<Wdt>(),
        9usize,
        concat!("Size of: ", stringify!(Wdt))
    );
    assert_eq!(
        ::core::mem::align_of::<Wdt>(),
        1usize,
        concat!("Alignment of ", stringify!(Wdt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).CTRL as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Wdt), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).CONFIG as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(CONFIG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).EWCTRL as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(EWCTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).Reserved1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).INTENCLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).INTENSET as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).INTFLAG as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).STATUS as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Wdt>())).CLEAR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(CLEAR)
        )
    );
}
#[doc = " \\brief Type for the register holding global interrupt enable flag"]
pub type hal_atomic_t = u32;
extern "C" {
    #[doc = " \\brief Disable interrupts, enter critical section"]
    #[doc = ""]
    #[doc = " Disables global interrupts. Supports nested critical sections,"]
    #[doc = " so that global interrupts are only re-enabled"]
    #[doc = " upon leaving the outermost nested critical section."]
    #[doc = ""]
    #[doc = " \\param[out] atomic The pointer to a variable to store the value of global"]
    #[doc = " interrupt enable flag"]
    pub fn atomic_enter_critical(atomic: *mut hal_atomic_t);
}
extern "C" {
    #[doc = " \\brief Exit atomic section"]
    #[doc = ""]
    #[doc = " Enables global interrupts. Supports nested critical sections,"]
    #[doc = " so that global interrupts are only re-enabled"]
    #[doc = " upon leaving the outermost nested critical section."]
    #[doc = ""]
    #[doc = " \\param[in] atomic The pointer to a variable, which stores the latest stored"]
    #[doc = " value of the global interrupt enable flag"]
    pub fn atomic_leave_critical(atomic: *mut hal_atomic_t);
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version"]
    #[doc = ""]
    #[doc = " \\return Current driver version."]
    pub fn atomic_get_version() -> u32;
}
pub type hri_ac_evctrl_reg_t = u16;
pub type hri_ac_compctrl_reg_t = u32;
pub type hri_ac_ctrla_reg_t = u8;
pub type hri_ac_ctrlb_reg_t = u8;
pub type hri_ac_intenset_reg_t = u8;
pub type hri_ac_intflag_reg_t = u8;
pub type hri_ac_scaler_reg_t = u8;
pub type hri_ac_statusa_reg_t = u8;
pub type hri_ac_statusb_reg_t = u8;
pub type hri_ac_statusc_reg_t = u8;
pub type hri_ac_winctrl_reg_t = u8;
pub type hri_adc_calib_reg_t = u16;
pub type hri_adc_ctrlb_reg_t = u16;
pub type hri_adc_gaincorr_reg_t = u16;
pub type hri_adc_offsetcorr_reg_t = u16;
pub type hri_adc_result_reg_t = u16;
pub type hri_adc_winlt_reg_t = u16;
pub type hri_adc_winut_reg_t = u16;
pub type hri_adc_inputctrl_reg_t = u32;
pub type hri_adc_avgctrl_reg_t = u8;
pub type hri_adc_ctrla_reg_t = u8;
pub type hri_adc_dbgctrl_reg_t = u8;
pub type hri_adc_evctrl_reg_t = u8;
pub type hri_adc_intenset_reg_t = u8;
pub type hri_adc_intflag_reg_t = u8;
pub type hri_adc_refctrl_reg_t = u8;
pub type hri_adc_sampctrl_reg_t = u8;
pub type hri_adc_status_reg_t = u8;
pub type hri_adc_swtrig_reg_t = u8;
pub type hri_adc_winctrl_reg_t = u8;
pub type hri_dac_data_reg_t = u16;
pub type hri_dac_databuf_reg_t = u16;
pub type hri_dac_ctrla_reg_t = u8;
pub type hri_dac_ctrlb_reg_t = u8;
pub type hri_dac_evctrl_reg_t = u8;
pub type hri_dac_intenset_reg_t = u8;
pub type hri_dac_intflag_reg_t = u8;
pub type hri_dac_status_reg_t = u8;
pub type hri_dmac_crcctrl_reg_t = u16;
pub type hri_dmac_ctrl_reg_t = u16;
pub type hri_dmac_intpend_reg_t = u16;
pub type hri_dmacdescriptor_btcnt_reg_t = u16;
pub type hri_dmacdescriptor_btctrl_reg_t = u16;
pub type hri_dmac_active_reg_t = u32;
pub type hri_dmac_baseaddr_reg_t = u32;
pub type hri_dmac_busych_reg_t = u32;
pub type hri_dmac_chctrlb_reg_t = u32;
pub type hri_dmac_crcchksum_reg_t = u32;
pub type hri_dmac_crcdatain_reg_t = u32;
pub type hri_dmac_intstatus_reg_t = u32;
pub type hri_dmac_pendch_reg_t = u32;
pub type hri_dmac_prictrl0_reg_t = u32;
pub type hri_dmac_swtrigctrl_reg_t = u32;
pub type hri_dmac_wrbaddr_reg_t = u32;
pub type hri_dmacdescriptor_descaddr_reg_t = u32;
pub type hri_dmacdescriptor_dstaddr_reg_t = u32;
pub type hri_dmacdescriptor_srcaddr_reg_t = u32;
pub type hri_dmac_chctrla_reg_t = u8;
pub type hri_dmac_chid_reg_t = u8;
pub type hri_dmac_chintenset_reg_t = u8;
pub type hri_dmac_chintflag_reg_t = u8;
pub type hri_dmac_chstatus_reg_t = u8;
pub type hri_dmac_crcstatus_reg_t = u8;
pub type hri_dmac_dbgctrl_reg_t = u8;
pub type hri_dmac_qosctrl_reg_t = u8;
pub type hri_dsu_addr_reg_t = u32;
pub type hri_dsu_cid0_reg_t = u32;
pub type hri_dsu_cid1_reg_t = u32;
pub type hri_dsu_cid2_reg_t = u32;
pub type hri_dsu_cid3_reg_t = u32;
pub type hri_dsu_data_reg_t = u32;
pub type hri_dsu_dcc_reg_t = u32;
pub type hri_dsu_did_reg_t = u32;
pub type hri_dsu_end_reg_t = u32;
pub type hri_dsu_entry1_reg_t = u32;
pub type hri_dsu_entry_reg_t = u32;
pub type hri_dsu_length_reg_t = u32;
pub type hri_dsu_memtype_reg_t = u32;
pub type hri_dsu_pid0_reg_t = u32;
pub type hri_dsu_pid1_reg_t = u32;
pub type hri_dsu_pid2_reg_t = u32;
pub type hri_dsu_pid3_reg_t = u32;
pub type hri_dsu_pid4_reg_t = u32;
pub type hri_dsu_ctrl_reg_t = u8;
pub type hri_dsu_statusa_reg_t = u8;
pub type hri_dsu_statusb_reg_t = u8;
pub type hri_eic_config_reg_t = u32;
pub type hri_eic_evctrl_reg_t = u32;
pub type hri_eic_intenset_reg_t = u32;
pub type hri_eic_intflag_reg_t = u32;
pub type hri_eic_wakeup_reg_t = u32;
pub type hri_eic_ctrl_reg_t = u8;
pub type hri_eic_nmictrl_reg_t = u8;
pub type hri_eic_nmiflag_reg_t = u8;
pub type hri_eic_status_reg_t = u8;
pub type hri_evsys_user_reg_t = u16;
pub type hri_evsys_channel_reg_t = u32;
pub type hri_evsys_chstatus_reg_t = u32;
pub type hri_evsys_intenset_reg_t = u32;
pub type hri_evsys_intflag_reg_t = u32;
pub type hri_evsys_ctrl_reg_t = u8;
pub type hri_gclk_clkctrl_reg_t = u16;
pub type hri_gclk_genctrl_reg_t = u32;
pub type hri_gclk_gendiv_reg_t = u32;
pub type hri_gclk_ctrl_reg_t = u8;
pub type hri_gclk_status_reg_t = u8;
pub type hri_hmatrixb_pras_reg_t = u32;
pub type hri_hmatrixb_prbs_reg_t = u32;
pub type hri_hmatrixb_sfr_reg_t = u32;
pub type hri_hmatrixbprs_pras_reg_t = u32;
pub type hri_hmatrixbprs_prbs_reg_t = u32;
pub type hri_i2s_intenset_reg_t = u16;
pub type hri_i2s_intflag_reg_t = u16;
pub type hri_i2s_syncbusy_reg_t = u16;
pub type hri_i2s_clkctrl_reg_t = u32;
pub type hri_i2s_data_reg_t = u32;
pub type hri_i2s_serctrl_reg_t = u32;
pub type hri_i2s_ctrla_reg_t = u8;
pub type hri_mtb_authstatus_reg_t = u32;
pub type hri_mtb_base_reg_t = u32;
pub type hri_mtb_cid0_reg_t = u32;
pub type hri_mtb_cid1_reg_t = u32;
pub type hri_mtb_cid2_reg_t = u32;
pub type hri_mtb_cid3_reg_t = u32;
pub type hri_mtb_claimset_reg_t = u32;
pub type hri_mtb_devarch_reg_t = u32;
pub type hri_mtb_devid_reg_t = u32;
pub type hri_mtb_devtype_reg_t = u32;
pub type hri_mtb_flow_reg_t = u32;
pub type hri_mtb_itctrl_reg_t = u32;
pub type hri_mtb_lockaccess_reg_t = u32;
pub type hri_mtb_lockstatus_reg_t = u32;
pub type hri_mtb_master_reg_t = u32;
pub type hri_mtb_pid0_reg_t = u32;
pub type hri_mtb_pid1_reg_t = u32;
pub type hri_mtb_pid2_reg_t = u32;
pub type hri_mtb_pid3_reg_t = u32;
pub type hri_mtb_pid4_reg_t = u32;
pub type hri_mtb_pid5_reg_t = u32;
pub type hri_mtb_pid6_reg_t = u32;
pub type hri_mtb_pid7_reg_t = u32;
pub type hri_mtb_position_reg_t = u32;
pub type hri_nvmctrl_ctrla_reg_t = u16;
pub type hri_nvmctrl_lock_reg_t = u16;
pub type hri_nvmctrl_status_reg_t = u16;
pub type hri_nvmctrl_addr_reg_t = u32;
pub type hri_nvmctrl_ctrlb_reg_t = u32;
pub type hri_nvmctrl_param_reg_t = u32;
pub type hri_nvmctrl_intenset_reg_t = u8;
pub type hri_nvmctrl_intflag_reg_t = u8;
pub type hri_pac_wpset_reg_t = u32;
pub type hri_pm_ahbmask_reg_t = u32;
pub type hri_pm_apbamask_reg_t = u32;
pub type hri_pm_apbbmask_reg_t = u32;
pub type hri_pm_apbcmask_reg_t = u32;
pub type hri_pm_apbasel_reg_t = u8;
pub type hri_pm_apbbsel_reg_t = u8;
pub type hri_pm_apbcsel_reg_t = u8;
pub type hri_pm_cpusel_reg_t = u8;
pub type hri_pm_ctrl_reg_t = u8;
pub type hri_pm_intenset_reg_t = u8;
pub type hri_pm_intflag_reg_t = u8;
pub type hri_pm_rcause_reg_t = u8;
pub type hri_pm_sleep_reg_t = u8;
pub type hri_port_ctrl_reg_t = u32;
pub type hri_port_dir_reg_t = u32;
pub type hri_port_in_reg_t = u32;
pub type hri_port_out_reg_t = u32;
pub type hri_port_wrconfig_reg_t = u32;
pub type hri_portgroup_ctrl_reg_t = u32;
pub type hri_portgroup_dir_reg_t = u32;
pub type hri_portgroup_in_reg_t = u32;
pub type hri_portgroup_out_reg_t = u32;
pub type hri_portgroup_wrconfig_reg_t = u32;
pub type hri_port_pincfg_reg_t = u8;
pub type hri_port_pmux_reg_t = u8;
pub type hri_portgroup_pincfg_reg_t = u8;
pub type hri_portgroup_pmux_reg_t = u8;
pub type hri_rtc_readreq_reg_t = u16;
pub type hri_rtcmode0_ctrl_reg_t = u16;
pub type hri_rtcmode0_evctrl_reg_t = u16;
pub type hri_rtcmode1_comp_reg_t = u16;
pub type hri_rtcmode1_count_reg_t = u16;
pub type hri_rtcmode1_ctrl_reg_t = u16;
pub type hri_rtcmode1_evctrl_reg_t = u16;
pub type hri_rtcmode1_per_reg_t = u16;
pub type hri_rtcmode2_ctrl_reg_t = u16;
pub type hri_rtcmode2_evctrl_reg_t = u16;
pub type hri_rtcalarm_alarm_reg_t = u32;
pub type hri_rtcmode0_comp_reg_t = u32;
pub type hri_rtcmode0_count_reg_t = u32;
pub type hri_rtcmode2_alarm_reg_t = u32;
pub type hri_rtcmode2_clock_reg_t = u32;
pub type hri_rtc_dbgctrl_reg_t = u8;
pub type hri_rtc_freqcorr_reg_t = u8;
pub type hri_rtc_status_reg_t = u8;
pub type hri_rtcalarm_mask_reg_t = u8;
pub type hri_rtcmode0_intenset_reg_t = u8;
pub type hri_rtcmode0_intflag_reg_t = u8;
pub type hri_rtcmode1_intenset_reg_t = u8;
pub type hri_rtcmode1_intflag_reg_t = u8;
pub type hri_rtcmode2_intenset_reg_t = u8;
pub type hri_rtcmode2_intflag_reg_t = u8;
pub type hri_rtcmode2_mask_reg_t = u8;
pub type hri_sercomi2cm_status_reg_t = u16;
pub type hri_sercomi2cs_status_reg_t = u16;
pub type hri_sercomspi_status_reg_t = u16;
pub type hri_sercomusart_baud_reg_t = u16;
pub type hri_sercomusart_data_reg_t = u16;
pub type hri_sercomusart_status_reg_t = u16;
pub type hri_sercomi2cm_addr_reg_t = u32;
pub type hri_sercomi2cm_baud_reg_t = u32;
pub type hri_sercomi2cm_ctrla_reg_t = u32;
pub type hri_sercomi2cm_ctrlb_reg_t = u32;
pub type hri_sercomi2cm_syncbusy_reg_t = u32;
pub type hri_sercomi2cs_addr_reg_t = u32;
pub type hri_sercomi2cs_ctrla_reg_t = u32;
pub type hri_sercomi2cs_ctrlb_reg_t = u32;
pub type hri_sercomi2cs_syncbusy_reg_t = u32;
pub type hri_sercomspi_addr_reg_t = u32;
pub type hri_sercomspi_ctrla_reg_t = u32;
pub type hri_sercomspi_ctrlb_reg_t = u32;
pub type hri_sercomspi_data_reg_t = u32;
pub type hri_sercomspi_syncbusy_reg_t = u32;
pub type hri_sercomusart_ctrla_reg_t = u32;
pub type hri_sercomusart_ctrlb_reg_t = u32;
pub type hri_sercomusart_syncbusy_reg_t = u32;
pub type hri_sercomi2cm_data_reg_t = u8;
pub type hri_sercomi2cm_dbgctrl_reg_t = u8;
pub type hri_sercomi2cm_intenset_reg_t = u8;
pub type hri_sercomi2cm_intflag_reg_t = u8;
pub type hri_sercomi2cs_data_reg_t = u8;
pub type hri_sercomi2cs_intenset_reg_t = u8;
pub type hri_sercomi2cs_intflag_reg_t = u8;
pub type hri_sercomspi_baud_reg_t = u8;
pub type hri_sercomspi_dbgctrl_reg_t = u8;
pub type hri_sercomspi_intenset_reg_t = u8;
pub type hri_sercomspi_intflag_reg_t = u8;
pub type hri_sercomusart_dbgctrl_reg_t = u8;
pub type hri_sercomusart_intenset_reg_t = u8;
pub type hri_sercomusart_intflag_reg_t = u8;
pub type hri_sercomusart_rxpl_reg_t = u8;
pub type hri_sysctrl_dfllctrl_reg_t = u16;
pub type hri_sysctrl_vreg_reg_t = u16;
pub type hri_sysctrl_xosc32k_reg_t = u16;
pub type hri_sysctrl_xosc_reg_t = u16;
pub type hri_sysctrl_bod33_reg_t = u32;
pub type hri_sysctrl_dfllmul_reg_t = u32;
pub type hri_sysctrl_dfllval_reg_t = u32;
pub type hri_sysctrl_dpllctrlb_reg_t = u32;
pub type hri_sysctrl_dpllratio_reg_t = u32;
pub type hri_sysctrl_intenset_reg_t = u32;
pub type hri_sysctrl_intflag_reg_t = u32;
pub type hri_sysctrl_osc32k_reg_t = u32;
pub type hri_sysctrl_osc8m_reg_t = u32;
pub type hri_sysctrl_pclksr_reg_t = u32;
pub type hri_sysctrl_vref_reg_t = u32;
pub type hri_sysctrl_dfllsync_reg_t = u8;
pub type hri_sysctrl_dpllctrla_reg_t = u8;
pub type hri_sysctrl_dpllstatus_reg_t = u8;
pub type hri_sysctrl_osculp32k_reg_t = u8;
pub type hri_tc_ctrla_reg_t = u16;
pub type hri_tc_evctrl_reg_t = u16;
pub type hri_tc_readreq_reg_t = u16;
pub type hri_tccount16_cc_reg_t = u16;
pub type hri_tccount16_count_reg_t = u16;
pub type hri_tccount32_cc_reg_t = u32;
pub type hri_tccount32_count_reg_t = u32;
pub type hri_tc_ctrlbset_reg_t = u8;
pub type hri_tc_ctrlc_reg_t = u8;
pub type hri_tc_dbgctrl_reg_t = u8;
pub type hri_tc_intenset_reg_t = u8;
pub type hri_tc_intflag_reg_t = u8;
pub type hri_tc_status_reg_t = u8;
pub type hri_tccount8_cc_reg_t = u8;
pub type hri_tccount8_count_reg_t = u8;
pub type hri_tccount8_per_reg_t = u8;
pub type hri_tcc_patt_reg_t = u16;
pub type hri_tcc_pattb_reg_t = u16;
pub type hri_tcc_cc_reg_t = u32;
pub type hri_tcc_ccb_reg_t = u32;
pub type hri_tcc_count_reg_t = u32;
pub type hri_tcc_ctrla_reg_t = u32;
pub type hri_tcc_drvctrl_reg_t = u32;
pub type hri_tcc_evctrl_reg_t = u32;
pub type hri_tcc_fctrla_reg_t = u32;
pub type hri_tcc_fctrlb_reg_t = u32;
pub type hri_tcc_intenset_reg_t = u32;
pub type hri_tcc_intflag_reg_t = u32;
pub type hri_tcc_per_reg_t = u32;
pub type hri_tcc_perb_reg_t = u32;
pub type hri_tcc_status_reg_t = u32;
pub type hri_tcc_syncbusy_reg_t = u32;
pub type hri_tcc_wave_reg_t = u32;
pub type hri_tcc_waveb_reg_t = u32;
pub type hri_tcc_wexctrl_reg_t = u32;
pub type hri_tcc_ctrlbset_reg_t = u8;
pub type hri_tcc_dbgctrl_reg_t = u8;
pub type hri_usb_padcal_reg_t = u16;
pub type hri_usbdesc_bank_ctrl_pipe_reg_t = u16;
pub type hri_usbdesc_bank_extreg_reg_t = u16;
pub type hri_usbdesc_bank_status_pipe_reg_t = u16;
pub type hri_usbdescriptordevice_extreg_reg_t = u16;
pub type hri_usbdescriptorhost_ctrl_pipe_reg_t = u16;
pub type hri_usbdescriptorhost_extreg_reg_t = u16;
pub type hri_usbdescriptorhost_status_pipe_reg_t = u16;
pub type hri_usbdevice_ctrlb_reg_t = u16;
pub type hri_usbdevice_epintsmry_reg_t = u16;
pub type hri_usbdevice_fnum_reg_t = u16;
pub type hri_usbdevice_intenset_reg_t = u16;
pub type hri_usbdevice_intflag_reg_t = u16;
pub type hri_usbhost_ctrlb_reg_t = u16;
pub type hri_usbhost_fnum_reg_t = u16;
pub type hri_usbhost_intenset_reg_t = u16;
pub type hri_usbhost_intflag_reg_t = u16;
pub type hri_usbhost_pintsmry_reg_t = u16;
pub type hri_usb_descadd_reg_t = u32;
pub type hri_usbdesc_bank_addr_reg_t = u32;
pub type hri_usbdesc_bank_pcksize_reg_t = u32;
pub type hri_usbdescriptordevice_addr_reg_t = u32;
pub type hri_usbdescriptordevice_pcksize_reg_t = u32;
pub type hri_usbdescriptorhost_addr_reg_t = u32;
pub type hri_usbdescriptorhost_pcksize_reg_t = u32;
pub type hri_usb_ctrla_reg_t = u8;
pub type hri_usb_fsmstatus_reg_t = u8;
pub type hri_usb_qosctrl_reg_t = u8;
pub type hri_usb_syncbusy_reg_t = u8;
pub type hri_usbdesc_bank_status_bk_reg_t = u8;
pub type hri_usbdescriptordevice_status_bk_reg_t = u8;
pub type hri_usbdescriptorhost_status_bk_reg_t = u8;
pub type hri_usbdevice_dadd_reg_t = u8;
pub type hri_usbdevice_epcfg_reg_t = u8;
pub type hri_usbdevice_epintenset_reg_t = u8;
pub type hri_usbdevice_epintflag_reg_t = u8;
pub type hri_usbdevice_epstatus_reg_t = u8;
pub type hri_usbdevice_status_reg_t = u8;
pub type hri_usbendpoint_epcfg_reg_t = u8;
pub type hri_usbendpoint_epintenset_reg_t = u8;
pub type hri_usbendpoint_epintflag_reg_t = u8;
pub type hri_usbendpoint_epstatus_reg_t = u8;
pub type hri_usbhost_binterval_reg_t = u8;
pub type hri_usbhost_flenhigh_reg_t = u8;
pub type hri_usbhost_hsofc_reg_t = u8;
pub type hri_usbhost_pcfg_reg_t = u8;
pub type hri_usbhost_pintenset_reg_t = u8;
pub type hri_usbhost_pintflag_reg_t = u8;
pub type hri_usbhost_pstatus_reg_t = u8;
pub type hri_usbhost_status_reg_t = u8;
pub type hri_usbpipe_binterval_reg_t = u8;
pub type hri_usbpipe_pcfg_reg_t = u8;
pub type hri_usbpipe_pintenset_reg_t = u8;
pub type hri_usbpipe_pintflag_reg_t = u8;
pub type hri_usbpipe_pstatus_reg_t = u8;
pub type hri_wdt_clear_reg_t = u8;
pub type hri_wdt_config_reg_t = u8;
pub type hri_wdt_ctrl_reg_t = u8;
pub type hri_wdt_ewctrl_reg_t = u8;
pub type hri_wdt_intenset_reg_t = u8;
pub type hri_wdt_intflag_reg_t = u8;
pub type hri_wdt_status_reg_t = u8;
pub const gpio_pull_mode_GPIO_PULL_OFF: gpio_pull_mode = 0;
pub const gpio_pull_mode_GPIO_PULL_UP: gpio_pull_mode = 1;
pub const gpio_pull_mode_GPIO_PULL_DOWN: gpio_pull_mode = 2;
#[doc = " \\brief PORT pull mode settings"]
pub type gpio_pull_mode = u32;
pub const gpio_direction_GPIO_DIRECTION_OFF: gpio_direction = 0;
pub const gpio_direction_GPIO_DIRECTION_IN: gpio_direction = 1;
pub const gpio_direction_GPIO_DIRECTION_OUT: gpio_direction = 2;
#[doc = " \\brief PORT direction settins"]
pub type gpio_direction = u32;
pub const gpio_port_GPIO_PORTA: gpio_port = 0;
pub const gpio_port_GPIO_PORTB: gpio_port = 1;
pub const gpio_port_GPIO_PORTC: gpio_port = 2;
pub const gpio_port_GPIO_PORTD: gpio_port = 3;
pub const gpio_port_GPIO_PORTE: gpio_port = 4;
#[doc = " \\brief PORT group abstraction"]
pub type gpio_port = u32;
extern "C" {
    #[doc = " \\brief Port initialization function"]
    #[doc = ""]
    #[doc = " Port initialization function should setup the port module based"]
    #[doc = " on a static configuration file, this function should normally"]
    #[doc = " not be called directly, but is a part of hal_init()"]
    pub fn _gpio_init();
}
extern "C" {
    #[doc = " \\brief Assert function"]
    #[doc = ""]
    #[doc = " This function is used to throw asserts."]
    #[doc = ""]
    #[doc = " \\param[in] condition A condition to be checked; assert is thrown if the given"]
    #[doc = "                      condition is false"]
    #[doc = " \\param[in] file File name"]
    #[doc = " \\param[in] line Line number"]
    pub fn assert(condition: bool, file: *const cty::c_char, line: cty::c_int);
}
extern "C" {
    #[doc = " \\brief Get current driver version"]
    pub fn gpio_get_version() -> u32;
}
#[doc = " \\brief IRQ descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _irq_descriptor {
    pub handler: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
    pub parameter: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout__irq_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<_irq_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(_irq_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<_irq_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(_irq_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_irq_descriptor>())).handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_descriptor),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_irq_descriptor>())).parameter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_descriptor),
            "::",
            stringify!(parameter)
        )
    );
}
extern "C" {
    #[doc = " \\brief Retrieve current IRQ number"]
    #[doc = ""]
    #[doc = " \\return The current IRQ number"]
    pub fn _irq_get_current() -> u8;
}
extern "C" {
    #[doc = " \\brief Disable the given IRQ"]
    #[doc = ""]
    #[doc = " \\param[in] n The number of IRQ to disable"]
    pub fn _irq_disable(n: u8);
}
extern "C" {
    #[doc = " \\brief Set the given IRQ"]
    #[doc = ""]
    #[doc = " \\param[in] n The number of IRQ to set"]
    pub fn _irq_set(n: u8);
}
extern "C" {
    #[doc = " \\brief Clear the given IRQ"]
    #[doc = ""]
    #[doc = " \\param[in] n The number of IRQ to clear"]
    pub fn _irq_clear(n: u8);
}
extern "C" {
    #[doc = " \\brief Enable the given IRQ"]
    #[doc = ""]
    #[doc = " \\param[in] n The number of IRQ to enable"]
    pub fn _irq_enable(n: u8);
}
extern "C" {
    #[doc = " \\brief Register IRQ handler"]
    #[doc = ""]
    #[doc = " \\param[in] number The number registered IRQ"]
    #[doc = " \\param[in] irq The pointer to irq handler to register"]
    #[doc = ""]
    #[doc = " \\return The status of IRQ handler registering"]
    #[doc = " \\retval -1 Passed parameters were invalid"]
    #[doc = " \\retval 0 The registering is completed successfully"]
    pub fn _irq_register(number: u8, irq: *mut _irq_descriptor);
}
pub const reset_reason_RESET_REASON_POR: reset_reason = 1;
pub const reset_reason_RESET_REASON_BOD12: reset_reason = 2;
pub const reset_reason_RESET_REASON_BOD33: reset_reason = 4;
pub const reset_reason_RESET_REASON_EXT: reset_reason = 16;
pub const reset_reason_RESET_REASON_WDT: reset_reason = 32;
pub const reset_reason_RESET_REASON_SYST: reset_reason = 64;
#[doc = " \\brief Reset reason enumeration"]
#[doc = ""]
#[doc = " The list of possible reset reasons."]
pub type reset_reason = u32;
extern "C" {
    #[doc = " \\brief Retrieve the reset reason"]
    #[doc = ""]
    #[doc = " Retrieves the reset reason of the last MCU reset."]
    #[doc = ""]
    #[doc = "\\return An enum value indicating the reason of the last reset."]
    pub fn _get_reset_reason() -> reset_reason;
}
extern "C" {
    #[doc = " \\brief Reset MCU"]
    pub fn _reset_mcu();
}
extern "C" {
    #[doc = " \\brief Set the sleep mode for the device"]
    #[doc = ""]
    #[doc = " This function sets the sleep mode for the device."]
    #[doc = " For an overview of which systems are disabled in sleep for the different"]
    #[doc = " sleep modes see datasheet."]
    #[doc = ""]
    #[doc = " \\param[in] mode Sleep mode to use"]
    #[doc = ""]
    #[doc = " \\return the status of a sleep request"]
    #[doc = " \\retval -1 The requested sleep mode was invalid"]
    #[doc = " \\retval  0 The operation completed successfully, sleep mode is set"]
    pub fn _set_sleep_mode(mode: u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Put MCU to sleep"]
    pub fn _go_to_sleep();
}
extern "C" {
    #[doc = " \\brief Initialize Delay driver"]
    #[doc = ""]
    #[doc = " \\param[in] hw The pointer to hardware instance"]
    pub fn delay_init(hw: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Perform delay in us"]
    #[doc = ""]
    #[doc = " This function performs delay for the given amount of microseconds."]
    #[doc = ""]
    #[doc = " \\param[in] us The amount delay in us"]
    pub fn delay_us(us: u16);
}
extern "C" {
    #[doc = " \\brief Perform delay in ms"]
    #[doc = ""]
    #[doc = " This function performs delay for the given amount of milliseconds."]
    #[doc = ""]
    #[doc = " \\param[in] ms The amount delay in ms"]
    pub fn delay_ms(ms: u16);
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version"]
    #[doc = ""]
    #[doc = " \\return Current driver version."]
    pub fn delay_get_version() -> u32;
}
extern "C" {
    #[doc = " \\brief Initializes clock sources"]
    pub fn _sysctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initializes Power Manager"]
    pub fn _pm_init();
}
extern "C" {
    #[doc = " \\brief Initialize generators"]
    pub fn _gclk_init_generators();
}
extern "C" {
    #[doc = " \\brief Initialize 32 kHz clock sources"]
    pub fn _osc32kctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources"]
    pub fn _oscctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources that need input reference clocks"]
    pub fn _sysctrl_init_referenced_generators();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources that need input reference clocks"]
    pub fn _oscctrl_init_referenced_generators();
}
extern "C" {
    #[doc = " \\brief Initialize master clock generator"]
    pub fn _mclk_init();
}
extern "C" {
    #[doc = " \\brief Initialize clock generator"]
    pub fn _lpmcu_misc_regs_init();
}
extern "C" {
    #[doc = " \\brief Initialize clock generator"]
    pub fn _pmc_init();
}
extern "C" {
    #[doc = " \\brief Set performance level"]
    #[doc = ""]
    #[doc = " \\param[in] level The performance level to set"]
    pub fn _set_performance_level(level: u8);
}
extern "C" {
    #[doc = " \\brief Initialize the chip"]
    pub fn _init_chip();
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version"]
    #[doc = ""]
    #[doc = " \\return Current driver version."]
    pub fn init_get_version() -> u32;
}
#[doc = " \\brief I/O write function pointer type"]
pub type io_write_t = ::core::option::Option<
    unsafe extern "C" fn(io_descr: *mut io_descriptor, buf: *const u8, length: u16) -> i32,
>;
#[doc = " \\brief I/O read function pointer type"]
pub type io_read_t = ::core::option::Option<
    unsafe extern "C" fn(io_descr: *mut io_descriptor, buf: *mut u8, length: u16) -> i32,
>;
#[doc = " \\brief I/O descriptor"]
#[doc = ""]
#[doc = " The I/O descriptor forward declaration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_descriptor {
    pub write: io_write_t,
    #[doc = " The write function pointer."]
    pub read: io_read_t,
}
#[test]
fn bindgen_test_layout_io_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<io_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(io_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<io_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(io_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_descriptor>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_descriptor),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_descriptor>())).read as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_descriptor),
            "::",
            stringify!(read)
        )
    );
}
extern "C" {
    #[doc = " \\brief I/O write interface"]
    #[doc = ""]
    #[doc = " This function writes up to \\p length of bytes to a given I/O descriptor."]
    #[doc = " It returns the number of bytes actually write."]
    #[doc = ""]
    #[doc = " \\param[in] descr  An I/O descriptor to write"]
    #[doc = " \\param[in] buf    The buffer pointer to story the write data"]
    #[doc = " \\param[in] length The number of bytes to write"]
    #[doc = ""]
    #[doc = " \\return The number of bytes written"]
    pub fn io_write(io_descr: *mut io_descriptor, buf: *const u8, length: u16) -> i32;
}
extern "C" {
    #[doc = " \\brief I/O read interface"]
    #[doc = ""]
    #[doc = " This function reads up to \\p length bytes from a given I/O descriptor, and"]
    #[doc = " stores it in the buffer pointed to by \\p buf. It returns the number of bytes"]
    #[doc = " actually read."]
    #[doc = ""]
    #[doc = " \\param[in] descr  An I/O descriptor to read"]
    #[doc = " \\param[in] buf    The buffer pointer to story the read data"]
    #[doc = " \\param[in] length The number of bytes to read"]
    #[doc = ""]
    #[doc = " \\return The number of bytes actually read. This number can be less than the"]
    #[doc = "         requested length. E.g., in a driver that uses ring buffer for"]
    #[doc = "         reception, it may depend on the availability of data in the"]
    #[doc = "         ring buffer."]
    pub fn io_read(io_descr: *mut io_descriptor, buf: *mut u8, length: u16) -> i32;
}
extern "C" {
    #[doc = " \\brief Set the sleep mode of the device and put the MCU to sleep"]
    #[doc = ""]
    #[doc = " For an overview of which systems are disabled in sleep for the different"]
    #[doc = " sleep modes, see the data sheet."]
    #[doc = ""]
    #[doc = " \\param[in] mode Sleep mode to use"]
    #[doc = ""]
    #[doc = " \\return The status of a sleep request"]
    #[doc = " \\retval -1 The requested sleep mode was invalid or not available"]
    #[doc = " \\retval  0 The operation completed successfully, returned after leaving the"]
    #[doc = "            sleep"]
    pub fn sleep(mode: u8) -> cty::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version"]
    #[doc = ""]
    #[doc = " \\return Current driver version."]
    pub fn sleep_get_version() -> u32;
}
#[doc = " \\brief Pointer to function"]
pub type FUNC_PTR = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " USB Low Speed."]
pub const usb_speed_USB_SPEED_LS: usb_speed = 0;
#[doc = " USB Full Speed."]
pub const usb_speed_USB_SPEED_FS: usb_speed = 1;
#[doc = " USB High Speed."]
pub const usb_speed_USB_SPEED_HS: usb_speed = 2;
#[doc = " USB Super Speed."]
pub const usb_speed_USB_SPEED_SS: usb_speed = 3;
#[doc = " USB speed."]
pub type usb_speed = u32;
#[doc = " USB SETUP transaction."]
pub const usb_trans_type_USB_TRANS_SETUP: usb_trans_type = 0;
#[doc = " USB IN transaction."]
pub const usb_trans_type_USB_TRANS_IN: usb_trans_type = 1;
#[doc = " USB OUT transaction."]
pub const usb_trans_type_USB_TRANS_OUT: usb_trans_type = 2;
#[doc = " USB transaction type."]
pub type usb_trans_type = u32;
#[doc = " USB VBus changed, with parameter as present/not present."]
pub const usb_event_USB_EV_VBUS: usb_event = 0;
#[doc = " USB RESET detected on bus."]
pub const usb_event_USB_EV_RESET: usb_event = 1;
#[doc = " USB wakeup."]
pub const usb_event_USB_EV_WAKEUP: usb_event = 2;
#[doc = " USB LPM suspend, with parameter as \\ref usb_lpm_attributes."]
pub const usb_event_USB_EV_LPM_SUSPEND: usb_event = 3;
#[doc = " USB suspend."]
pub const usb_event_USB_EV_SUSPEND: usb_event = 4;
#[doc = " USB error, with parameter as error code."]
pub const usb_event_USB_EV_ERROR: usb_event = 5;
#[doc = " Number of USB event types."]
pub const usb_event_USB_EV_N: usb_event = 6;
#[doc = " USB events that generates the device callbacks."]
pub type usb_event = u32;
#[doc = " Clear stall of the endpoint."]
pub const usb_ep_stall_ctrl_USB_EP_STALL_CLR: usb_ep_stall_ctrl = 0;
#[doc = " Stall the endpoint."]
pub const usb_ep_stall_ctrl_USB_EP_STALL_SET: usb_ep_stall_ctrl = 1;
#[doc = " Return the stall status."]
pub const usb_ep_stall_ctrl_USB_EP_STALL_GET: usb_ep_stall_ctrl = 2;
#[doc = " Control action for USB device endpoint stall."]
pub type usb_ep_stall_ctrl = u32;
#[doc = " Clear halt of the endpoint."]
pub const usb_ep_halt_ctrl_USB_EP_HALT_CLR: usb_ep_halt_ctrl = 0;
#[doc = " Stall the endpoint."]
pub const usb_ep_halt_ctrl_USB_EP_HALT_SET: usb_ep_halt_ctrl = 1;
#[doc = " Return the halt status."]
pub const usb_ep_halt_ctrl_USB_EP_HALT_GET: usb_ep_halt_ctrl = 2;
#[doc = " Control action for USB device endpoint halt."]
pub type usb_ep_halt_ctrl = u32;
#[doc = " TX or RX has been done without error."]
pub const usb_trans_code_USB_TRANS_DONE: usb_trans_code = 0;
#[doc = " The endpoint is stalled."]
pub const usb_trans_code_USB_TRANS_STALL: usb_trans_code = 1;
#[doc = " The endpoint transactions are aborted (cancel, control setup/status)."]
pub const usb_trans_code_USB_TRANS_ABORT: usb_trans_code = 2;
#[doc = " The endpoint transactions are aborted by reset/disable."]
pub const usb_trans_code_USB_TRANS_RESET: usb_trans_code = 3;
#[doc = " Error is reported on the endpoint."]
pub const usb_trans_code_USB_TRANS_ERROR: usb_trans_code = 4;
#[doc = " USB transactions status codes."]
pub type usb_trans_code = u32;
#[doc = " Transfer is done without error, for ctrl it means status packet done."]
pub const usb_xfer_code_USB_XFER_DONE: usb_xfer_code = 0;
#[doc = " For control transfer only, data stage is done without error."]
pub const usb_xfer_code_USB_XFER_DATA: usb_xfer_code = 1;
#[doc = " Endpoint stall is set."]
pub const usb_xfer_code_USB_XFER_HALT: usb_xfer_code = 2;
#[doc = " Endpoint stall is cleared."]
pub const usb_xfer_code_USB_XFER_UNHALT: usb_xfer_code = 3;
#[doc = " Transfer is aborted."]
pub const usb_xfer_code_USB_XFER_ABORT: usb_xfer_code = 4;
#[doc = " Transfer is aborted because endpoint reset/disable."]
pub const usb_xfer_code_USB_XFER_RESET: usb_xfer_code = 5;
#[doc = " There was an error."]
pub const usb_xfer_code_USB_XFER_ERROR: usb_xfer_code = 6;
#[doc = " Transfer status codes."]
pub type usb_xfer_code = u32;
#[doc = " No error."]
pub const usb_ep_error_USB_EP_NO_ERROR: usb_ep_error = 0;
#[doc = " CRC error."]
pub const usb_ep_error_USB_EP_ERR_CRC: usb_ep_error = 1;
#[doc = " Endpoint transfer overflow."]
pub const usb_ep_error_USB_EP_ERR_OVERFLOW: usb_ep_error = 2;
#[doc = " Other endpoint errors."]
pub const usb_ep_error_USB_EP_ERR_GENERAL: usb_ep_error = 3;
#[doc = " USB endpoint errors."]
pub type usb_ep_error = u32;
#[doc = " Endpoint is disabled."]
pub const usb_ep_state_USB_EP_S_DISABLED: usb_ep_state = 0;
#[doc = " Endpoint is not busy."]
pub const usb_ep_state_USB_EP_S_IDLE: usb_ep_state = 1;
#[doc = " Control transfer only, endpoint is transferring setup packet."]
pub const usb_ep_state_USB_EP_S_X_SETUP: usb_ep_state = 2;
#[doc = " Endpoint is transferring data."]
pub const usb_ep_state_USB_EP_S_X_DATA: usb_ep_state = 3;
#[doc = " Control transfer only, endpoint is in status stage."]
pub const usb_ep_state_USB_EP_S_X_STATUS: usb_ep_state = 4;
#[doc = " Endpoint is halted."]
pub const usb_ep_state_USB_EP_S_HALTED: usb_ep_state = 5;
#[doc = " Endpoint error."]
pub const usb_ep_state_USB_EP_S_ERROR: usb_ep_state = 6;
#[doc = " Endpoint transfer state."]
pub type usb_ep_state = u32;
#[doc = " USB device SOF callback."]
pub const usb_d_cb_type_USB_D_CB_SOF: usb_d_cb_type = 0;
#[doc = " USB device events callbacks."]
pub const usb_d_cb_type_USB_D_CB_EVENT: usb_d_cb_type = 1;
#[doc = " Number of types of USB device callback types."]
pub const usb_d_cb_type_USB_D_CB_N: usb_d_cb_type = 2;
#[doc = " USB Device callback type."]
pub type usb_d_cb_type = u32;
#[doc = " USB device endpoint setup callback."]
pub const usb_d_ep_cb_type_USB_D_EP_CB_SETUP: usb_d_ep_cb_type = 0;
#[doc = " USB device endpoint more data callback."]
pub const usb_d_ep_cb_type_USB_D_EP_CB_MORE: usb_d_ep_cb_type = 1;
#[doc = " USB device endpoint transaction done or error callback."]
pub const usb_d_ep_cb_type_USB_D_EP_CB_XFER: usb_d_ep_cb_type = 2;
#[doc = " Number of types of USB device endpoint callback types."]
pub const usb_d_ep_cb_type_USB_D_EP_CB_N: usb_d_ep_cb_type = 3;
#[doc = " USB Device endpoint callback type."]
pub type usb_d_ep_cb_type = u32;
#[doc = " No LPM handshake, not supported."]
pub const usb_d_lpm_ctrl_USB_D_LPM_DISABLE: usb_d_lpm_ctrl = 0;
#[doc = " ACK the LPM transaction."]
pub const usb_d_lpm_ctrl_USB_D_LPM_ACK: usb_d_lpm_ctrl = 1;
#[doc = " NYET the LPM transaction."]
pub const usb_d_lpm_ctrl_USB_D_LPM_NYET: usb_d_lpm_ctrl = 2;
#[doc = " Control action for USB device LPM handshake."]
pub type usb_d_lpm_ctrl = u32;
#[doc = "  USB device transfer descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_d_transfer {
    #[doc = " Pointer to data buffer to transfer."]
    #[doc = "  Note that it's recommended that the buffer is 32-bit aligned since"]
    #[doc = "  some of USB peripheral require this."]
    pub buf: *mut u8,
    #[doc = " Transfer size, in number of bytes."]
    #[doc = "  Note that it's recommended that the buffer size is 32-bit aligned"]
    #[doc = "  (modeled by 4) since some of USB peripheral require this."]
    pub size: u32,
    #[doc = " Endpoint address."]
    pub ep: u8,
    #[doc = " Append ZLP for IN transfer, wait ZLP for OUT transfer."]
    pub zlp: u8,
}
#[test]
fn bindgen_test_layout_usb_d_transfer() {
    assert_eq!(
        ::core::mem::size_of::<usb_d_transfer>(),
        12usize,
        concat!("Size of: ", stringify!(usb_d_transfer))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_d_transfer>(),
        4usize,
        concat!("Alignment of ", stringify!(usb_d_transfer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_transfer>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_transfer),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_transfer>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_transfer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_transfer>())).ep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_transfer),
            "::",
            stringify!(ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_transfer>())).zlp as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_transfer),
            "::",
            stringify!(zlp)
        )
    );
}
#[doc = " USB device transactions status structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_d_trans_status {
    #[doc = " Total data size."]
    pub size: u32,
    #[doc = " Total transfered data count."]
    pub count: u32,
    #[doc = " Endpoint address."]
    pub ep: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_usb_d_trans_status() {
    assert_eq!(
        ::core::mem::size_of::<usb_d_trans_status>(),
        12usize,
        concat!("Size of: ", stringify!(usb_d_trans_status))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_d_trans_status>(),
        4usize,
        concat!("Alignment of ", stringify!(usb_d_trans_status))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_trans_status>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_trans_status),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_trans_status>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_trans_status),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_trans_status>())).ep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_trans_status),
            "::",
            stringify!(ep)
        )
    );
}
impl usb_d_trans_status {
    #[inline]
    pub fn xtype(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_xtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn busy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn setup(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_setup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stall(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stall(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xtype: u8,
        busy: u8,
        setup: u8,
        stall: u8,
        dir: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let xtype: u8 = unsafe { ::core::mem::transmute(xtype) };
            xtype as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let busy: u8 = unsafe { ::core::mem::transmute(busy) };
            busy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let setup: u8 = unsafe { ::core::mem::transmute(setup) };
            setup as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let stall: u8 = unsafe { ::core::mem::transmute(stall) };
            stall as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dir: u8 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Prototype function for callback that is invoked on USB device SOF."]
pub type _usb_d_dev_sof_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Prototype function for callback that is invoked on USB device events."]
pub type _usb_d_dev_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: usb_event, param: u32)>;
#[doc = " HPL USB device callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usb_d_dev_callbacks {
    #[doc = " Callback that is invoked on SOF."]
    pub sof: _usb_d_dev_sof_cb_t,
    #[doc = " Callback that is invoked on USB RESET/WAKEUP/RESUME/SUSPEND."]
    pub event: _usb_d_dev_event_cb_t,
}
#[test]
fn bindgen_test_layout__usb_d_dev_callbacks() {
    assert_eq!(
        ::core::mem::size_of::<_usb_d_dev_callbacks>(),
        8usize,
        concat!("Size of: ", stringify!(_usb_d_dev_callbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<_usb_d_dev_callbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(_usb_d_dev_callbacks))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_usb_d_dev_callbacks>())).sof as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usb_d_dev_callbacks),
            "::",
            stringify!(sof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_usb_d_dev_callbacks>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_usb_d_dev_callbacks),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " Setup packet is received."]
pub const usb_d_dev_ep_cb_type_USB_D_DEV_EP_CB_SETUP: usb_d_dev_ep_cb_type = 0;
#[doc = " Try to require more data."]
pub const usb_d_dev_ep_cb_type_USB_D_DEV_EP_CB_MORE: usb_d_dev_ep_cb_type = 1;
#[doc = " Transaction done OK/ERROR."]
pub const usb_d_dev_ep_cb_type_USB_D_DEV_EP_CB_DONE: usb_d_dev_ep_cb_type = 2;
#[doc = " Number of device endpoint callbacks."]
pub const usb_d_dev_ep_cb_type_USB_D_DEV_EP_CB_N: usb_d_dev_ep_cb_type = 3;
#[doc = " USB device endpoint callbacks."]
pub type usb_d_dev_ep_cb_type = u32;
#[doc = "  Callback that is invoked when control SETUP packet has bee received."]
#[doc = "  \\ref _usb_d_dev_ep_read_req() must be invoked to read setup data, and allow"]
#[doc = "  IN/OUT transactions on control endpoint."]
pub type _usb_d_dev_ep_cb_setup_t = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = " Callback that is invoked when buffer is done, but last packet is full size"]
#[doc = "  packet without ZLP. Return \\c true if more data has been requested."]
pub type _usb_d_dev_ep_cb_more_t =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, transfered: u32) -> bool>;
#[doc = " Callback that is invoked when all data is finished, including background"]
#[doc = "  transfer, or error happens."]
pub type _usb_d_dev_ep_cb_done_t =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, code: i32, transfered: u32)>;
#[doc = " Callbacks for HPL USB device endpoint."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usb_d_dev_ep_callbacks {
    #[doc = " Callback that is invoked when SETUP packet is received."]
    #[doc = "  \\ref _usb_d_dev_ep_read_req() must be invoked to read setup data, and"]
    #[doc = "  allow IN/OUT transactions on control endpoint."]
    pub setup: _usb_d_dev_ep_cb_setup_t,
    #[doc = " Callback that is invoked to check if buffer is NULL and more data is"]
    #[doc = "  required."]
    #[doc = "  It's called when last packet is full size packet, without"]
    #[doc = "  auto ZLP enabled."]
    #[doc = "  It could be called when background transfer is still in progress."]
    pub more: _usb_d_dev_ep_cb_more_t,
    #[doc = " Callback that is invoked when transaction is done, including background"]
    #[doc = "  transfer, or error occurs."]
    pub done: _usb_d_dev_ep_cb_done_t,
}
#[test]
fn bindgen_test_layout__usb_d_dev_ep_callbacks() {
    assert_eq!(
        ::core::mem::size_of::<_usb_d_dev_ep_callbacks>(),
        12usize,
        concat!("Size of: ", stringify!(_usb_d_dev_ep_callbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<_usb_d_dev_ep_callbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(_usb_d_dev_ep_callbacks))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_usb_d_dev_ep_callbacks>())).setup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usb_d_dev_ep_callbacks),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_usb_d_dev_ep_callbacks>())).more as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_usb_d_dev_ep_callbacks),
            "::",
            stringify!(more)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_usb_d_dev_ep_callbacks>())).done as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_usb_d_dev_ep_callbacks),
            "::",
            stringify!(done)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize the USB device instance"]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_init() -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize the USB device instance"]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_deinit();
}
extern "C" {
    #[doc = " \\brief Register callback to handle USB device events"]
    #[doc = " \\param[in] type Callback type. See \\ref usb_d_cb_type."]
    #[doc = " \\param[in] func Pointer to callback function."]
    #[doc = "         Refer to \\ref _usb_d_dev_callbacks for the prototypes."]
    pub fn _usb_d_dev_register_callback(type_: usb_d_cb_type, func: FUNC_PTR);
}
extern "C" {
    #[doc = " \\brief Register callback to handle USB device endpoint events"]
    #[doc = " \\param[in] type Callback type. See \\ref usb_d_dev_ep_cb_type."]
    #[doc = " \\param[in] func Pointer to callback function."]
    #[doc = "         Refer to \\ref _usb_d_dev_ep_callbacks for the prototypes."]
    pub fn _usb_d_dev_register_ep_callback(type_: usb_d_dev_ep_cb_type, func: FUNC_PTR);
}
extern "C" {
    #[doc = " \\brief Enable the USB device"]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_enable() -> i32;
}
extern "C" {
    #[doc = " \\brief Disable the USB device"]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_disable() -> i32;
}
extern "C" {
    #[doc = " \\brief Attach the USB device"]
    pub fn _usb_d_dev_attach();
}
extern "C" {
    #[doc = " \\brief Detach the USB device"]
    pub fn _usb_d_dev_detach();
}
extern "C" {
    #[doc = " \\brief Send the USB device remote wakeup to host"]
    pub fn _usb_d_dev_send_remotewakeup();
}
extern "C" {
    #[doc = " \\brief Get the USB device working speed"]
    #[doc = " \\return USB speed. See \\ref usb_speed."]
    pub fn _usb_d_dev_get_speed() -> usb_speed;
}
extern "C" {
    #[doc = " \\brief Set the USB device address"]
    #[doc = " \\param[in] addr Address to be used."]
    pub fn _usb_d_dev_set_address(addr: u8);
}
extern "C" {
    #[doc = " \\brief Get the USB device address"]
    #[doc = " \\return Address that is used."]
    pub fn _usb_d_dev_get_address() -> u8;
}
extern "C" {
    #[doc = " \\brief Get the USB device frame number"]
    #[doc = " \\return The frame number."]
    pub fn _usb_d_dev_get_frame_n() -> u16;
}
extern "C" {
    #[doc = " \\brief Get the USB device micro frame number"]
    #[doc = " \\return The micro frame number inside one frame (0~7)."]
    pub fn _usb_d_dev_get_uframe_n() -> u8;
}
extern "C" {
    #[doc = " \\brief Initialize and enable the USB device default endpoint 0"]
    #[doc = " \\param[in] max_pkt_siz Max endpoint size."]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_ep0_init(max_pkt_siz: u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Initialize and enable the USB device endpoint"]
    #[doc = " \\param[in] ep Endpoint address,"]
    #[doc = "               see endpoint descriptor details in USB spec."]
    #[doc = " \\param[in] attr Endpoint attributes,"]
    #[doc = "                 see endpoint descriptor details in USB spec."]
    #[doc = " \\param[in] max_pkt_siz Endpoint size,"]
    #[doc = "                        see endpoint descriptor details in USB spec."]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_ep_init(ep: u8, attr: u8, max_pkt_siz: u16) -> i32;
}
extern "C" {
    #[doc = " \\brief Disable and deinitialize the USB device endpoint"]
    #[doc = ""]
    #[doc = " \\param[in] ep The endpoint to deinitialize."]
    pub fn _usb_d_dev_ep_deinit(ep: u8);
}
extern "C" {
    #[doc = " \\brief Enable the endpoint"]
    #[doc = " \\param[in] ep The endpoint to enable."]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_ep_enable(ep: u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Disable the endpoint"]
    #[doc = " \\param[in] ep The endpoint to disable."]
    pub fn _usb_d_dev_ep_disable(ep: u8);
}
extern "C" {
    #[doc = " \\brief Set/Clear/Get USB device endpoint stall status"]
    #[doc = " \\param[in] ep Endpoint address."]
    #[doc = " \\param[in] ctrl Operation selector. See \\ref usb_ep_stall_ctrl."]
    #[doc = " \\return Operation result or stall status."]
    #[doc = " \\retval 0 Success or not stall."]
    #[doc = " \\retval 1 Endpoint is stalled."]
    #[doc = " \\retval -1 error."]
    pub fn _usb_d_dev_ep_stall(ep: u8, ctrl: usb_ep_stall_ctrl) -> i32;
}
extern "C" {
    #[doc = " \\brief Read setup request data from specific endpoint"]
    #[doc = " \\param[in] ep Endpoint address."]
    #[doc = " \\param[out] req_buf Pointer to buffer to locate the setup packet."]
    #[doc = " \\return Number of bytes or error code."]
    #[doc = " \\retval <0 error code."]
    #[doc = " \\retval 0 No setup packet ready for read."]
    #[doc = " \\retval >0 Size of bytes read, and ready to start IN/OUT. Note that if"]
    #[doc = "         this number is over 8, only first 8 bytes will be copied."]
    pub fn _usb_d_dev_ep_read_req(ep: u8, req_buf: *mut u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Start USB device transfer"]
    #[doc = ""]
    #[doc = " On different USB peripheral hardware the transaction buffer address and size"]
    #[doc = " may have different constraints. E.g., some hardware may require input address"]
    #[doc = " 32-bit aligned, and input size 32-bit aligned. Refer to the corresponding"]
    #[doc = " hardware usage reference documents."]
    #[doc = " The constraints are checked in implementation, with error code returned."]
    #[doc = ""]
    #[doc = " \\param[in] trans Pointer to the transaction description."]
    #[doc = " \\return Operation result status."]
    #[doc = " \\retval 1 Busy."]
    #[doc = " \\retval 0 Success."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_ep_trans(trans: *const usb_d_transfer) -> i32;
}
extern "C" {
    #[doc = " \\brief Abort pending USB device transaction on specific endpoint"]
    #[doc = " \\param[in] ep Endpoint address to abort."]
    pub fn _usb_d_dev_ep_abort(ep: u8);
}
extern "C" {
    #[doc = " \\brief Retrieve endpoint status."]
    #[doc = " \\param[in] ep Endpoint address."]
    #[doc = " \\param[out] stat Pointer to buffer to fill status description."]
    #[doc = " \\return Status."]
    #[doc = " \\retval 2 Packet writing."]
    #[doc = " \\retval 1 Busy."]
    #[doc = " \\retval 0 Ready."]
    #[doc = " \\retval <0 Error code."]
    pub fn _usb_d_dev_ep_get_status(ep: u8, stat: *mut usb_d_trans_status) -> i32;
}
#[doc = " USB device endpoint status structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_d_ep_status {
    #[doc = " Endpoint address, including direction."]
    pub ep: u8,
    #[doc = " Endpoint transfer status code that triggers the callback."]
    #[doc = "  \\ref usb_xfer_code."]
    pub code: u8,
    #[doc = " Endpoint error, if \\c code is \\ref USB_TRANS_ERROR."]
    pub error: u8,
    #[doc = " Transfer state, \\ref usb_ep_state."]
    pub state: u8,
    #[doc = " Transfer count."]
    pub count: u32,
    #[doc = " Transfer size."]
    pub size: u32,
}
#[test]
fn bindgen_test_layout_usb_d_ep_status() {
    assert_eq!(
        ::core::mem::size_of::<usb_d_ep_status>(),
        12usize,
        concat!("Size of: ", stringify!(usb_d_ep_status))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_d_ep_status>(),
        4usize,
        concat!("Alignment of ", stringify!(usb_d_ep_status))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).ep as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).error as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).state as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_ep_status>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_ep_status),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Prototype function for callback that is invoked on USB device SOF."]
pub type usb_d_sof_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Prototype function for callback that is invoked on USB device events."]
pub type usb_d_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(event: usb_event, param: u32)>;
#[doc = " USB device callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_d_callbacks {
    #[doc = " Callback that is invoked on SOF."]
    pub sof: usb_d_sof_cb_t,
    #[doc = " Callback that is invoked on USB RESET/WAKEUP/RESUME/SUSPEND."]
    pub event: usb_d_event_cb_t,
}
#[test]
fn bindgen_test_layout_usb_d_callbacks() {
    assert_eq!(
        ::core::mem::size_of::<usb_d_callbacks>(),
        8usize,
        concat!("Size of: ", stringify!(usb_d_callbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_d_callbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(usb_d_callbacks))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_callbacks>())).sof as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_callbacks),
            "::",
            stringify!(sof)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_d_callbacks>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_d_callbacks),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " Callback that is invoked when setup packet is received."]
#[doc = "  Return \\c true if request has been handled, or control endpoint will"]
#[doc = "  stall IN/OUT transactions."]
pub type usb_d_ep_cb_setup_t =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, req: *const u8) -> bool>;
#[doc = " Callback that is invoked when buffer is done without error, but last packet"]
#[doc = "  is full size packet without ZLP."]
#[doc = "  Return \\c true if more data has been requested."]
pub type usb_d_ep_cb_more_t =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, count: u32) -> bool>;
#[doc = " Callback that is invoked when all data is finished, including background"]
#[doc = "  transfer, or error happens."]
#[doc = "  In control transfer data stage, return value is checked,"]
#[doc = "  return \\c false if no error happens."]
pub type usb_d_ep_cb_xfer_t = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, code: usb_xfer_code, param: *mut cty::c_void) -> bool,
>;
extern "C" {
    #[doc = "  \\brief Initialize the USB device driver"]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_init() -> i32;
}
extern "C" {
    #[doc = "  \\brief Deinitialize the USB device driver"]
    pub fn usb_d_deinit();
}
extern "C" {
    #[doc = "  \\brief Register the USB device callback"]
    #[doc = "  \\param[in] type The callback type to register."]
    #[doc = "  \\param[in] func The callback function, NULL to disable callback."]
    pub fn usb_d_register_callback(type_: usb_d_cb_type, func: FUNC_PTR);
}
extern "C" {
    #[doc = "  \\brief Enable the USB device driver"]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_enable() -> i32;
}
extern "C" {
    #[doc = "  \\brief Disable the USB device driver"]
    pub fn usb_d_disable();
}
extern "C" {
    #[doc = "  \\brief Attach the USB device"]
    pub fn usb_d_attach();
}
extern "C" {
    #[doc = "  \\brief Detach the USB device"]
    pub fn usb_d_detach();
}
extern "C" {
    #[doc = "  \\brief Retrieve current USB working speed."]
    #[doc = "  \\return USB Speed. See \\ref usb_speed."]
    pub fn usb_d_get_speed() -> usb_speed;
}
extern "C" {
    #[doc = "  \\brief Retrieve current USB frame number."]
    #[doc = "  \\return Frame number."]
    pub fn usb_d_get_frame_num() -> u16;
}
extern "C" {
    #[doc = "  \\brief Retrieve current USB micro frame number."]
    #[doc = "  \\return Micro frame number inside a frame (0~7)."]
    #[doc = "          0 if not available (not HS)."]
    pub fn usb_d_get_uframe_num() -> u8;
}
extern "C" {
    #[doc = "  \\brief Set the USB address that is used."]
    #[doc = "  \\param[in] addr The address to set."]
    pub fn usb_d_set_address(addr: u8);
}
extern "C" {
    #[doc = "  \\brief Send remote wakeup to host"]
    #[doc = "  \\return Operation status."]
    pub fn usb_d_send_remotewakeup();
}
extern "C" {
    #[doc = "  \\brief Initialize the endpoint 0."]
    #[doc = ""]
    #[doc = "  Note that endpoint 0 must be initialized as control endpoint."]
    #[doc = ""]
    #[doc = "  \\param[in] max_pkt_size Max. packet size of EP0."]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_ep0_init(max_pkt_size: u8) -> i32;
}
extern "C" {
    #[doc = "  \\brief Initialize the endpoint."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\param[in] attr The endpoint attributes."]
    #[doc = "  \\param[in] max_pkt_size Max. packet size of EP0."]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_ep_init(ep: u8, attr: u8, max_pkt_size: u16) -> i32;
}
extern "C" {
    #[doc = "  \\brief Disable and deinitialize the endpoint."]
    #[doc = "  \\param[in] ep The endpoint address to deinitialize."]
    pub fn usb_d_ep_deinit(ep: u8);
}
extern "C" {
    #[doc = "  \\brief Register the USB device endpoint callback on initialized endpoint."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\param[in] type The callback type to register."]
    #[doc = "  \\param[in] func The callback function, NULL to disable callback."]
    pub fn usb_d_ep_register_callback(ep: u8, type_: usb_d_ep_cb_type, func: FUNC_PTR);
}
extern "C" {
    #[doc = "  \\brief Enabled the initialized endpoint."]
    #[doc = ""]
    #[doc = "  Setup request will be monitored after enabling a control endpoint."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_ep_enable(ep: u8) -> i32;
}
extern "C" {
    #[doc = "  \\brief Disable the initialized endpoint."]
    #[doc = "  \\param[in] ep The endpoint address."]
    pub fn usb_d_ep_disable(ep: u8);
}
extern "C" {
    #[doc = "  \\brief Get request data pointer to access received setup request packet"]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\return Pointer to the request data."]
    #[doc = "  \\retval NULL The endpoint is not a control endpoint."]
    pub fn usb_d_ep_get_req(ep: u8) -> *mut u8;
}
extern "C" {
    #[doc = "  \\brief Endpoint transfer."]
    #[doc = ""]
    #[doc = "  For control endpoints, start the transfer according to the direction in the bmRequest"]
    #[doc = "  type, and finish with STATUS stage."]
    #[doc = "  For non-control endpoints, the transfer will be unique direction. Defined by"]
    #[doc = "  bit 8 of the endpoint address."]
    #[doc = ""]
    #[doc = "  \\param[in] xfer Pointer to the transfer description."]
    #[doc = "  \\return Operation status."]
    #[doc = "  \\retval 0 Success."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_ep_transfer(xfer: *const usb_d_transfer) -> i32;
}
extern "C" {
    #[doc = "  \\brief Abort an on-going transfer on a specific endpoint."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    pub fn usb_d_ep_abort(ep: u8);
}
extern "C" {
    #[doc = "  \\brief Retrieve the endpoint status."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\param[out] stat Pointer to the buffer to fill the status description."]
    #[doc = ""]
    #[doc = "  \\return Endpoint status."]
    #[doc = "  \\retval 1 Busy."]
    #[doc = "  \\retval 0 Idle."]
    #[doc = "  \\retval <0 Error code."]
    pub fn usb_d_ep_get_status(ep: u8, stat: *mut usb_d_ep_status) -> i32;
}
extern "C" {
    #[doc = "  \\brief Endpoint halt control."]
    #[doc = ""]
    #[doc = "  \\param[in] ep The endpoint address."]
    #[doc = "  \\param[in] ctrl Control code (SET/CLEAR/GET)."]
    #[doc = ""]
    #[doc = "  \\return Operation status or HALT state (if \\c ctrl is \\ref USB_EP_HALT_GET)."]
    pub fn usb_d_ep_halt(ep: u8, ctrl: usb_ep_halt_ctrl) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version"]
    #[doc = ""]
    #[doc = "  \\return Current driver version."]
    pub fn usb_d_get_version() -> u32;
}
extern "C" {
    pub fn USB_DEVICE_INSTANCE_CLOCK_init();
}
extern "C" {
    pub fn USB_DEVICE_INSTANCE_init();
}
extern "C" {
    #[doc = " \\brief Perform system initialization, initialize pins and clocks for"]
    #[doc = " peripherals"]
    pub fn system_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_T;
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = *mut cty::c_char;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._ind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._fns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._up as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._data as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._niobs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._iobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _unspecified_locale_info: cty::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: cty::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 30usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: cty::c_uint,
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut cty::c_uchar; 30usize],
    pub _nmalloc: [cty::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stderr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._inc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._emergency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._locale as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result_k as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._p5s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._freelist as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sglue as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sf as *const _ as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const cty::c_void, arg2: *mut cty::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut cty::c_void, arg2: cty::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn fls(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn flsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn flsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn index(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const cty::c_void,
        arg2: cty::c_int,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut cty::c_void, arg2: cty::c_int, arg3: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strerror(arg1: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: cty::c_int, arg2: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_int,
        arg4: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const cty::c_char, arg2: cty::c_uint) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strerror_r(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: cty::c_int,
        arg4: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__signo: cty::c_int) -> *mut cty::c_char;
}
#[doc = " \\brief List element type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_element {
    pub next: *mut list_element,
}
#[test]
fn bindgen_test_layout_list_element() {
    assert_eq!(
        ::core::mem::size_of::<list_element>(),
        4usize,
        concat!("Size of: ", stringify!(list_element))
    );
    assert_eq!(
        ::core::mem::align_of::<list_element>(),
        4usize,
        concat!("Alignment of ", stringify!(list_element))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_element>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_element),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " \\brief List head type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_descriptor {
    pub head: *mut list_element,
}
#[test]
fn bindgen_test_layout_list_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<list_descriptor>(),
        4usize,
        concat!("Size of: ", stringify!(list_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<list_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(list_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<list_descriptor>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_descriptor),
            "::",
            stringify!(head)
        )
    );
}
extern "C" {
    #[doc = " \\brief Insert an element as list head"]
    #[doc = ""]
    #[doc = " \\param[in] list The pointer to a list element"]
    #[doc = " \\param[in] element An element to insert to the given list"]
    pub fn list_insert_as_head(list: *mut list_descriptor, element: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Insert an element after the given list element"]
    #[doc = ""]
    #[doc = " \\param[in] after An element to insert after"]
    #[doc = " \\param[in] element Element to insert to the given list"]
    pub fn list_insert_after(after: *mut cty::c_void, element: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Insert an element at list end"]
    #[doc = ""]
    #[doc = " \\param[in] after An element to insert after"]
    #[doc = " \\param[in] element Element to insert to the given list"]
    pub fn list_insert_at_end(list: *mut list_descriptor, element: *mut cty::c_void);
}
extern "C" {
    #[doc = " \\brief Check whether an element belongs to a list"]
    #[doc = ""]
    #[doc = " \\param[in] list The pointer to a list"]
    #[doc = " \\param[in] element An element to check"]
    #[doc = ""]
    #[doc = " \\return The result of checking"]
    #[doc = " \\retval true If the given element is an element of the given list"]
    #[doc = " \\retval false Otherwise"]
    pub fn is_list_element(list: *const list_descriptor, element: *const cty::c_void) -> bool;
}
extern "C" {
    #[doc = " \\brief Removes list head"]
    #[doc = ""]
    #[doc = " This function removes the list head and sets the next element after the list"]
    #[doc = " head as a new list head."]
    #[doc = ""]
    #[doc = " \\param[in] list The pointer to a list"]
    #[doc = ""]
    #[doc = " \\return The pointer to the new list head of NULL if the list head is NULL"]
    pub fn list_remove_head(list: *mut list_descriptor) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " \\brief Removes the list element"]
    #[doc = ""]
    #[doc = " \\param[in] list The pointer to a list"]
    #[doc = " \\param[in] element An element to remove"]
    #[doc = ""]
    #[doc = " \\return The result of element removing"]
    #[doc = " \\retval true The given element is removed from the given list"]
    #[doc = " \\retval false The given element is not an element of the given list"]
    pub fn list_delete_element(list: *mut list_descriptor, element: *const cty::c_void) -> bool;
}
pub type le16_t = u16;
pub type le32_t = u32;
pub type be16_t = u16;
pub type be32_t = u32;
pub const usb_ctrl_stage_USB_SETUP_STAGE: usb_ctrl_stage = 0;
pub const usb_ctrl_stage_USB_DATA_STAGE: usb_ctrl_stage = 1;
pub const usb_ctrl_stage_USB_STATUS_STAGE: usb_ctrl_stage = 2;
#[doc = " \\brief Standard USB control transfer stages."]
pub type usb_ctrl_stage = u32;
pub const usb_req_code_USB_REQ_GET_STATUS: usb_req_code = 0;
pub const usb_req_code_USB_REQ_CLEAR_FTR: usb_req_code = 1;
pub const usb_req_code_USB_REQ_SET_FTR: usb_req_code = 3;
pub const usb_req_code_USB_REQ_SET_ADDRESS: usb_req_code = 5;
pub const usb_req_code_USB_REQ_GET_DESC: usb_req_code = 6;
pub const usb_req_code_USB_REQ_SET_DESC: usb_req_code = 7;
pub const usb_req_code_USB_REQ_GET_CONFIG: usb_req_code = 8;
pub const usb_req_code_USB_REQ_SET_CONFIG: usb_req_code = 9;
pub const usb_req_code_USB_REQ_GET_INTERFACE: usb_req_code = 10;
pub const usb_req_code_USB_REQ_SET_INTERFACE: usb_req_code = 11;
pub const usb_req_code_USB_REQ_SYNCH_FRAME: usb_req_code = 12;
pub const usb_req_code_USB_REQ_SET_SEL: usb_req_code = 48;
pub const usb_req_code_USB_REQ_ISOCH_DELAY: usb_req_code = 49;
#[doc = " \\brief Standard USB requests (bRequest)"]
pub type usb_req_code = u32;
pub const usb_dev_status_USB_DEV_STAT_BUS_POWERED: usb_dev_status = 0;
pub const usb_dev_status_USB_DEV_STAT_SELF_POWERED: usb_dev_status = 1;
pub const usb_dev_status_USB_DEV_STAT_REMOTEWAKEUP: usb_dev_status = 2;
pub const usb_dev_status_USB_DEV_STAT_U1_ENABLE: usb_dev_status = 4;
pub const usb_dev_status_USB_DEV_STAT_U2_ENABLE: usb_dev_status = 8;
pub const usb_dev_status_USB_DEV_STAT_LTM_ENABLE: usb_dev_status = 16;
#[doc = " \\brief Standard USB device status flags"]
#[doc = ""]
pub type usb_dev_status = u32;
pub const usb_interface_status_USB_IFACE_STAT_RESERVED: usb_interface_status = 0;
pub const usb_interface_status_USB_IFACE_STAT_REMOTEWAKE_CAP: usb_interface_status = 1;
pub const usb_interface_status_USB_IFACE_STAT_REMOTEWAKE: usb_interface_status = 2;
#[doc = " \\brief Standard USB Interface status flags"]
#[doc = ""]
pub type usb_interface_status = u32;
pub const usb_endpoint_status_USB_EP_STAT_HALT: usb_endpoint_status = 1;
#[doc = " \\brief Standard USB endpoint status flags"]
#[doc = ""]
pub type usb_endpoint_status = u32;
#[doc = "< Remote wakeup enabled"]
pub const usb_device_feature_USB_DEV_FTR_REMOTE_WAKEUP: usb_device_feature = 1;
#[doc = "< USB test mode"]
pub const usb_device_feature_USB_DEV_FTR_TEST_MODE: usb_device_feature = 2;
pub const usb_device_feature_USB_DEV_FTR_OTG_B_HNP_ENABLE: usb_device_feature = 3;
pub const usb_device_feature_USB_DEV_FTR_OTG_A_HNP_SP: usb_device_feature = 4;
pub const usb_device_feature_USB_DEV_FTR_OTG_A_ALT_HNP_SP: usb_device_feature = 5;
pub const usb_device_feature_USB_DEV_FTR_U1_ENABLE: usb_device_feature = 48;
pub const usb_device_feature_USB_DEV_FTR_U2_ENABLE: usb_device_feature = 49;
pub const usb_device_feature_USB_DEV_FTR_LTM_ENABLE: usb_device_feature = 50;
#[doc = " \\brief Standard USB device feature flags"]
#[doc = ""]
#[doc = " \\note valid for SetFeature request."]
pub type usb_device_feature = u32;
pub const usb_device_hs_test_mode_USB_DEV_TEST_MODE_J: usb_device_hs_test_mode = 1;
pub const usb_device_hs_test_mode_USB_DEV_TEST_MODE_K: usb_device_hs_test_mode = 2;
pub const usb_device_hs_test_mode_USB_DEV_TEST_MODE_SE0_NAK: usb_device_hs_test_mode = 3;
pub const usb_device_hs_test_mode_USB_DEV_TEST_MODE_PACKET: usb_device_hs_test_mode = 4;
pub const usb_device_hs_test_mode_USB_DEV_TEST_MODE_FORCE_ENABLE: usb_device_hs_test_mode = 5;
#[doc = " \\brief Test Mode possible on HS USB device"]
#[doc = ""]
#[doc = " \\note valid for USB_DEV_FTR_TEST_MODE request."]
pub type usb_device_hs_test_mode = u32;
pub const usb_iface_feature_USB_IFACE_FTR_FUNC_SUSP: usb_iface_feature = 0;
#[doc = " \\brief Standard Feature Selectors for Interface"]
pub type usb_iface_feature = u32;
pub const usb_endpoint_feature_USB_EP_FTR_HALT: usb_endpoint_feature = 0;
#[doc = " \\brief Standard USB endpoint feature/status flags"]
pub type usb_endpoint_feature = u32;
pub const usb_test_mode_selector_USB_TEST_J: usb_test_mode_selector = 1;
pub const usb_test_mode_selector_USB_TEST_K: usb_test_mode_selector = 2;
pub const usb_test_mode_selector_USB_TEST_SE0_NAK: usb_test_mode_selector = 3;
pub const usb_test_mode_selector_USB_TEST_PACKET: usb_test_mode_selector = 4;
pub const usb_test_mode_selector_USB_TEST_FORCE_ENABLE: usb_test_mode_selector = 5;
#[doc = " \\brief Standard USB Test Mode Selectors"]
pub type usb_test_mode_selector = u32;
pub const usb_descriptor_type_USB_DT_DEVICE: usb_descriptor_type = 1;
pub const usb_descriptor_type_USB_DT_CONFIG: usb_descriptor_type = 2;
pub const usb_descriptor_type_USB_DT_STRING: usb_descriptor_type = 3;
pub const usb_descriptor_type_USB_DT_INTERFACE: usb_descriptor_type = 4;
pub const usb_descriptor_type_USB_DT_ENDPOINT: usb_descriptor_type = 5;
pub const usb_descriptor_type_USB_DT_DEVICE_QUALIFIER: usb_descriptor_type = 6;
pub const usb_descriptor_type_USB_DT_OTHER_SPEED_CONFIG: usb_descriptor_type = 7;
pub const usb_descriptor_type_USB_DT_INTERFACE_POWER: usb_descriptor_type = 8;
pub const usb_descriptor_type_USB_DT_OTG: usb_descriptor_type = 9;
pub const usb_descriptor_type_USB_DT_DEBUG: usb_descriptor_type = 10;
pub const usb_descriptor_type_USB_DT_IAD: usb_descriptor_type = 11;
pub const usb_descriptor_type_USB_DT_BOS: usb_descriptor_type = 15;
pub const usb_descriptor_type_USB_DT_DEV_CAP: usb_descriptor_type = 16;
pub const usb_descriptor_type_USB_DT_SS_EP_COMPANION: usb_descriptor_type = 48;
#[doc = " \\brief Standard USB descriptor types"]
pub type usb_descriptor_type = u32;
pub const usb_capability_type_USB_CAPT_WIRELESS: usb_capability_type = 1;
pub const usb_capability_type_USB_CAPT_2_0_EXT: usb_capability_type = 2;
pub const usb_capability_type_USB_CAPT_SUPER_SPEED: usb_capability_type = 3;
pub const usb_capability_type_USB_CAPT_CONTAINER_ID: usb_capability_type = 4;
#[doc = " \\brief Capability types"]
pub type usb_capability_type = u32;
pub const usb_2_0_ext_attr_USB_2_0_EXT_LPM_SP: usb_2_0_ext_attr = 1;
#[doc = " \\brief USB 2.0 Extension attributes"]
pub type usb_2_0_ext_attr = u32;
pub const usb_ss_cap_attr_USB_SS_LTM_SP: usb_ss_cap_attr = 0;
#[doc = " \\brief USB SuperSpeed Capability attributes"]
pub type usb_ss_cap_attr = u32;
pub const usb_speed_sp_USB_SPEED_LOW_SP: usb_speed_sp = 1;
pub const usb_speed_sp_USB_SPEED_LS_SP: usb_speed_sp = 1;
pub const usb_speed_sp_USB_SPEED_FULL_SP: usb_speed_sp = 2;
pub const usb_speed_sp_USB_SPEED_FS_SP: usb_speed_sp = 2;
pub const usb_speed_sp_USB_SPEED_HIGH_SP: usb_speed_sp = 4;
pub const usb_speed_sp_USB_SPEED_HS_SP: usb_speed_sp = 4;
pub const usb_speed_sp_USB_SPEED_SUPER_SP: usb_speed_sp = 8;
pub const usb_speed_sp_USB_SPEED_SS_SP: usb_speed_sp = 8;
#[doc = " \\brief USB Speed Supports"]
pub type usb_speed_sp = u32;
pub const usb_ep_type_USB_EP_TYPE_CONTROL: usb_ep_type = 0;
pub const usb_ep_type_USB_EP_TYPE_ISOCHRONOUS: usb_ep_type = 1;
pub const usb_ep_type_USB_EP_TYPE_BULK: usb_ep_type = 2;
pub const usb_ep_type_USB_EP_TYPE_INTERRUPT: usb_ep_type = 3;
pub const usb_ep_type_USB_EP_TYPE_MASK: usb_ep_type = 3;
#[doc = " \\brief Standard USB endpoint transfer types"]
pub type usb_ep_type = u32;
pub const usb_ep_int_type_USB_EP_INT_T_PERIODIC: usb_ep_int_type = 0;
pub const usb_ep_int_type_USB_EP_INT_T_NOTIFICATION: usb_ep_int_type = 1;
pub const usb_ep_int_type_USB_EP_INT_T_MASK: usb_ep_int_type = 3;
#[doc = " \\brief USB endpoint interrupt types"]
pub type usb_ep_int_type = u32;
pub const usb_ep_sync_type_USB_EP_SYNC_T_NO: usb_ep_sync_type = 0;
pub const usb_ep_sync_type_USB_EP_SYNC_T_ASYNC: usb_ep_sync_type = 2;
pub const usb_ep_sync_type_USB_EP_SYNC_T_ADAPTIVE: usb_ep_sync_type = 2;
pub const usb_ep_sync_type_USB_EP_SYNC_T_SYNC: usb_ep_sync_type = 3;
pub const usb_ep_sync_type_USB_EP_SYNC_T_MASK: usb_ep_sync_type = 3;
#[doc = " \\brief Standard USB endpoint synchronization types"]
pub type usb_ep_sync_type = u32;
pub const usb_ep_usage_type_USB_EP_USAGE_T_DATA: usb_ep_usage_type = 0;
pub const usb_ep_usage_type_USB_EP_USAGE_T_FEEDBACK: usb_ep_usage_type = 1;
pub const usb_ep_usage_type_USB_EP_USAGE_T_FEEDBACK_DATA: usb_ep_usage_type = 2;
pub const usb_ep_usage_type_USB_EP_USAGE_T_MASK: usb_ep_usage_type = 3;
#[doc = " \\brief Standard USB endpoint usage types"]
pub type usb_ep_usage_type = u32;
#[doc = "< English (United States)"]
pub const usb_langid_USB_LANGID_EN_US: usb_langid = 1033;
#[doc = " \\brief Standard USB language IDs for string descriptors"]
pub type usb_langid = u32;
#[doc = " \\brief A USB Device SETUP request"]
#[doc = ""]
#[doc = " The data payload of SETUP packets always follows this structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_req {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub __bindgen_anon_1: usb_req__bindgen_ty_1,
    pub __bindgen_anon_2: usb_req__bindgen_ty_2,
    pub __bindgen_anon_3: usb_req__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_req__bindgen_ty_1 {
    pub wValue: le16_t,
    pub wValueBytes: usb_req__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_req__bindgen_ty_1__bindgen_ty_1 {
    pub l: u8,
    pub h: u8,
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_req__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_1__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_1__bindgen_ty_1>())).h as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_req__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_req__bindgen_ty_1>())).wValue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_1),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_1>())).wValueBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_1),
            "::",
            stringify!(wValueBytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_req__bindgen_ty_2 {
    pub wIndex: le16_t,
    pub wIndexBytes: usb_req__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_req__bindgen_ty_2__bindgen_ty_1 {
    pub l: u8,
    pub h: u8,
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_req__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_2__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_2__bindgen_ty_1>())).h as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_req__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_req__bindgen_ty_2>())).wIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_2),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_2>())).wIndexBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_2),
            "::",
            stringify!(wIndexBytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_req__bindgen_ty_3 {
    pub wLength: le16_t,
    pub wLengthBytes: usb_req__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_req__bindgen_ty_3__bindgen_ty_1 {
    pub l: u8,
    pub h: u8,
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_3__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_req__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_3__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_3__bindgen_ty_1>())).h as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_req__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<usb_req__bindgen_ty_3>(),
        2usize,
        concat!("Size of: ", stringify!(usb_req__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req__bindgen_ty_3>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_req__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_req__bindgen_ty_3>())).wLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_3),
            "::",
            stringify!(wLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_req__bindgen_ty_3>())).wLengthBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req__bindgen_ty_3),
            "::",
            stringify!(wLengthBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_req() {
    assert_eq!(
        ::core::mem::size_of::<usb_req>(),
        8usize,
        concat!("Size of: ", stringify!(usb_req))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_req>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_req))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_req>())).bmRequestType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_req>())).bRequest as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_req),
            "::",
            stringify!(bRequest)
        )
    );
}
pub type usb_req_t = usb_req;
#[doc = " \\brief Standard USB device descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_dev_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUSB: le16_t,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub idVendor: le16_t,
    pub idProduct: le16_t,
    pub bcdDevice: le16_t,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_dev_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_dev_desc>(),
        18usize,
        concat!("Size of: ", stringify!(usb_dev_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_dev_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_dev_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bDeviceClass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bDeviceSubClass as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bDeviceProtocol as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bMaxPacketSize0 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).idVendor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).idProduct as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).bcdDevice as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).iManufacturer as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).iProduct as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_desc>())).iSerialNumber as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_desc>())).bNumConfigurations as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_desc),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
pub type usb_dev_desc_t = usb_dev_desc;
#[doc = " \\brief Binary device Object Store (BOS) descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_bos_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: le16_t,
    pub bNumDeviceCaps: u8,
}
#[test]
fn bindgen_test_layout_usb_bos_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_bos_desc>(),
        5usize,
        concat!("Size of: ", stringify!(usb_bos_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_bos_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_bos_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_bos_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_bos_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_bos_desc>())).wTotalLength as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_desc),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_bos_desc>())).bNumDeviceCaps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_bos_desc),
            "::",
            stringify!(bNumDeviceCaps)
        )
    );
}
pub type usb_bos_desc_t = usb_bos_desc;
#[doc = " \\brief Device Capability Descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cap_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub Vars: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_usb_cap_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_cap_desc>(),
        4usize,
        concat!("Size of: ", stringify!(usb_cap_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cap_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cap_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cap_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cap_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cap_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cap_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cap_desc>())).bDevCapabilityType as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cap_desc),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cap_desc>())).Vars as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cap_desc),
            "::",
            stringify!(Vars)
        )
    );
}
pub type usb_cap_desc_t = usb_cap_desc;
#[doc = " \\brief USB 2.0 Extension Descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_2_0_ext {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub bmAttributes: u32,
}
#[test]
fn bindgen_test_layout_usb_2_0_ext() {
    assert_eq!(
        ::core::mem::size_of::<usb_2_0_ext>(),
        7usize,
        concat!("Size of: ", stringify!(usb_2_0_ext))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_2_0_ext>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_2_0_ext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_2_0_ext>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_2_0_ext),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_2_0_ext>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_2_0_ext),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_2_0_ext>())).bDevCapabilityType as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_2_0_ext),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_2_0_ext>())).bmAttributes as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_2_0_ext),
            "::",
            stringify!(bmAttributes)
        )
    );
}
pub type usb_2_0_ext_t = usb_2_0_ext;
#[doc = " \\brief LPM Device Capabilities descriptor structure"]
pub type usb_lpm_cap_desc_t = usb_2_0_ext;
#[doc = " \\brief SuperSpeed USB Device Capability structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_cap_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub bmAttributes: u8,
    pub wSpeedsSupported: le16_t,
    pub bFunctionalitySupport: u8,
    pub bU1DevExitLat: u8,
    pub bU2DevExitLat: u8,
}
#[test]
fn bindgen_test_layout_usb_ss_cap_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_ss_cap_desc>(),
        9usize,
        concat!("Size of: ", stringify!(usb_ss_cap_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_ss_cap_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ss_cap_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_cap_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_cap_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_cap_desc>())).bDevCapabilityType as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_cap_desc>())).bmAttributes as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_cap_desc>())).wSpeedsSupported as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(wSpeedsSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_cap_desc>())).bFunctionalitySupport as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bFunctionalitySupport)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_cap_desc>())).bU1DevExitLat as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bU1DevExitLat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_cap_desc>())).bU2DevExitLat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_cap_desc),
            "::",
            stringify!(bU2DevExitLat)
        )
    );
}
pub type usb_ss_cap_desc_t = usb_ss_cap_desc;
#[doc = " \\brief USB Container ID Descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_container_id_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub bReserved: u8,
    pub ContainerID: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_usb_container_id_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_container_id_desc>(),
        20usize,
        concat!("Size of: ", stringify!(usb_container_id_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_container_id_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_container_id_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_container_id_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_container_id_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_container_id_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_container_id_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_container_id_desc>())).bDevCapabilityType as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_container_id_desc),
            "::",
            stringify!(bDevCapabilityType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_container_id_desc>())).bReserved as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_container_id_desc),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_container_id_desc>())).ContainerID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_container_id_desc),
            "::",
            stringify!(ContainerID)
        )
    );
}
pub type usb_container_id_desc_t = usb_container_id_desc;
#[doc = " \\brief Standard USB device qualifier descriptor structure"]
#[doc = ""]
#[doc = " This descriptor contains information about the device when running at"]
#[doc = " the \"other\" speed (i.e. if the device is currently operating at high"]
#[doc = " speed, this descriptor can be used to determine what would change if"]
#[doc = " the device was operating at full speed.)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_dev_qual_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUSB: le16_t,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub bNumConfigurations: u8,
    pub bReserved: u8,
}
#[test]
fn bindgen_test_layout_usb_dev_qual_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_dev_qual_desc>(),
        10usize,
        concat!("Size of: ", stringify!(usb_dev_qual_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_dev_qual_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_dev_qual_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_qual_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_qual_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_qual_desc>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_qual_desc>())).bDeviceClass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_qual_desc>())).bDeviceSubClass as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_qual_desc>())).bDeviceProtocol as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_qual_desc>())).bMaxPacketSize0 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_dev_qual_desc>())).bNumConfigurations as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bNumConfigurations)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_dev_qual_desc>())).bReserved as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_dev_qual_desc),
            "::",
            stringify!(bReserved)
        )
    );
}
pub type usb_dev_qual_desc_t = usb_dev_qual_desc;
#[doc = " \\brief Standard USB configuration descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_config_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: le16_t,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub bMaxPower: u8,
}
#[test]
fn bindgen_test_layout_usb_config_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_config_desc>(),
        9usize,
        concat!("Size of: ", stringify!(usb_config_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_config_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_config_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).wTotalLength as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).bNumInterfaces as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bNumInterfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_desc>())).bConfigurationValue as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bConfigurationValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).iConfiguration as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(iConfiguration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).bmAttributes as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_desc>())).bMaxPower as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_desc),
            "::",
            stringify!(bMaxPower)
        )
    );
}
pub type usb_config_desc_t = usb_config_desc;
#[doc = " \\brief Standard USB association descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_iad_desc {
    #[doc = "< Size of this descriptor in bytes"]
    pub bLength: u8,
    #[doc = "< Interface descriptor type"]
    pub bDescriptorType: u8,
    #[doc = "< Number of interface"]
    pub bFirstInterface: u8,
    #[doc = "< value to select alternate setting"]
    pub bInterfaceCount: u8,
    #[doc = "< Class code assigned by the USB"]
    pub bFunctionClass: u8,
    #[doc = "< Sub-class code assigned by the USB"]
    pub bFunctionSubClass: u8,
    #[doc = "< Protocol code assigned by the USB"]
    pub bFunctionProtocol: u8,
    #[doc = "< Index of string descriptor"]
    pub iFunction: u8,
}
#[test]
fn bindgen_test_layout_usb_iad_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_iad_desc>(),
        8usize,
        concat!("Size of: ", stringify!(usb_iad_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_iad_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_iad_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bFirstInterface as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bFirstInterface)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bInterfaceCount as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bInterfaceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bFunctionClass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bFunctionClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bFunctionSubClass as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bFunctionSubClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).bFunctionProtocol as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(bFunctionProtocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iad_desc>())).iFunction as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iad_desc),
            "::",
            stringify!(iFunction)
        )
    );
}
pub type usb_iad_desc_t = usb_iad_desc;
#[doc = " \\brief Standard USB interface descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_iface_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_iface_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_iface_desc>(),
        9usize,
        concat!("Size of: ", stringify!(usb_iface_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_iface_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_iface_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iface_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iface_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_iface_desc>())).bInterfaceNumber as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_iface_desc>())).bAlternateSetting as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bAlternateSetting)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iface_desc>())).bNumEndpoints as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bNumEndpoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iface_desc>())).bInterfaceClass as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_iface_desc>())).bInterfaceSubClass as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_iface_desc>())).bInterfaceProtocol as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_iface_desc>())).iInterface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_iface_desc),
            "::",
            stringify!(iInterface)
        )
    );
}
pub type usb_iface_desc_t = usb_iface_desc;
#[doc = " \\brief Standard USB endpoint descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ep_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: le16_t,
    pub bInterval: u8,
}
#[test]
fn bindgen_test_layout_usb_ep_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_ep_desc>(),
        7usize,
        concat!("Size of: ", stringify!(usb_ep_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_ep_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ep_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).bEndpointAddress as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).bmAttributes as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).wMaxPacketSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ep_desc>())).bInterval as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ep_desc),
            "::",
            stringify!(bInterval)
        )
    );
}
pub type usb_ep_desc_t = usb_ep_desc;
#[doc = " \\brief SuperSpeed Endpoint Companion descriptor structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_ss_ep_comp_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bMaxBurst: u8,
    pub bmAttributes: u8,
    pub wBytesPerInterval: le16_t,
}
#[test]
fn bindgen_test_layout_usb_ss_ep_comp_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_ss_ep_comp_desc>(),
        6usize,
        concat!("Size of: ", stringify!(usb_ss_ep_comp_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_ss_ep_comp_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_ss_ep_comp_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_ep_comp_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_ep_comp_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_ss_ep_comp_desc>())).bMaxBurst as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_desc),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_ep_comp_desc>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_desc),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_ep_comp_desc>())).wBytesPerInterval as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_ep_comp_desc),
            "::",
            stringify!(wBytesPerInterval)
        )
    );
}
pub type usb_ss_ep_comp_desc_t = usb_ss_ep_comp_desc;
#[doc = " \\brief LPM Token bmAttributes structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_lpm_attributes {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_usb_lpm_attributes() {
    assert_eq!(
        ::core::mem::size_of::<usb_lpm_attributes>(),
        2usize,
        concat!("Size of: ", stringify!(usb_lpm_attributes))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_lpm_attributes>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_lpm_attributes))
    );
}
impl usb_lpm_attributes {
    #[inline]
    pub fn bLinkState(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_bLinkState(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn HIRD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_HIRD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bRemoteWake(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bRemoteWake(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bLinkState: u8,
        HIRD: u8,
        bRemoteWake: u8,
        Reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let bLinkState: u8 = unsafe { ::core::mem::transmute(bLinkState) };
            bLinkState as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let HIRD: u8 = unsafe { ::core::mem::transmute(HIRD) };
            HIRD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bRemoteWake: u8 = unsafe { ::core::mem::transmute(bRemoteWake) };
            bRemoteWake as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type usb_lpm_attributes_t = usb_lpm_attributes;
#[doc = " \\brief A standard USB string descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_str_desc {
    pub bLength: u8,
    pub bDescriptorType: u8,
}
#[test]
fn bindgen_test_layout_usb_str_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_str_desc>(),
        2usize,
        concat!("Size of: ", stringify!(usb_str_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_str_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_str_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_str_desc>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_str_desc),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_str_desc>())).bDescriptorType as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_str_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
}
pub type usb_str_desc_t = usb_str_desc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_str_langid_desc {
    pub desc: usb_str_desc_t,
    pub string: [le16_t; 1usize],
}
#[test]
fn bindgen_test_layout_usb_str_langid_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_str_langid_desc>(),
        4usize,
        concat!("Size of: ", stringify!(usb_str_langid_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_str_langid_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_str_langid_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_str_langid_desc>())).desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_str_langid_desc),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_str_langid_desc>())).string as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_str_langid_desc),
            "::",
            stringify!(string)
        )
    );
}
pub type usb_str_langid_desc_t = usb_str_langid_desc;
extern "C" {
    #[doc = " \\brief Find specific USB Descriptor by its type"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\param[in] type The descriptor type expected"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval NULL if not found"]
    pub fn usb_find_desc(desc: *mut u8, eof: *mut u8, type_: u8) -> *mut u8;
}
extern "C" {
    #[doc = " Get interface descriptor next to the specified one (by interface number)"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\param[in] iface_n The interface number to check"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval >= eof if not found"]
    pub fn usb_find_iface_after(desc: *mut u8, eof: *mut u8, iface_n: u8) -> *mut u8;
}
extern "C" {
    #[doc = " Find endpoint descriptor, breaks if interface descriptor detected"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval NULL if not found"]
    pub fn usb_find_ep_desc(desc: *mut u8, eof: *mut u8) -> *mut u8;
}
extern "C" {
    #[doc = " Find configuration descriptor by its configuration number"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\param[in] cfg_value The configure value expected"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval NULL if not found"]
    pub fn usb_find_cfg_desc(desc: *mut u8, eof: *mut u8, cfg_value: u8) -> *mut u8;
}
extern "C" {
    #[doc = " Find other speed configuration descriptor by its configuration number"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\param[in] cfg_value The configure value expected"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval NULL if not found"]
    pub fn usb_find_othspdcfg_desc(desc: *mut u8, eof: *mut u8, cfg_value: u8) -> *mut u8;
}
extern "C" {
    #[doc = " Find string descriptor by its index"]
    #[doc = "  \\param[in] desc Byte pointer to the descriptor start address"]
    #[doc = "  \\param[in] eof  Byte pointer to the descriptor end address"]
    #[doc = "  \\param[in] str_index The string index expected"]
    #[doc = "  \\return Pointer to the descriptor"]
    #[doc = "  \\retval NULL if not found"]
    pub fn usb_find_str_desc(desc: *mut u8, eof: *mut u8, str_index: u8) -> *mut u8;
}
pub const usbd_state_USBD_S_OFF: usbd_state = 0;
pub const usbd_state_USBD_S_POWER: usbd_state = 1;
pub const usbd_state_USBD_S_DEFAULT: usbd_state = 2;
pub const usbd_state_USBD_S_ADDRESS: usbd_state = 3;
pub const usbd_state_USBD_S_CONFIG: usbd_state = 4;
pub const usbd_state_USBD_S_SUSPEND: usbd_state = 16;
#[doc = " USB device states."]
pub type usbd_state = u32;
pub const usbdc_handler_type_USBDC_HDL_SOF: usbdc_handler_type = 0;
pub const usbdc_handler_type_USBDC_HDL_REQ: usbdc_handler_type = 1;
pub const usbdc_handler_type_USBDC_HDL_CHANGE: usbdc_handler_type = 2;
#[doc = " USB device core handler type."]
pub type usbdc_handler_type = u32;
#[doc = " Change of connection, detected by vbus."]
pub const usbdc_change_type_USBDC_C_CONN: usbdc_change_type = 0;
#[doc = " Change of state, by RESET, SetAddress(), SetConfig()."]
pub const usbdc_change_type_USBDC_C_STATE: usbdc_change_type = 1;
#[doc = " Change of power."]
pub const usbdc_change_type_USBDC_C_POWER: usbdc_change_type = 2;
#[doc = " Change of remote wakeup setting."]
pub const usbdc_change_type_USBDC_C_REMOTE_WAKEUP: usbdc_change_type = 3;
#[doc = " USB device core change notification type."]
pub type usbdc_change_type = u32;
pub const usbdc_power_type_USBDC_ACTIVE: usbdc_power_type = 0;
pub const usbdc_power_type_USBDC_SLEEP: usbdc_power_type = 1;
pub const usbdc_power_type_USBDC_SUSPEND: usbdc_power_type = 2;
#[doc = " Power change."]
pub type usbdc_power_type = u32;
#[doc = " Enable the function."]
#[doc = "  int32_t ctrl(usbdf, USBDF_ENABLE, struct usbd_descriptors *desc);"]
#[doc = "  Parameter holds interface descriptor and"]
#[doc = "  configuration descriptor end position."]
pub const usbdf_control_USBDF_ENABLE: usbdf_control = 0;
#[doc = " Disable the function."]
#[doc = "  int32_t ctrl(usbdf, USBDF_DISABLE, struct usbd_descriptors *desc);"]
#[doc = "  Parameter holds interface descriptor and"]
#[doc = "  configuration descriptor end position."]
#[doc = "  Input NULL to force disable the function anyway."]
pub const usbdf_control_USBDF_DISABLE: usbdf_control = 1;
#[doc = " Get interface alternate setting."]
#[doc = "  int32_t ctrl(usbdf, USBDF_GET_IFACE, struct usb_req *req);"]
#[doc = "  Parameter holds interface number who should return"]
#[doc = "  the alternate setting."]
pub const usbdf_control_USBDF_GET_IFACE: usbdf_control = 2;
#[doc = " USB device general function control code."]
pub type usbdf_control = u32;
#[doc = " Describes a list of USB descriptors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_descriptors {
    #[doc = " Pointer to Start of Descriptors."]
    pub sod: *mut u8,
    #[doc = " Pointer to End of Descriptors."]
    pub eod: *mut u8,
}
#[test]
fn bindgen_test_layout_usbd_descriptors() {
    assert_eq!(
        ::core::mem::size_of::<usbd_descriptors>(),
        8usize,
        concat!("Size of: ", stringify!(usbd_descriptors))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_descriptors>(),
        4usize,
        concat!("Alignment of ", stringify!(usbd_descriptors))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbd_descriptors>())).sod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_descriptors),
            "::",
            stringify!(sod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbd_descriptors>())).eod as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_descriptors),
            "::",
            stringify!(eod)
        )
    );
}
#[doc = " Describes the USB device core descriptors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbdc_descriptors {
    pub ls_fs: *mut usbd_descriptors,
}
#[test]
fn bindgen_test_layout_usbdc_descriptors() {
    assert_eq!(
        ::core::mem::size_of::<usbdc_descriptors>(),
        4usize,
        concat!("Size of: ", stringify!(usbdc_descriptors))
    );
    assert_eq!(
        ::core::mem::align_of::<usbdc_descriptors>(),
        4usize,
        concat!("Alignment of ", stringify!(usbdc_descriptors))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdc_descriptors>())).ls_fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdc_descriptors),
            "::",
            stringify!(ls_fs)
        )
    );
}
#[doc = " Describes a list of core handler descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbdc_handler {
    #[doc = " Pointer to next handler."]
    pub next: *mut usbdc_handler,
    #[doc = " Pointer to handler function."]
    pub func: FUNC_PTR,
}
#[test]
fn bindgen_test_layout_usbdc_handler() {
    assert_eq!(
        ::core::mem::size_of::<usbdc_handler>(),
        8usize,
        concat!("Size of: ", stringify!(usbdc_handler))
    );
    assert_eq!(
        ::core::mem::align_of::<usbdc_handler>(),
        4usize,
        concat!("Alignment of ", stringify!(usbdc_handler))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdc_handler>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdc_handler),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdc_handler>())).func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdc_handler),
            "::",
            stringify!(func)
        )
    );
}
#[doc = " SOF handling function."]
pub type usbdc_sof_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " REQ handling function."]
pub type usbdc_req_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, req: *mut usb_req, stage: usb_ctrl_stage) -> i32,
>;
#[doc = " Change notification callback function."]
pub type usbdc_change_cb_t =
    ::core::option::Option<unsafe extern "C" fn(change: usbdc_change_type, value: u32)>;
#[doc = " Control function for USB device general function driver."]
pub type usbdf_control_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        drv: *mut usbdf_driver,
        ctrl: usbdf_control,
        param: *mut cty::c_void,
    ) -> i32,
>;
#[doc = " Forward declaration for USB device function driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbdf_driver {
    #[doc = " Pointer to next function."]
    pub next: *mut usbdf_driver,
    #[doc = " Pointer to control function."]
    pub ctrl: usbdf_control_cb_t,
    #[doc = " Pointer to function driver specific data."]
    pub func_data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_usbdf_driver() {
    assert_eq!(
        ::core::mem::size_of::<usbdf_driver>(),
        12usize,
        concat!("Size of: ", stringify!(usbdf_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<usbdf_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(usbdf_driver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdf_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdf_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdf_driver>())).ctrl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdf_driver),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usbdf_driver>())).func_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbdf_driver),
            "::",
            stringify!(func_data)
        )
    );
}
extern "C" {
    #[doc = " \\brief Register the handler"]
    #[doc = " \\param[in] type USB device core handler type."]
    #[doc = " \\param[in] h Pointer to usb device core handler."]
    pub fn usbdc_register_handler(type_: usbdc_handler_type, h: *const usbdc_handler);
}
extern "C" {
    #[doc = " \\brief Unregister the handler"]
    #[doc = " \\param[in] type USB device core handler type."]
    #[doc = " \\param[in] h Pointer to usb device core handler."]
    pub fn usbdc_unregister_handler(type_: usbdc_handler_type, h: *const usbdc_handler);
}
extern "C" {
    #[doc = " \\brief Initialize the USB device core driver"]
    #[doc = " \\param[in] ctrl_buf Pointer to a buffer to be used by usb device ctrl endpoint"]
    #[doc = "  Note: the size of ctrl_buf should not be less than the size of EP0"]
    #[doc = " \\return Operation status."]
    pub fn usbdc_init(ctrl_buf: *mut u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize the USB device core driver"]
    #[doc = " \\return Operation status."]
    pub fn usbdc_deinit() -> i32;
}
extern "C" {
    #[doc = " \\brief Register function support of a USB device function"]
    #[doc = " \\param[in] func Pointer to usb device function driver structure"]
    pub fn usbdc_register_function(func: *mut usbdf_driver);
}
extern "C" {
    #[doc = " \\brief Unregister function support of a USB device function"]
    #[doc = " \\param[in] func Pointer to usb device function driver structure"]
    pub fn usbdc_unregister_function(func: *mut usbdf_driver);
}
extern "C" {
    #[doc = " \\brief Validate the descriptors"]
    #[doc = " \\param[in] desces Pointer to usb device core descriptors"]
    #[doc = " \\return Operation status."]
    pub fn usbdc_validate_desces(desces: *mut usbd_descriptors) -> i32;
}
extern "C" {
    #[doc = " \\brief Issue USB device data transfer"]
    #[doc = " \\param[in] ep endpointer address."]
    #[doc = " \\param[in] buf Pointer to data transfer buffer."]
    #[doc = " \\param[in] size the size of data transfer."]
    #[doc = " \\param[in] zlp flag to indicate zero length packet."]
    #[doc = " \\return Operation status."]
    pub fn usbdc_xfer(ep: u8, buf: *mut u8, size: u32, zlp: bool) -> i32;
}
extern "C" {
    #[doc = " \\brief Start the USB device driver with specific descriptors set"]
    #[doc = " \\param[in] desces Pointer to usb device core descriptors (FS/LS),"]
    #[doc = "                   or pointer to array of core descriptors (HS), the"]
    #[doc = "                   very first one includes device descriptor, FS/LS"]
    #[doc = "                   configuration descriptor, string descriptor, and"]
    #[doc = "                   may include device qualifier and other speed"]
    #[doc = "                   configuration descriptor; the second one includes"]
    #[doc = "                   high speed used descriptors."]
    #[doc = "                   Note that string descriptor should be included in"]
    #[doc = "                   first place."]
    #[doc = " \\return Operation status."]
    pub fn usbdc_start(desces: *mut usbd_descriptors) -> i32;
}
extern "C" {
    #[doc = " \\brief Stop the USB device driver"]
    #[doc = " \\return Operation status."]
    pub fn usbdc_stop() -> i32;
}
extern "C" {
    #[doc = " \\brief Attach the USB device to host"]
    pub fn usbdc_attach();
}
extern "C" {
    #[doc = " \\brief Detach the USB device from host"]
    pub fn usbdc_detach();
}
extern "C" {
    #[doc = " \\brief Send remote wakeup to host"]
    pub fn usbdc_remotewakeup();
}
extern "C" {
    #[doc = " \\brief Return USB device ctrl end pointer buffer start address"]
    pub fn usbdc_get_ctrl_buffer() -> *mut u8;
}
extern "C" {
    #[doc = " \\brief Return current USB state"]
    pub fn usbdc_get_state() -> u8;
}
extern "C" {
    #[doc = " \\brief Return version"]
    pub fn usbdc_get_version() -> u32;
}
#[doc = "! CDC Header Functional Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_hdr_desc {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bcdCDC: le16_t,
}
#[test]
fn bindgen_test_layout_usb_cdc_hdr_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_hdr_desc>(),
        5usize,
        concat!("Size of: ", stringify!(usb_cdc_hdr_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_hdr_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_hdr_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_hdr_desc>())).bFunctionLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_hdr_desc),
            "::",
            stringify!(bFunctionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_hdr_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_hdr_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_hdr_desc>())).bDescriptorSubtype as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_hdr_desc),
            "::",
            stringify!(bDescriptorSubtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_hdr_desc>())).bcdCDC as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_hdr_desc),
            "::",
            stringify!(bcdCDC)
        )
    );
}
pub type usb_cdc_hdr_desc_t = usb_cdc_hdr_desc;
#[doc = "! CDC Call Management Functional Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_call_mgmt_desc {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
    pub bDataInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_call_mgmt_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_call_mgmt_desc>(),
        5usize,
        concat!("Size of: ", stringify!(usb_cdc_call_mgmt_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_call_mgmt_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_call_mgmt_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_call_mgmt_desc>())).bFunctionLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_call_mgmt_desc),
            "::",
            stringify!(bFunctionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_call_mgmt_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_call_mgmt_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_call_mgmt_desc>())).bDescriptorSubtype as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_call_mgmt_desc),
            "::",
            stringify!(bDescriptorSubtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_call_mgmt_desc>())).bmCapabilities as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_call_mgmt_desc),
            "::",
            stringify!(bmCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_call_mgmt_desc>())).bDataInterface as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_call_mgmt_desc),
            "::",
            stringify!(bDataInterface)
        )
    );
}
pub type usb_cdc_call_mgmt_desc_t = usb_cdc_call_mgmt_desc;
#[doc = "! CDC ACM Functional Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_acm_desc {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_acm_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_acm_desc>(),
        4usize,
        concat!("Size of: ", stringify!(usb_cdc_acm_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_acm_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_acm_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_acm_desc>())).bFunctionLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_acm_desc),
            "::",
            stringify!(bFunctionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_acm_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_acm_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_acm_desc>())).bDescriptorSubtype as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_acm_desc),
            "::",
            stringify!(bDescriptorSubtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_acm_desc>())).bmCapabilities as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_acm_desc),
            "::",
            stringify!(bmCapabilities)
        )
    );
}
pub type usb_cdc_acm_desc_t = usb_cdc_acm_desc;
#[doc = "! CDC Union Functional Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_union_desc {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bMasterInterface: u8,
    pub bSlaveInterface0: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_union_desc() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_union_desc>(),
        5usize,
        concat!("Size of: ", stringify!(usb_cdc_union_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_union_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_union_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_union_desc>())).bFunctionLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_union_desc),
            "::",
            stringify!(bFunctionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_union_desc>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_union_desc),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_union_desc>())).bDescriptorSubtype as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_union_desc),
            "::",
            stringify!(bDescriptorSubtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_union_desc>())).bMasterInterface as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_union_desc),
            "::",
            stringify!(bMasterInterface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_union_desc>())).bSlaveInterface0 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_union_desc),
            "::",
            stringify!(bSlaveInterface0)
        )
    );
}
pub type usb_cdc_union_desc_t = usb_cdc_union_desc;
#[doc = "! Line Coding structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_line_coding {
    #[doc = "!< Data rate, bits per second"]
    pub dwDTERate: le32_t,
    #[doc = "!< 0-1 Stop bit,1-1.5 Stop bits,2-2 Stop bits"]
    pub bCharFormat: u8,
    #[doc = "!< 0-None,1-Odd,2-Even,3-Mark,4-Space"]
    pub bParityType: u8,
    #[doc = "!< 5,6,7,8 or 16"]
    pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_line_coding>(),
        7usize,
        concat!("Size of: ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_line_coding>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_line_coding>())).dwDTERate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(dwDTERate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_line_coding>())).bCharFormat as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bCharFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_line_coding>())).bParityType as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bParityType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_line_coding>())).bDataBits as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bDataBits)
        )
    );
}
pub type usb_cdc_line_coding_t = usb_cdc_line_coding;
#[doc = "!< 1 stop bit"]
pub const cdc_char_format_CDC_STOP_BITS_1: cdc_char_format = 0;
#[doc = "!< 1.5 stop bits"]
pub const cdc_char_format_CDC_STOP_BITS_1_5: cdc_char_format = 1;
#[doc = "!< 2 stop bits"]
pub const cdc_char_format_CDC_STOP_BITS_2: cdc_char_format = 2;
#[doc = "! Possible values of bCharFormat"]
pub type cdc_char_format = u32;
#[doc = "!< No parity"]
pub const cdc_parity_CDC_PAR_NONE: cdc_parity = 0;
#[doc = "!< Odd parity"]
pub const cdc_parity_CDC_PAR_ODD: cdc_parity = 1;
#[doc = "!< Even parity"]
pub const cdc_parity_CDC_PAR_EVEN: cdc_parity = 2;
#[doc = "!< Parity forced to 1 (mark)"]
pub const cdc_parity_CDC_PAR_MARK: cdc_parity = 3;
#[doc = "!< Parity forced to 0 (space)"]
pub const cdc_parity_CDC_PAR_SPACE: cdc_parity = 4;
#[doc = "! Possible values of bParityType"]
pub type cdc_parity = u32;
#[doc = "! Control signal structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_cdc_control_signal {
    pub __bindgen_anon_1: usb_cdc_control_signal__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_cdc_control_signal__bindgen_ty_1 {
    pub value: le16_t,
    pub modem: usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1,
    pub rs232: usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2,
    pub v24: usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1 {
    pub dte_present: u8,
    pub carrier_ctrl: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1>()))
                .dte_present as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(dte_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1>()))
                .carrier_ctrl as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(carrier_ctrl)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn DTR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RTS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DTR: u8, RTS: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTR: u8 = unsafe { ::core::mem::transmute(DTR) };
            DTR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RTS: u8 = unsafe { ::core::mem::transmute(RTS) };
            RTS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
impl usb_cdc_control_signal__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn s108_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_s108_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn s105(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_s105(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(s108_2: u8, s105: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let s108_2: u8 = unsafe { ::core::mem::transmute(s108_2) };
            s108_2 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let s105: u8 = unsafe { ::core::mem::transmute(s105) };
            s105 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_usb_cdc_control_signal__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_control_signal__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_control_signal__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1>())).modem as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1),
            "::",
            stringify!(modem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1>())).rs232 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1),
            "::",
            stringify!(rs232)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_control_signal__bindgen_ty_1>())).v24 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_control_signal__bindgen_ty_1),
            "::",
            stringify!(v24)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_cdc_control_signal() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_control_signal>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_control_signal))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_control_signal>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_control_signal))
    );
}
pub type usb_cdc_control_signal_t = usb_cdc_control_signal;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_cdc_notify_msg {
    pub bmRequestType: u8,
    pub bNotification: u8,
    pub __bindgen_anon_1: usb_cdc_notify_msg__bindgen_ty_1,
    pub __bindgen_anon_2: usb_cdc_notify_msg__bindgen_ty_2,
    pub __bindgen_anon_3: usb_cdc_notify_msg__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_cdc_notify_msg__bindgen_ty_1 {
    pub wValue: le16_t,
    pub wValueBytes: usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1 {
    pub low: u8,
    pub high: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1>())).low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1>())).high
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_notify_msg__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_1>())).wValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_1>())).wValueBytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_1),
            "::",
            stringify!(wValueBytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_cdc_notify_msg__bindgen_ty_2 {
    pub wIndex: le16_t,
    pub wIndexBytes: usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1 {
    pub low: u8,
    pub high: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1>())).low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1>())).high
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_notify_msg__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_2>())).wIndex as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_2>())).wIndexBytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_2),
            "::",
            stringify!(wIndexBytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_cdc_notify_msg__bindgen_ty_3 {
    pub wLength: le16_t,
    pub wLengthBytes: usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1 {
    pub low: u8,
    pub high: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1>())).low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1>())).high
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg__bindgen_ty_3>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_notify_msg__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_3>())).wLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3),
            "::",
            stringify!(wLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg__bindgen_ty_3>())).wLengthBytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg__bindgen_ty_3),
            "::",
            stringify!(wLengthBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_msg() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_msg>(),
        8usize,
        concat!("Size of: ", stringify!(usb_cdc_notify_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_msg>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_notify_msg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg>())).bmRequestType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_msg>())).bNotification as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_msg),
            "::",
            stringify!(bNotification)
        )
    );
}
pub type usb_cdc_notify_msg_t = usb_cdc_notify_msg;
#[doc = "! UART State Bitmap (cdc spec 1.1 chapter 6.3.5)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union usb_cdc_uart_state {
    pub value: le16_t,
    pub bitmap: usb_cdc_uart_state__bindgen_ty_1,
    pub rs232: usb_cdc_uart_state__bindgen_ty_2,
    pub v24: usb_cdc_uart_state__bindgen_ty_3,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_uart_state__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub bOverRun: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_uart_state__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_uart_state__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_uart_state__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_uart_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_uart_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_uart_state__bindgen_ty_1>())).bOverRun as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state__bindgen_ty_1),
            "::",
            stringify!(bOverRun)
        )
    );
}
impl usb_cdc_uart_state__bindgen_ty_1 {
    #[inline]
    pub fn bRxCarrier(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bRxCarrier(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bTxCarrier(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bTxCarrier(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bBreak(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bBreak(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bRingSignal(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bRingSignal(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFraming(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bFraming(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bParity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bParity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bRxCarrier: u8,
        bTxCarrier: u8,
        bBreak: u8,
        bRingSignal: u8,
        bFraming: u8,
        bParity: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bRxCarrier: u8 = unsafe { ::core::mem::transmute(bRxCarrier) };
            bRxCarrier as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bTxCarrier: u8 = unsafe { ::core::mem::transmute(bTxCarrier) };
            bTxCarrier as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bBreak: u8 = unsafe { ::core::mem::transmute(bBreak) };
            bBreak as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bRingSignal: u8 = unsafe { ::core::mem::transmute(bRingSignal) };
            bRingSignal as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bFraming: u8 = unsafe { ::core::mem::transmute(bFraming) };
            bFraming as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bParity: u8 = unsafe { ::core::mem::transmute(bParity) };
            bParity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_uart_state__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub bOverRun: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_uart_state__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_uart_state__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_uart_state__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_uart_state__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_uart_state__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_uart_state__bindgen_ty_2>())).bOverRun as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state__bindgen_ty_2),
            "::",
            stringify!(bOverRun)
        )
    );
}
impl usb_cdc_uart_state__bindgen_ty_2 {
    #[inline]
    pub fn bDCD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bDCD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bDSR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bDSR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bBreak(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bBreak(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bRingSignal(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bRingSignal(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFraming(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bFraming(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bParity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bParity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bDCD: u8,
        bDSR: u8,
        bBreak: u8,
        bRingSignal: u8,
        bFraming: u8,
        bParity: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bDCD: u8 = unsafe { ::core::mem::transmute(bDCD) };
            bDCD as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bDSR: u8 = unsafe { ::core::mem::transmute(bDSR) };
            bDSR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bBreak: u8 = unsafe { ::core::mem::transmute(bBreak) };
            bBreak as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bRingSignal: u8 = unsafe { ::core::mem::transmute(bRingSignal) };
            bRingSignal as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bFraming: u8 = unsafe { ::core::mem::transmute(bFraming) };
            bFraming as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bParity: u8 = unsafe { ::core::mem::transmute(bParity) };
            bParity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_uart_state__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub bOverRun: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_uart_state__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_uart_state__bindgen_ty_3>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_uart_state__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_uart_state__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usb_cdc_uart_state__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_uart_state__bindgen_ty_3>())).bOverRun as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state__bindgen_ty_3),
            "::",
            stringify!(bOverRun)
        )
    );
}
impl usb_cdc_uart_state__bindgen_ty_3 {
    #[inline]
    pub fn bS109(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bS109(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bS106(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bS106(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bBreak(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bBreak(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bRingSignal(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bRingSignal(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFraming(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bFraming(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bParity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bParity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bS109: u8,
        bS106: u8,
        bBreak: u8,
        bRingSignal: u8,
        bFraming: u8,
        bParity: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bS109: u8 = unsafe { ::core::mem::transmute(bS109) };
            bS109 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bS106: u8 = unsafe { ::core::mem::transmute(bS106) };
            bS106 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bBreak: u8 = unsafe { ::core::mem::transmute(bBreak) };
            bBreak as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bRingSignal: u8 = unsafe { ::core::mem::transmute(bRingSignal) };
            bRingSignal as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bFraming: u8 = unsafe { ::core::mem::transmute(bFraming) };
            bFraming as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bParity: u8 = unsafe { ::core::mem::transmute(bParity) };
            bParity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_usb_cdc_uart_state() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_uart_state>(),
        2usize,
        concat!("Size of: ", stringify!(usb_cdc_uart_state))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_uart_state>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_uart_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_uart_state>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_uart_state>())).bitmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_uart_state>())).rs232 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state),
            "::",
            stringify!(rs232)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_cdc_uart_state>())).v24 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_uart_state),
            "::",
            stringify!(v24)
        )
    );
}
pub type usb_cdc_uart_state_t = usb_cdc_uart_state;
#[doc = "! Hardware handshake support (cdc spec 1.1 chapter 6.3.5)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usb_cdc_notify_serial_state {
    pub header: usb_cdc_notify_msg_t,
    pub state: usb_cdc_uart_state,
}
#[test]
fn bindgen_test_layout_usb_cdc_notify_serial_state() {
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_notify_serial_state>(),
        10usize,
        concat!("Size of: ", stringify!(usb_cdc_notify_serial_state))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_notify_serial_state>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_notify_serial_state))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_serial_state>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_serial_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_cdc_notify_serial_state>())).state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_notify_serial_state),
            "::",
            stringify!(state)
        )
    );
}
pub type usb_cdc_notify_serial_state_t = usb_cdc_notify_serial_state;
pub const cdcdf_acm_cb_type_CDCDF_ACM_CB_READ: cdcdf_acm_cb_type = 0;
pub const cdcdf_acm_cb_type_CDCDF_ACM_CB_WRITE: cdcdf_acm_cb_type = 1;
pub const cdcdf_acm_cb_type_CDCDF_ACM_CB_LINE_CODING_C: cdcdf_acm_cb_type = 2;
pub const cdcdf_acm_cb_type_CDCDF_ACM_CB_STATE_C: cdcdf_acm_cb_type = 3;
#[doc = " CDC ACM Class Callback Type"]
pub type cdcdf_acm_cb_type = u32;
#[doc = " CDC ACM Notify Line State Callback."]
pub type cdcdf_acm_notify_state_t = ::core::option::Option<unsafe extern "C" fn(arg1: u16)>;
#[doc = " CDC ACM Set Line Coding Callback."]
pub type cdcdf_acm_set_line_coding_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut usb_cdc_line_coding) -> bool>;
extern "C" {
    #[doc = " \\brief Initialize the USB CDC ACM Function Driver"]
    #[doc = " \\return Operation status."]
    pub fn cdcdf_acm_init() -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize the USB CDC ACM Function Driver"]
    #[doc = " \\return Operation status."]
    pub fn cdcdf_acm_deinit();
}
extern "C" {
    #[doc = " \\brief USB CDC ACM Function Read Data"]
    #[doc = " \\param[in] buf Pointer to the buffer which receives data"]
    #[doc = " \\param[in] size the size of data to be received"]
    #[doc = " \\return Operation status."]
    pub fn cdcdf_acm_read(buf: *mut u8, size: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief USB CDC ACM Function Write Data"]
    #[doc = " \\param[in] buf Pointer to the buffer which stores data"]
    #[doc = " \\param[in] size the size of data to be sent"]
    #[doc = " \\return Operation status."]
    pub fn cdcdf_acm_write(buf: *mut u8, size: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief USB CDC ACM Stop the currnet data transfer"]
    pub fn cdcdf_acm_stop_xfer();
}
extern "C" {
    #[doc = " \\brief USB CDC ACM Function Register Callback"]
    #[doc = " \\param[in] cb_type Callback type of CDC ACM Function"]
    #[doc = " \\param[in] func Pointer to callback function"]
    #[doc = " \\return Operation status."]
    pub fn cdcdf_acm_register_callback(cb_type: cdcdf_acm_cb_type, func: FUNC_PTR) -> i32;
}
extern "C" {
    #[doc = " \\brief Check whether CDC ACM Function is enabled"]
    #[doc = " \\return Operation status."]
    #[doc = " \\return true CDC ACM Function is enabled"]
    #[doc = " \\return false CDC ACM Function is disabled"]
    pub fn cdcdf_acm_is_enabled() -> bool;
}
extern "C" {
    #[doc = " \\brief Return the CDC ACM line coding structure start address"]
    #[doc = " \\return Pointer to USB CDC ACM line coding data."]
    pub fn cdcdf_acm_get_line_coding() -> *const usb_cdc_line_coding;
}
extern "C" {
    #[doc = " \\brief Return version"]
    pub fn cdcdf_acm_get_version() -> u32;
}
extern "C" {
    pub fn cdcd_acm_example();
}
extern "C" {
    pub fn cdc_device_acm_init();
}
extern "C" {
    #[doc = " \\berif Initialize USB"]
    pub fn usb_init();
}
extern "C" {
    pub fn pin_new(port: gpio_port, pin: u8) -> u8;
}
extern "C" {
    pub fn pin_into_output(pin: u8);
}
extern "C" {
    pub fn pin_into_input(pin: u8);
}
extern "C" {
    pub fn pin_into_pull_down_input(pin: u8);
}
extern "C" {
    pub fn pin_into_pull_up_input(pin: u8);
}
extern "C" {
    pub fn pin_is_high(pin: u8) -> bool;
}
extern "C" {
    pub fn pin_is_low(pin: u8) -> bool;
}
extern "C" {
    pub fn pin_set_high(pin: u8);
}
extern "C" {
    pub fn pin_set_low(pin: u8);
}
extern "C" {
    pub fn pin_toggle(pin: u8);
}
